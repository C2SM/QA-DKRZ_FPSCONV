#! /bin/bash

package=QA-DKRZ  # default

srcPath=local/source  # by default, absolute path comes later

check_targets()
{
  local kind=$1
  local target=$2

  if [ ! -d ${target} ] ; then
    log "${target}: no such directory" FAIL
    return 1
  fi

  local lib=lib

  if [ ${kind} = zlib ] ; then

    if ! ls ${target}/$lib/libz.* &> /dev/null ; then
      lib=lib64
      if ! ls ${target}/$lib/libz.* &> /dev/null ; then
        lib=
        return 1
      fi
    fi

    if ! ls ${target}/include/zlib.h &> /dev/null ; then
      return 1
    fi

  elif [ ${kind} = hdf5 ] ; then

      if ! ls ${target}/$lib/libhdf5* &> /dev/null ; then
      lib=lib64
      if ! ls ${target}/$lib/libhdf5* &> /dev/null ; then
        lib=
        return 1
      fi
    fi

    if ! ls ${target}/include/hdf5.h &> /dev/null ; then
      return 1
    fi

  elif [ ${kind} = netcdf ] ; then

      if ! ls ${target}/$lib/libnetcdf* &> /dev/null ; then
      lib=lib64
      if ! ls ${target}/$lib/libnetcdf* &> /dev/null ; then
        lib=
        return 1
      fi
    fi

    if ! ls ${target}/include/netcdf.h &> /dev/null ; then
      return 1
    fi

  elif [ ${kind} = udunits ] ; then

      if ! ls ${target}/$lib/libudunits2* &> /dev/null ; then
      lib=lib64
      if ! ls ${target}/$lib/libudunits2* &> /dev/null ; then
        lib=
        return 1
      fi
    fi

    if ! ls ${target}/include/udunits2.h &> /dev/null ; then
      return 1
    fi

  fi

  mkdir -p local/$lib

  return 0
}

cmpStrings()
{
  # if comparison is true, then return 0; else 0

  if [ $# -ne 3 ] ; then
    echo 'cmpStrings() requires: string1 operator string2.'
    exit 1
  fi

  local s0=$1
  local op=$2
  local s1=$3

  local res
  res=( $(echo -e "${s0}\n${s1}" | sort ) )

  # equal?
  if [ ${res[0]} = ${res[1]} ] ; then
    if [ ${op} = '-eq' -o ${op:2:1} = 'e' ]  ; then
      return 0
    else
      return 1
    fi
  else
    # strings are not equal, but this was asked
    test ${op} = '-eq' && return 1
  fi

  # convert e.g. -le to -lt
  if [ ${op:2:1} = 'e' ]  ; then
    op=${op:0:2}t
  fi

  local ret=1

  if [ ${op} = '-lt' ] ; then
    test ${res[0]} = $s0 && ret=0
  elif [ ${op} = '-gt' ] ; then
    test ${res[0]} = $s1 && ret=0
  fi

  return $ret
}

descript()
{
  echo -e "\ninstall_local [opts]"
  echo "Usage: Provide access and/or installation of libraries"
  echo "versions zlib-1.2.7, hdf5-1.8.10, and netcdf-4.2.1.1 of higher;"
  echo "by default from ftp://ftp-unidata.ucar.edu/pub/netcdf/... ."
  echo "Static libs will be installed by default in"
  echo "your-path/$package/local. Alternatively, links may be established"
  echo "to external installations or installations may be accomplished"
  echo "in external sources (requires write permission for externals)."
  echo "Priority for compiler settings:"
  echo "    1) those in file $package/install_configure, if existing"
  echo "    2) given in environmental variables CC, CXX, etc."
  echo "    3) find gcc and g++ executables."
  echo "    4) file 'install_configure' ready for special editing; EXIT"
  echo "Options:"
  echo "  --continue_log Iternal processing option."
  echo "  --debug[=script]  Display execution commands."
  echo "  --distclean"
  echo "  --help         Also option -h."
  echo "  --link=str     Hard-link of external NetCDF installation to the directories"
  echo "                 in 'your-path/$package/local'."
  echo "  -q             Quiet for successful operation."
  echo "  --src-path=path To the place were all three packages reside."
}

distclean()
{
  for f in bin include lib lib64 share ; do
    \rm -rf ${QA_SRC}/local/$f
  done
  \rm -f ${QA_SRC}/local/source/INDSTALL_*.log

  local name

  for t in zlib hdf5 netcdf udunits ; do
    eval name=\${curr_${t}}

    bash ${QA_SRC}/scripts/install_local_${t} --distclean  \
       -q --prefix=${prefix} ${QUIET:+-q} --src=$srcPath/$name
  done

  return
}

f()
{
  local c dirs is
  declare -a dirs

  if [ $1 = zlib ] ; then
    if ls ${prefix}/lib/libz.* &> /dev/null \
          || ls ${prefix}/lib64/libz.* &> /dev/null ; then
       log zlib DONE=up-to-date
       return 0  # go on
    fi

    # request: only hard links
    if [ ${#link} -gt 0 ] ; then
      is=f

      if ln_zlib ${link} ; then
        is=t
      fi

      if [ ${is} = t ] ; then
        log "zlib linked to ${link}" DONE
      else
        log "linking of zlib to ${link}" FAIL
        return 1
      fi

      return 0
    fi

    # instance already available?
    dirs=( $( ls -d ${srcPath}/${curr_zlib}* 2> /dev/null) )
  fi

  if [ $1 = hdf5 ] ; then
    if ls ${prefix}/lib/libhdf5.* &> /dev/null \
           || ls ${prefix}/lib64/libhdf5.* &> /dev/null ; then
      log hdf5 DONE=up-to-date
      return 0  # go on
    fi

    # request: only hard links
    if [ ${#link} -gt 0 ] ; then
      is=f

      if ln_hdf5 ${link} ; then
        is=t
      fi

      if [ ${is} = t ] ; then
        log "hdf5 linked to ${link}" DONE
      else
        log "linking of hdf5 to ${link}" FAIL
        return 1
      fi

      return 0
    fi

    # instance already available?
    dirs=( $( ls -d ${srcPath}/${curr_hdf5}* 2> /dev/null) )
  fi

  if [ $1 = netcdf ] ; then
    if ls ${prefix}/lib/libnetcdf.* &> /dev/null \
           || ls ${prefix}/lib64/libnetcdf.* &> /dev/null ; then
      log netcdf DONE=up-to-date
      return 0  # go on
    fi

    # request: only hard links
    if [ ${#link} -gt 0 ] ; then
      is=f

      if ln_netcdf ${link} ; then
        is=t
      fi

      if [ ${is} = t ] ; then
        log "netcdf linked to ${link}" DONE
      else
        log "linking of netcdf to ${link}" FAIL
        return 1
      fi

      return 0
    fi

    # instance already available?
    dirs=( $( ls -d ${srcPath}/${curr_netcdf}* 2> /dev/null) )
  fi

  if [ $1 = udunits ] ; then
    if ls ${prefix}/lib/libudunits2.* &> /dev/null \
           || ls ${prefix}/lib64/libudunits2.* &> /dev/null ; then
      log udunits2 DONE=up-to-date
      return 0  # go on
    fi

    # request: only hard links
    if [ ${#link} -gt 0 ] ; then
      is=f

      if ln_udunits ${link} ; then
        is=t
      fi

      if [ ${is} = t ] ; then
        log "udunits linked to ${link}" DONE
      else
        log "linking of udunits to ${link}" FAIL
        return 1
      fi

      return 0
    fi

    # instance already available?
    dirs=( $( ls -d ${srcPath}/${curr_udunits}* 2> /dev/null) )
  fi

  cd ${srcPath}

  local dir

  local isDownload isTar isTgz

  local isDir isTar isTgz

  if [ ${#dirs[*]} -eq 0 ] ; then
    # get sources from svn
: #    isDownload=t
  else
    for dir in ${dirs[*]##*/} ; do
      test -d ${dir} && isDir=t && break
      if [ -f ${dir} ] ; then
         test ${dir:$(( ${#dir}-2 ))} = 'gz'  && isTgz=t
         test ${dir:$(( ${#dir}-3 ))} = 'tar' && isTar=t
      fi
    done

    test ${isTar:-f} = t && isTgz=
  fi

  local vers name
  eval name=\${curr_${1}}

  if [ ${isDownload:-f} = t ] ; then
    local text
    if [ ${name:0:1} = 'n' ] ; then
      text="www.unidata.ucar.edu./downloads/netcdf/ftp/${name}.tar.gz"
      wget -l1 -np -nc ${text} &> INSTALL_netcdf.log
    elif [ ${name:0:1} = 'h' ] ; then
      cd $srcPath
      text="www.hdfgroup.org/ftp/HDF5/releases/${name}/src/${name}.tar.gz"
      wget -l1 -np -nc ${text} &> INSTALL_hdf.log
    elif [ ${name:0:1} = 'z' ] ; then
      cd $srcPath
      text="www.zlib.net/${name}.tar.gz"
      wget -l1 -np -nc ${text} &> INSTALL_zlib.log
    elif [ ${name:0:1} = 'u' ] ; then
      cd $srcPath
      text="ftp.unidata.ucar/edu/pub/udunits/udunits-2.2.16.tar.gz"
      wget -O - ftp://ftp.unidata.ucar.edu/pub/udunits/udunits-2.2.16.tar.gz \
        | gunzip -c | pax -r
    fi
    if [ $? -eq 0 ] ; then
      log "download: $name.tar.gz" DONE
      isTgz=t
    else
      log "wget -l1 -np -nc ${text}" FAIL
      exit 1
    fi
  fi

  if [ ${isTgz:-f} = t ] ; then
    gzip -d $name.tar.gz
    isTar=t
  fi

  if [ ${isTar:-f} = t ] ; then
    tar xf $name.tar > /dev/null
    \rm -f $name.tar
  fi

  mkdir -p $prefix

  bash ${QA_SRC}/scripts/install_local_${1}  \
     ${isDebug:+--debug} ${QUIET:+-q} \
     --prefix=${prefix} \
     --src=$srcPath/$name

  local status=$?

  if [ ${status} -gt 0 ] ; then
    myStat=FAIL
  else
    myStat=DONE
  fi

  log ${QA_SRC}/scripts/install_local_${1} ${isDebug:+--debug} \
  --prefix=${prefix} ${QUIET:+-q} --src=${srcPath} ${myStat}

  test ${myStat} = FAIL && exit 1

  cd - &> /dev/null

  return $status
}

findPackage()
{
  local packs
  declare -a dirs

  packs=( $( ls -d ${1}/${2}-* | sort ) )
  eval curr_${2}=${packs[0]##*/}

  test ${#packs[*]} -eq 0 && return 0

  return 1
}

formatText()
{
  # format text ready for printing

  # date and host
  local k N n str0 str isWrap

  str0="$*"

  # The total output is subdivided into chunks of pmax characters.
  # Effect of \n is preserved.
  N=$pEnd  # special: taken from log()
  str=

  while : ; do
    k=0  # necessary when skipping the loop

    if [ ${isWrap:-f} = t ] ; then
      n=$(( N - 6 ))
    else
      n=$N
    fi

    if [ ${#str0} -ge $n ] ; then
      # wrap lines with length > N
      for (( ; k < n ; ++k )) ; do
        if [ "${str0:k:2}" = "\n" ] ; then
          str="${str}${str0:0:k}\n"
          str0=${str0:$((k+2))}
          isWrap=f
          continue 2
        fi
      done
    fi

    # the last line
    if [ ${#str0} -le $n ] ; then
      str="${str}${str0}"
      break

    # sub-lines length equals N
    elif [ $k -eq $n -a "${str0:k:2}" = "\n" ] ; then
      str="${str}${str0:0:n}"
      str0=${str0:n}

    # wrap line
    else
      str="${str}${str0:0:n}\n      "
      str0=${str0:n}
      isWrap=t
    fi
  done

  if [ ${isWrap:-f} = t ] ; then
    lastLineSz=$(( ${#str0} + 6 ))
  else
    lastLineSz=${#str0}
  fi

  formattedText=${str}
}

ln_hdf5()
{
  # libs are made in check_targets
  mkdir -p local/include

  local lib=lib  # could be mapped to lib64 by check_targets

  if ! check_targets hdf5 ${link} ; then
    return 1
  fi

  test ${ret} -eq 1 && return 1

  if ls ${link}/$lib/libhdf* &> /dev/null ; then
    ln -f -L -t local/$lib ${link}/$lib/libhdf* 2> /dev/null
  else
    log "no targets to link: ${link}/$lib/libhdf*" FAIL
    return 1
  fi

  if ls ${link}/include/H5* &> /dev/null ; then
    ln -f -L -t local/include ${link}/include/H5* 2> /dev/null
  else
    log "no targets to link: ${link}/include/H5*" FAIL
    return 1
  fi

  if ls ${link}/include/hdf5* &> /dev/null ; then
    ln -f -L -t local/include ${link}/include/hdf5* 2> /dev/null
  else
    log "no targets to link: ${link}/include/hdf5*" FAIL
    return 1
  fi

  if ls ${link}/bin/h5* &> /dev/null ; then
    mkdir  -p local/bin
    ln -f -L -t local/bin ${link}/bin/h5* 2> /dev/null
      # a failure is not essential
  fi

  if ls ${link}/bin/gif2h5* &> /dev/null ; then
    ln -f -L -t local/bin ${link}/bin/gif2h5* 2> /dev/null
  fi

  return 0
}

ln_netcdf()
{
  # libs are made in check_targets
  mkdir -p local/include

  local lib=lib  # could be mapped to lib64 by check_targets

  if ! check_targets netcdf ${link} ; then
    return 1
  fi

  if ls ${link}/$lib/libnetcd* &> /dev/null ; then
    ln -f -L -t local/$lib ${link}/$lib/libnetcd* 2> /dev/null
  else
    log "no targets to link: ${link}/$lib/libnetcdf*" FAIL
    return 1
  fi

  if ls ${link}/include/netcdf* &> /dev/null ; then
    ln -f -L -t local/include ${link}/include/netcdf* 2> /dev/null
  else
    log "no targets to link: ${link}/include/netcdf*" FAIL
    return 1
  fi

  if ls ${link}/bin/nc* &> /dev/null ; then
    mkdir  -p local/bin
    ln -f -L -t local/bin ${link}/bin/nc* 2> /dev/null
    # a failure is not essential
  fi

  if ls ${link}/lib/pkgconfig/netcd* &> /dev/null ; then
    mkdir -p  local/$lib/pkgconfig
    ln -f -L -t local/lib/pkgconfig ${link}/lib/pkgconfig/netcd* 2> /dev/null
    # a failure is not essential
  fi

  return 0
}

ln_udunits()
{
  # libs are made in check_targets
  mkdir -p local/include

  local lib=lib  # could be mapped to lib64 by check_targets

  if ! check_targets udunits ${link} ; then
    return 1
  fi

  if ls ${link}/$lib/libudunits2* &> /dev/null ; then
    ln -f -L -t local/$lib ${link}/$lib/libudunits2* 2> /dev/null
  else
    log "no targets to link: ${link}/$lib/libudunits2*" FAIL
    return 1
  fi

  if ls ${link}/include/udunits2.h &> /dev/null ; then
    ln -f -L -t local/include ${link}/include/udunits* 2> /dev/null
  else
    log "no targets to link: ${link}/include/netcdf*" FAIL
    return 1
  fi

  if ls ${link}/bin/udunits2 &> /dev/null ; then
    mkdir  -p local/bin
    ln -f -L -t local/bin ${link}/bin/udunits2 2> /dev/null
    # a failure is not essential
  fi

  if ls ${link}/lib/pkgconfig/udunits2* &> /dev/null ; then
    mkdir -p  local/$lib/pkgconfig
    ln -f -L -t local/lib/pkgconfig ${link}/lib/pkgconfig/udunits2* 2> /dev/null
    # a failure is not essential
  fi

  return 0
}

ln_zlib()
{
  # libs are made in check_targets
  mkdir -p local/include

  local lib=lib  # could be mapped to lib64 by check_targets

  if ! check_targets zlib ${link} ; then
    return 1
  fi

  if [ -f ${link}/$lib/libz.a ] ; then
    ln -f -t local/$lib ${link}/$lib/libz.a 2> /dev/null
  else
    log "no targets to link: ${link}/$lib/libz.a" FAIL
    return 1
  fi

  if [ -f ${link}/include/zlib.h ] ; then
    ln -f -t local/include ${link}/include/zlib.h 2> /dev/null
  else
    log "no targets to link: ${link}/include/zlib.h" FAIL
    return 1
  fi

  if [ -f ${link}/include/zconf.h ] ; then
    ln -f -t local/include ${link}/include/zconf.h 2> /dev/null
  else
    log "no targets to link: ${link}/include/zconf.h" FAIL
    return 1
  fi

  if [ -f ${link}/$lib/pkgconfig/zlib.pc ] ; then
    mkdir -p  local/$lib/pkgconfig
    ln -f -t local/$lib/pkgconfig ${link}/$lib/pkgconfig/zlib.pc 2> /dev/null
    # a failure is not essential
  fi

  return 0
}

log()
{

  test ${isDebug:-f} = t && set +x

  # get status from last process
  local status=$?

  local n p
  local pEnd=80
  local str isDONE
  local term

#  if [ ${isContLog:-f} = f ] ; then
#     str="\n === Install Session: $(date +'%F_%T') ===\n"
#  fi

  test "$1" = '--continue_log' && shift 1

  n=$#
  local lastWord=${!n}
  if [ "${lastWord:0:4}" = DONE ] ; then
    term=${lastWord#*=}
    n=$(( n - 1 ))
    status=0
  elif [ "${lastWord}" = FAIL ] ; then
    term=FAIL
    n=$(( n - 1 ))
    status=1
  elif [ ${status} -eq 0 ] ; then
    term=DONE
  else
    term=FAIL
  fi

  for(( p=1 ; p <= n ; ++p )) ; do
    str="${str} ${!p}"
  done

  formatText "${str}"
  echo -e -n "$formattedText" >> ${log_pwd}install.log

  if [ ${#term} -gt 0 ] ; then
    str=' '
    for(( p=${lastLineSz} ; p < ${pEnd} ; ++p )) ; do
      str="${str}."
    done
    str="${str} ${term}"
  fi

  echo "$str" >> ${log_pwd}install.log

  test ${isDebug:-f} = t && set -x

  return $status
}

xtractSrcPath()
{
  # Note: each executable invoked on a bash command-line
  # gets its name in parameter $0, which is unchanged
  # in a function.

  # this function is called recursively

  # remember the current path
  if [ $# -eq 0 ] ; then
    local oldPath=$(pwd)
    local p=$0
  else
    p=$1
  fi

  if [ ${p} != "${p//\./}" ] ; then
    cd ${p%/*}
    xtractSrcPath ${p##*/}
  fi

  # Is it a symbolic link?
  # The symbolic link could point to another symbolic link
  if [ -h $p ] ; then
    local tmps
    tmps=( $( ls -l $p ) )

    # get the target of the symbolic link
    p=${tmps[$(( ${#tmps[*]}-1 ))]}
    cd ${p%/*}  # strip command

    xtractSrcPath ${p##*/}
    return
  fi

  QA_SRC=$(pwd)

  if [ ${QA_SRC} != ${QA_SRC%/scripts} ] ; then
    QA_SRC=${QA_SRC%/scripts}
    cd ..
  fi

  return
}

# ++++++++++++   main   +++++++++++++++

#extract the path to QA from $0
xtractSrcPath

srcPath=${QA_SRC}/${srcPath}  # by default

prefix=${QA_SRC}/local

while getopts hq-: option ${args[*]}
do
  case $option in
    h)  descript
        exit 1 ;;
    q)  QUIET=t ;;
    -)  if [ "${OPTARG%%=*}" = "autofix" ] ; then
           if [ "${OPTARG#*=}" = disable ] ; then
              sed -i '/autofix/ d' .conf &> /dev/null
              test ! -s .conf && \rm .conf
           else
              if ! grep -q autofix .conf &> /dev/null; then
                 echo autofix=enabled >> .conf
              fi
           fi
        elif [ "${OPTARG}" = "continue_log" ] ; then
           isContLog=t
        elif [ "${OPTARG%=*}" = "debug" ] ; then
           if [ ${OPTARG} = debug -o ${OPTARG#*=} = ${0##*/} ] ; then
             set -x
             isDebug=t
           fi
        elif [ "${OPTARG}" = "distclean" ] ; then
           isDistClean=t
        elif [ "$OPTARG" = "help" ] ; then
           descript
           exit 1
        elif [ "${OPTARG%%=*}" = "lib-dest" ] ; then
           prefix=${OPTARG#*=}
        elif [ "${OPTARG%%=*}" = "link" ] ; then
           link=${OPTARG#*=}
        elif [ "${OPTARG%%=*}" = "package" ] ; then
           package=${OPTARG#*=}
        elif [ "${OPTARG%%=*}" = "src-path" ] ; then
           srcPath=${OPTARG#*=}

        #undocumented; default from install overrides internal default
        elif [ "${OPTARG%=*}" = "hdf5" ] ; then
          curr_hdf5=${OPTARG#hdf5=}
        elif [ "${OPTARG%=*}" = "netcdf" ] ; then
          curr_netcdf=${OPTARG#netcdf=}
        elif [ "${OPTARG%=*}" = "zlib" ] ; then
          curr_zlib=${OPTARG#zlib=}
        elif [ "${OPTARG%=*}" = "udunits" ] ; then
          curr_udunits=${OPTARG#udunits=}
        fi

        ;;
   \?)  descript
        exit 1
  esac
done

test ${isDebug:-f} = t && unset QUIET

shift $(( $OPTIND - 1 ))

log_pwd=$(pwd)/

# Installation of external packages.

if ! mkdir -p ${prefix} 2> /dev/null ; then
  descript
  txt="Could not mkdir -p ${prefix}"
  echo -e "\n${txt}"

  log ${txt} DONE
  exit 1
fi

mkdir -p $srcPath

test ${#LIB} -eq 0 && LIB=local/lib

test ${isDistClean:-f} = t  && distclean

# only required for a genuine build
if [ ${#link} -eq 0 ] ; then
  if ! $( f zlib ) ; then
    exit 1
  fi

  if ! $( f hdf5 ) ; then
    exit 1
  fi
fi

if ! $( f netcdf ) ; then
  exit 1
fi

if ! $( f udunits ) ; then
  exit 1
fi

# adjust install_configure setting
lib=
test -e ${prefix}/lib && lib=${prefix}/lib
if [ -e ${prefix}/lib64 ] ; then
  lib=${lib}${lib:+:}${prefix}/lib64
fi
sed -i "/^[[:space:]]*LIB=/ c LIB=${lib}" install_configure

incl=${prefix}/include
sed -i "/^[[:space:]]*INCLUDE=/ c INCLUDE=${incl}" install_configure

exit 0
