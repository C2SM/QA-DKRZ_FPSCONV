#! /bin/bash

org=http://cfconventions.org

cf_html()
{
  # htmnl page containing access to cf related tables
  local html=standard-names.html
  wget -q -N $org/$html

  if [ ! -f ${file} ] ; then
    echo "failed wget -N $org/$html" > /dev/stderr
    exit
  fi

  parse_html "Standard Name Table" xml
  parse_html "Area Type Table" xml
  parse_html "Standardized Region List" html

  return
}

convert_html2txt()
{
  if [ "${2}" = "Standardized Region List" ] ; then
    convert_html2txt_region "$1"
  fi

  return
}

convert_html2txt_region()
{
  local htmlFile=${1}
  local txtFile=CF_${1%html}txt

  if [ -f ${txtFile} ] ; then
    local h_date=$(ls -l --time-style='+%Y%m%d' ${htmlFile} | awk '{print $6}')
    local t_date=$(ls -l --time-style='+%Y%m%d' ${txtFile} | awk '{print $6}')

    test ${h_date} -lt ${t_date} && return
  fi

  # convert html to plain text

  rm -f ${txtFile}
  isSearchBeg=t
  local txt
  while read line ; do
    txt=
    for(( i=0 ; i < ${#line} ; ++i )) ; do
      if [ ${isSearchBeg} = t ] ; then
        test "${line:i:4}" = '</p>' && isSearchBeg=f
        continue
      fi

      # rm leading
      test "${line:i:1}" = ' ' && continue
      test "${line:i:6}" = '</div>' && return
      if [ "${line:i:1}" = '<' ] ; then
        echo "${txt}" >> ${txtFile}
        txt=
        continue 2
      fi

      txt=${txt}"${line:i:1}"
    done
  done < ${htmlFile}

  return
}

convert_xml2txt()
{
  if [ "${2}" = "Area Type Table" ] ; then
    convert_xml2txt_area "$1"
  fi

  return
}

convert_xml2txt_area()
{
  local xmlFile=${1}
  local txtFile=CF_${1%xml}txt

  if [ -f ${txtFile} ] ; then
    local h_date=$(ls -l --time-style='+%Y%m%d' ${xmlFile} | awk '{print $6}')
    local t_date=$(ls -l --time-style='+%Y%m%d' ${txtFile} | awk '{print $6}')

    test ${h_date} -lt ${t_date} && return
  fi

  # convert html to plain text

  rm -f ${txtFile}
  local txt
  while read line ; do
    for(( i=0 ; i < ${#line} ; ++i )) ; do
      # rm leading blanks
      test "${line:i:1}" = ' ' && continue

      if [ "${line:i:10}" = '<entry id=' ] ; then
        line=${line#*=}
        line=${line:1:$((${#line}-3))}
        echo "${line}" >> ${txtFile}

        continue 2
      fi

      break  #get next line
    done
  done < ${xmlFile}

  return
}

editConfigFile()
{
  test $# -eq 0 && return

  # return 1 if a single parameter was passed whose value is 'disable'
  local retVal=0

  # find the corresponding section in the config file
  test ! -f ${CONFIG_FILE} && touch $CONFIG_FILE

  # adjust for spaces a user may have edited into the section
  local line is num
  local blkBeg=0
  local blkEnd
  local num=0
  local str

  while read line ; do
    test "${is}" -a ! "${line}" && break

    num=$((num + 1))

    if [ "${line}" = ${QA_PATH}: ] ; then
      is=t
      blkBeg=$num
      str=${QA_PATH}:
      continue
    fi

    if [ ${is} ] ; then
      line=${line// /}

      while [ ${line/==/=} != ${line} ] ; do
        line=${line/==/=}
      done

      str="${str} ${line}"
    fi
  done < ${CONFIG_FILE}

  blkEnd=$num

  sctn=( ${str} )
  str=

  local item name value

  if [ ${blkBeg} -eq 0 ] ; then
    # append a new section
    echo -e "\n${QA_PATH}:" >> $CONFIG_FILE

    for item in $* ; do
      value=${item#*=}

      if [ ${value} = ${item} ] ; then
        item="${item}=enabled"
      elif [ ${value} = d -o ${value:0:7} = disable ] ; then
        test $# -eq 1 && retVal=1
        continue
      fi

      echo ${item} >> $CONFIG_FILE
    done

    return retVal
  fi

  local i
  for item in $* ; do
    test ${item:$((${#item}-1))} = '=' && item=${item}enabled

    name=${item%=*}
    value=${item#*=}

    if [ ${name} = ${item} ] ; then
      item=${item}=enabled
    elif [ ${value} = d -o ${value} = disabled ] ; then
      item=${name}=d
    fi

    for(( i=0 ; i < ${#sctn[*]} ; ++i )) ; do
      test ${sctn[i]} = ${item} && continue 2

      if [ ${sctn[i]%=*} = ${name} ] ; then
        num=$((blkBeg+i))
        if [ "${value}" = d ] ; then
          sed -i "${num} d" $CONFIG_FILE &> /dev/null
          blkEnd=$((blkEnd -1 ))
          unset sctn[i]
          sctn=( ${sctn[*]} )
          test $# -eq 1 && retval=1
        else
          sed -i "${num} c${item}" $CONFIG_FILE &> /dev/null
        fi

        continue 2
      fi
    done

    if [ ${item#*=} != d ] ; then
      sed -i "$((blkEnd++)) a${item}" $CONFIG_FILE &> /dev/null
      sctn[i]="${item} ${sctn[i]}"
      sctn=( ${sctn[*]} )
    fi
  done

  return $retVal
}

getConfigEntry()
{
  local section=$1
  local entry=$2
  local configFile=$3

  local line is

  while read line ; do
    test "${is}" -a ! "${line}" && break

    if [ "${line}" = ${section}: ] ; then
      is=t
      continue
    fi

    if [ ${is} ] ; then
      line=${line// /}

      # repair some manually edited faults
      while [ ${line/==/=} != ${line} ] ; do
        line=${line/==/=}
      done

      if [ "${line%=*}" = "${entry}" ] ; then
         eval ${entry}=${line}
         return 0
      fi
    fi
  done < $configFile

  eval ${entry}=

  return 1
}

parse_html()
{
  local table="$1"
  local type=$2

  # extract the relative path to the latest version
  local line="$(grep -A 3 "$table" $html | grep $type)"
  local i cf_table_name
  local isSearchBeg=t

  for(( i=0 ; i < ${#line} ; ++i )) ; do
    if [ ${isSearchBeg} = t ] ; then
      test "${line:i:1}" = '"' && isSearchBeg=f

      continue
    fi

    test "${line:i:1}" = '"' && break

    cf_table_name=${cf_table_name}"${line:i:1}"
  done

  if [ ${#cf_table_name} -eq 0 ] ; then
    echo "grep failed to find string ${table} in file $html" > /dev/stderr
    return
  fi

  test ${#cf_table_name} -gt 0 && ! wget -q -N $org/${cf_table_name} && return

  if [ ${cf_table_name##*.} = html ] ; then
    convert_html2txt ${cf_table_name##*/} "${table}"
  elif [ ${cf_table_name##*.} = xml ] ; then
    convert_xml2txt ${cf_table_name##*/} "${table}"
  fi

  return
}


updateDotConf()
{
  local name=${1%=*}
  local newDate=${1#*=}
  local savedDate=$2

  test "${savedDate}" = "${newDate}" && return 1

  editConfigFile $1

  return 0
}

# main
while getopts h-: option ${sArgs[*]}
do
  case $option in
    h)  ;;
    -) if [ ${OPTARG%=*} = "config_file" ] ; then
         CONFIG_FILE=${OPTARG##*=}
       elif [ ${OPTARG%=*} = "qa_path" ] ; then
         QA_PATH=${OPTARG##*=}
       fi
       ;;
   \?) exit 1 ;;
  esac
done

shift $(( $OPTIND - 1 ))

test $# -eq 1  && cd $1 &> /dev/null

# search for updates only once a day
today=$( date '+%Y%m%d' )
getConfigEntry $QA_PATH CF_LAST_UPDATE_CHECK ${CONFIG_FILE}

if ! updateDotConf ${CF_LAST_UPDATE_CHECK} $today  ; then
  exit
fi

cf_html

