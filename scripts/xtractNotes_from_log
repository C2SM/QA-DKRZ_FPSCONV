#! /bin/bash

descript()
{
  echo -e "\nxtractNotes_from_log:"
  echo "purpose: extract notes from a logfile"
  echo "  Exclusive options:"
  echo "  -c       Clear file from redundant entries and exit."
  echo "           Note: a clearance is always done"
  echo "  -d dir   stdout directory; default: [file-path/]Annotations.yaml"
  echo "  -f str   Comma-sep-list of notes [default: all]"
  echo "  -g expr  Grep blocks containing expr (comma-sep-list)."
  echo "  -H       Output original header of input file."
  echo "  -h       Help."
  echo "  -i       Output the inverse; only with option -g or -r."
  echo "  -m       Merge QA results (automaticly in ONLY_SUMMARY mode)."
  echo "  -p       Print to output."
  echo "  -r expr  Remove blocks; equivalent to"
  echo "           -i -g expr -Q > same_File"
  echo "  -t str   Comma-sep-list of 'name,ensemble' pairs"
  echo "           where 'ensemble' may be omitted."
  echo "           for a default and for particular files."
  echo "  --debug[=script]"
  echo "  --line=i only search the i-th line of each block."
  echo "  f(s)  these logfs (bash: *, ? allowed)"
  exit
}

printAnnotations()
{
  local k line
  local blk
  declare -a blk

  #note that there is no header
  read line
  blk[${#blk[*]}]="$line"

  while read line ; do
    if [ "${line:0:8}" = ' - date:' ] ; then
      print_blk
      unset blk
    fi

    blk[${#blk[*]}]=$line
  done

  # the last block
  print_blk
  unset blk

  return
}

print_blk()
{
  local i ix j
  local fName
  local file_ix=-1
  local end_ix=-1
  local events_ix=-1

  local event_ix
  declare -a event_ix

  local words
  declare -a words

  local sz=${#blk[*]}

  isHeader=f

  for(( i=0 ; i < sz ; ++i )) ; do
    # skip leading spaces
    for(( j=0 ; j < ${#blk[i]} ; ++j )) ; do
       test "${blk[i]:j:1}" != ' ' && break
    done

    # find next file
    if [ "${blk[i]:j:1}" = 'f' -a "${blk[i]:j:5}" = 'file:' ] ; then
      splitString words "${blk[i]}"
      fName=${words[1]}
      file_ix=$i
    elif [ "${blk[i]:j:1}" = 'e' ] ; then
      if [ "${blk[i]:j:4}" = 'end:' ] ; then
        end_ix=$i
      elif [ "${blk[i]:j:7}" = 'events:' ] ; then
        events_ix=$i
      fi
    elif [ "${blk[i]:j:8}" = '- event:' ] ; then
        event_ix[${#event_ix[*]}]=$i
    fi
  done

  # not a usual block, e.g. qa_version
  test ${i} -eq ${sz} -a ${file_ix} -eq -1 && return

  local szA
  local tag0 tag tags0 tags
  declare -a tags
  declare -a tags0

  # look for a matching base
  local szAB=${#atomicBase[*]}
  for(( ix=0 ; ix < szAB ; ++ix )) ; do
    szA=${#atomicBase[ix]}
    test "${fName:0:${szA}}" = "${atomicBase[ix]}" & break
  done

  # look for a matching tags
  if [ $ix -lt ${szAB} ] ; then
    splitString tags "${pureAtomicTags[ix]}" ','

    for(( i=0 ; i < ${#tags[*]} ; ++i )) ; do
      if [ "${tags[i]}" ] ;then
        printPureAtomicTag ${tags[i]}
      fi
    done
  fi

  printNonAtomicTag

  return
}

printHeader()
{
  test ${isHeader:-f} = t && return

  local i sz
  sz=$(( events_ix + 1 ))

  for(( i=0 ; i < sz ; ++i )) ; do
    if [ "$1" = atom ] ; then
      if [ $i -eq ${file_ix} ] ; then
        echo "   atomic: ${atomicBase[ix]}.nc"
        continue
      elif [ $i -eq ${end_ix} ] ; then
        echo "    end: ${atomicEnd[ix]}"
        continue
      fi
    fi

    echo "${blk[i]}"
  done

  isHeader=t
  return
}

printPureAtomicTag()
{
  local aTag=$1

  local e i j
  local varTag

  local words
  declare -a words

  for e in ${event_ix[*]} ; do
    i=$((e+3))  # index of tag:
    splitString words "${blk[i]}"

    if [ "${words[0]}" = 'tag:' ] ; then
      getVarTag varTag $i

      if [ "${varTag}" = "$aTag" ] ; then
        for((j=0 ; j < ${#solvedPureAtomicTags[*]} ; ++j )) ; do
          test ${solvedPureAtomicTags[j]} = "${varTag}" && continue 2
        done

        printHeader atom # safe when already done

        j=${#solvedPureAtomicTags[*]}
        solvedPureAtomicTags[j]=$aTag

        echo "${blk[e]}" # the line with event:

        for(( i=e+1 ; i < sz ; ++i )) ; do
          splitString words "${blk[i]}"

          # next event or end of last event
          test "${words[1]}" = 'event:' && return
          echo "${blk[i]}"
          test "${words[0]}" = 'status:' && return
        done
      fi
    fi
  done

  return
}

printNonAtomicTag()
{
  local e i j
  local varTag

  local words
  declare -a words

  for e in ${event_ix[*]} ; do
    for(( i=e+1 ; i < sz ; ++i )) ; do
      splitString words "${blk[i]}"

      if [ "${words[0]}" = 'tag:' ] ; then
        getVarTag varTag $i

        for((j=0 ; j < ${#solvedPureAtomicTags[*]} ; ++j )) ; do
          test ${solvedPureAtomicTags[j]} = "${varTag}" && continue 3
        done

        printHeader # safe when already done

        echo "${blk[e]}" # the line with event:

        for(( i=e+1 ; i < sz ; ++i )) ; do
          splitString words "${blk[i]}"

          # next event or end of last event
          test "${words[1]}" = 'event:' && break 2
          echo "${blk[i]}"
          test "${words[0]}" = 'status:' && return
        done
      fi
    done
  done

  return
}

atomise()
{
  # fBase: plain array
  # atomicTags:  comma-sep groups of tags;
  #              a group is separated by /
  #              each tag has the sh1sum of the caption appended
  # atomicEnd:   end time

  unset atomicBase atomicTags atomicEnd pureAtomicTags solvedPureAtomicTags

  exec 0< $annot

  atomicParsing
  atomicFinal

  exec 0< $annot  # rewind
  exec 1> $atom
  printAnnotations

  unset atomicTags # no longer needed

  return
}

atomicFinal()
{
  # find pure atomic tags. If found, then remove them from the non-atomic tags

  local ix isAtomic tag0 tag tags0 tags
  declare -a tags
  declare -a tags0

  for(( ix=0 ; ix < ${#atomicBase[*]} ; ++ix )) ; do
    splitString tags "${atomicTags[ix]}" ','
    splitString tags0 "${tags[0]}" '/'

    for tag0 in ${tags0[*]} ; do
      isAtomic=t
      for tag in ${tags[*]} ; do
        if [ "${tag}" = "${tag/${tag0}/}" ] ; then
          isAtomic=f
          break;
        fi
      done

      if [ ${isAtomic} = t ] ; then
         atomicTags[ix]=${atomicTags[ix]//${tag0}/}
         pureAtomicTags[ix]=${pureAtomicTags[ix]}${pureAtomicTags[ix]:+,}${tag0}
      else
         pureAtomicTags[ix]=''
      fi
    done

  done

  return
}

clear_out()
{
  test ${isOut:-f} = t && return

  if [ ${countHeaderLines} -eq $( cat ${out} | wc -l ) \
      -o ! -s ${out} ] ; then
    \rm -f $out
  fi

  return
}

clearRedirection()
{
   test ${isOut:-f} = t && return

#   test ${#dir} -gt 0 && exec 1<&7 7<&-
   return
}

clearRedundantBlock()
{
  # remove all but the most recent unique entry

  local countLines
  local isFound=f
  local pattern

  local isInverse=t
  local isOldFile=t
  local dir=""
  local isOut=f

  local grepArg
  declare -a grepArg

  local out

  IFS=''

  exec 7<&1

  for(( i=0 ; i < ${#fs[*]} ; ++i )) ; do
    f=${fs[i]##*/}

    exec 9<&0 # save stdin
    exec 0< ${path[i]}$f

    out="${path[i]}tmp_${f}"
    exec 1>$out

    # skip header
    countLines=0
    while read line ; do
      countLines=$(( countLines + 1 ))
      if [ ${isAddHeader} = t ] ; then
        echo "${line}"
      fi

      test "${line}" = 'items:' && break
    done

    countHeaderLines=$(( countLines - 1 ))

    local line
    unset blk

    # init reading of blocks
    read line
    blk[${#blk[*]}]=$line

    while read line ; do
      countLines=$(( countLines + 1 ))

      # read a block respecitvely an item
      if [ "${line:0:2}" = ' -' ] ; then
        # the end of a block
        if findRedundantBlocks ; then
          processBlock
          isFound=t
        fi

        unset blk
      fi

      blk[${#blk[*]}]=$line
    done

    # process the last block
    if findRedundantBlocks ; then
       processBlock
      isFound=t
    fi

    # remove empty output file or just containing the headline
    clear_out

    if [ -s "$out" -a ${isOldFile:-f} = t ] ; then
      if [ ${isFound} = t ] ; then
        mv $out ${path[i]}${f}
      else
        \rm -f $out
      fi
    fi

    # restore stdin and free #9
    exec 0<&9 9<&-
  done

  exec 1<&7 7<&-

  IFS=$oldIFS

  return
}

findAnnotatedBlock()
{
  # return 0 for a xtracting a block
  local i j tag tags
  declare -a tags

  # the last line belongs to the next block
  local sz=$(( ${#blk[*]} -1 ))

  # find all tags in the block
  for(( i=0 ; i < sz ; ++i )) ; do
    # skip spaces
    for(( j=0 ; j < ${#blk[i]} ; ++j )) ; do
      test "${blk[i]:j:1}" != ' ' && break
    done

    # find next tag
    if [ "${blk[i]:j:1}" = 't' -a "${blk[i]:j:4}" = 'tag:' ] ; then
      return 0
    fi
  done

  return 1
}

findRedundantBlocks()
{
  # find redundant entries in terms of full file name
  local i j last matches pattern
  local is=t
  declare -a matches

  # the last line belongs to the next block
  local sz=$(( ${#blk[*]} -1 ))

  # find all tags in the block
  for(( i=0 ; i < sz ; ++i )) ; do
    # skip spaces
    for(( j=0 ; j < ${#blk[i]} ; ++j )) ; do
      test "${blk[i]:j:1}" != ' ' && break
    done

    # find file:
    if [ "${blk[i]:j:1}" = 'f' -a "${blk[i]:j:5}" = 'file:' ] ; then
      pattern=${blk[i]:$((j+6))}
      is=f
      break
    fi
  done
  test $is = t && return 0 # this block has no file: item

  local IFS=$oldIFS

  # note: first array item of pattern is FILE:
  matches=($(grep -n "[[:space:]]*file:[[:space:]]*${pattern}" ${path}${f} ))

  # a unique block is represented by three matches per line
  test ${#matches[*]} -eq 3 && return 0

  last=${matches[$(( ${#matches[*]} - 3 ))]}
  last=${last%:}

  IFS=''
  if [ ${last} -gt ${countLines} ] ; then
    return 1
  else
    return 0
  fi
}

parseBlock()
{
  local words
  declare -a words

  local sz=${#blk[*]}
  local fBase range
  local ix=-1
  local tag capt

  # the first line is always ' - date: ...'
  for(( i=1 ; i < sz ; ++i )) ; do
    splitString words "${blk[i]}"

    if [ "${words[0]}" = 'file:' ] ; then
      words[1]=${words[1]%.nc}

      if range=$(expr match "${words[1]}" \
                    '.*_\([[:digit:]]\+-[[:digit:]]\+\)' 2> /dev/null ) ; then
        fBase=${words[1]%_${range}}
      elif range=$(expr match "${words[1]}" \
                    '.*_\([[:digit:]]\+\)' 2> /dev/null ) ; then
        fBase=${words[1]%_${range}}
      else
        fBase=${words[1]%.*}
      fi

      for(( ix=0 ; ix < ${#atomicBase[*]} ; ++ix )) ; do
        test ${atomicBase[ix]} = $fBase && break
      done

      if [ ${ix} -eq ${#atomicBase[*]} ] ; then
        atomicBase[ix]=$fBase
        atomicEnd[ix]=$(grep -A 10 "file: $fBase" $bad \
                        | grep 'end:' | awk 'END{print $NF}' )
      fi
    elif [ "${words[0]}" = 'tag:' ] ; then
      local varTag
      getVarTag varTag $i
      tag=${tag}${tag:+/}${varTag}
    fi
  done

  if [ ${ix} -gt -1 ] ; then
    atomicTags[ix]=${atomicTags[ix]}${atomicTags[ix]:+,}${tag}
  fi

  return
}

getVarTag()
{
  local sz=${#blk[*]}
  local tag=$1
  local tag_ix=$2
  local capt_ix=$(( tag_ix - 2 ))

  local x_tag x_capt

  splitString x_tag "${blk[tag_ix]}"
  splitString x_capt "${blk[capt_ix]}"

  local capt=$( echo "${x_capt[1]}" | sha1sum | awk '{print $1}' )
  eval ${1}=${x_tag[1]}=${capt}

  return
}

atomicParsing()
{
  local i ix j k line words

  local blk
  declare -a blk

  #note: there is no header
  local is isNew isOld
  local blkCount=0

  # read: no need to preserve leading blanks
  # init reading of blocks
  read line
  blk[${#blk[*]}]=$line

  while read line ; do
    if [ "${line:0:8}" = ' - date:' ] ; then
      parseBlock
      unset blk
    fi

    blk[${#blk[*]}]=$line
  done

  # the final block
  parseBlock

  return
}

getByToken()
{
  local is isNoFlag

  for token in ${tokens[*]} ; do
    ts=( ${token//,/ } )

    set -f
    if [ ${#ts[*]} -eq 1 ] ; then
      t=*${token}*
    else
      t=*
      for(( i=0 ; i < ${#ts[*]} ; ++i )) ; do
        t=${t}${ts[i]}*
      done
    fi
    set +f

    fs=( $( ls -d ${t}.log ) )

    xtrctAnnotated
  done

  return
}

grepBlock()
{
  test ${isOut:-f} = f && exec 7<&1

  for(( i=0 ; i < ${#fs[*]} ; ++i )) ; do
    f=${fs[i]##*/}

    if [ ${#dir} -gt 0 ] ; then
        out="${dir}${f%.log}.note"
    else
      test ${#path[i]} -gt 0 && mkdir -p ${path[i]}
    fi

    if [ ${isOut:-f} = f ] ; then
      out="${dir}${f%.log}.note"
    fi

    if [ ${isOldFile:-f} = t ] ; then
      out="${path}tmp_${f}"
    fi

    test ${#out} -gt 0 && exec 1>$out

    exec 9<&0 # save stdin
    exec 0< ${path}$f

    # skip header
    while read line ; do
      test "${line}" = 'items:' && break
    done

    IFS=''

    # init reading of blocks
    read line
    blk[${#blk[*]}]=$line

    while read line ; do
      if [ ${line:0:2} = ' -' ] ; then
        # the begin of a block
        splitString words "${line}"
        test "${words[0]}" = '-' -a "${words[1]}" = ' date:' && unset blk

        blk[${#blk[*]}]="$line"
        continue
      fi

      # put out blocks, if any
      processBlock

      unset blk
      blk[${#blk[*]}]="$line"
    done

    # remove empty output file or just containing the headline
    clear_out

    if [ ${isOldFile:-f} = t ] ; then
      if [ -s ${out} ] ; then
        mv $out ${path}${f}
      elif [ ${isOldFile:-f} = t ] ; then
        test ${isInverse} = t && \rm ${path}${f}
        # try to remove an empty dir
        rmdir ${path} &> /dev/null
      fi
    fi

    # restore stdin and free #9
    exec 0<&9 9<&-
  done

  test ${isOut:-f} = f && exec 1<&7 7<&-
  return
}

onExit()
{
  clearRedirection
}

processBlock()
{
  local i
  local pr=f
  local gA
  local count=0

  local IFS=''

  # the last line belongs to the next block
  local sz=${#blk[*]}

  # grep blocks
  if [ ${#grepArg[*]} -gt 0 ] ; then
    for(( i=0 ; i < sz ; ++i )) ; do
      count=$(( count + 1 ))
      if [ $isSearchLine = t ] ; then
         test $count != $searchLine && continue
      fi

      # find blocks containing a specified string
      for gA in ${grepArg[*]} ; do
        if expr match "${blk[i]}" ".*$gA" &> /dev/null ; then
          pr=t
          break 2
        fi
      done
    done

    if ! ( [ ${isInverse} = f -a $pr = t ]     ||
              [ ${isInverse} = t -a $pr = f  ]    ) ; then
       return
    fi
  fi

  # xtract notes
  for(( i=0 ; i < sz ; ++i )) ; do
    test "${blk[i]}" != cancel && echo "${blk[i]}"
  done

  return
}

splitString()
{
  # split a string at given separator
  local sep

  if [ "${3}" ] ; then
    sep=${3}
  else
    sep=' '
  fi

  local p0 p1 vals
  declare -a vals

  local str="${2}"
  p0=0

  for((p0=0 ; p0 < ${#str} ; ++p0 )) ; do
    test "${str:p0:1}" != "${sep}" && break
  done

  for((p1=p0+1 ; p1 < ${#str} ; ++p1 )) ; do
    if [ "${str:p1:1}" = "${sep}" ] ; then
       vals[${#vals[*]}]=${str:p0:$((p1-p0))}

       for((p0=p1+1 ; p0 < ${#str} ; ++p0 )) ; do
         if [ "${str:p0:1}" != "${sep}" ] ; then
           p1=$((p0+1))
           break
         fi
       done
    fi
  done
  test $((p0+1)) -lt $p1 && vals[${#vals[*]}]=${str:p0:$((p1-p0))}

  # a '#' could harm, but that is not looked for
  eval ${1}=\( ${vals[*]} \) 2> /dev/null

  return
}

xtrctAnnotated()
{
  local blk
  declare -a blk

  local file i line

  # save stdin
  exec 9<&0 # save stdin

  for(( i=0 ; i < ${#fs[*]} ; ++i )) ; do
    file=${fs[i]##*/}

    if [ ${#dir} -gt 0 ] ; then
      mkdir -p ${path[i]}${dir}annot
      mkdir -p ${path[i]}${dir}head

      head="${path[i]}${dir}head/${file%.log}.head"
      annot="${path[i]}${dir}annot/${file%.log}.anot"
      atom="${path[i]}${dir}annot/${file%.log}.atom"
      finA="${path[i]}${dir}${file%.log}.note"
    fi

    test "${file##*.}" != log && continue

    exec 0< ${path[i]}$file
    exec 1> $annot

    IFS=''

    #skip file header
    local countHeaderLines=0
    while read line ; do
      countHeaderLines=$(( countHeaderLines +1 ))

      if [ ${isAddHeader} = t ] ; then
        echo "${line}" >> $head
      fi

      test "${line}" = 'items:' && break
    done

    # init reading of blocks
    unset blk
    read line
    blk[${#blk[*]}]="$line"

    while read line ; do
      if [ "${line:0:8}" = ' - date:' ] ; then
        # the end of a block
        if findAnnotatedBlock ; then
          processBlock
        fi

        unset blk
      fi
      blk[${#blk[*]}]="$line"
    done

    # last block
    if findAnnotatedBlock ; then
      processBlock
    fi

    atomise

    if [ -s $atom ] ; then
      mv $head $finA
      cat $atom >> $finA
    fi

  done

  \rm -r ${path[i]}${dir}annot
  \rm -r ${path[i]}${dir}head

  # restore stdin and free #9
  exec 0<&9 9<&-

  IFS=$oldIFS

  return
}

# -------  main -----
test $# -eq 0 && descript

trap onExit EXIT

isInternalExclude=f
isOut=f
dir=Annotations.yaml/
isInverse=f
isClearRedundant=f
isSearchLine=f
isAddHeader=f

while getopts cd:f:g:hHim:pr:st:-: option ${args[*]}
do
  case $option in
    c)  isClearRedundant=t
        ;;
    d)  dir=${OPTARG}/ ;;
    f)  flags=( ${flags[*]} ${OPTARG//,/ } ) ;;
    g)  grepArg=( ${OPTARG//,/ } )
        unset dir ;;
    H)  isAddHeader=t ;;
    h)  descript ;;
    i)  isInverse=t ;;
    m)  MERGE=${OPTARG}
        isClearRedundant=t
        ;;
    p)  dir="" ;;
    r)  isInverse=t
        grepArg=( ${OPTARG//,/ } )
        isOldFile=t
        dir=""
        ;;
    s)  isOut=t ;;
    t)  tokens=( ${tokens[*]} ${OPTARG} ) ;;
    -)  if [ "$OPTARG" = "help" ] ; then
           descript
        elif [ "${OPTARG%%=*}" = "debug" ] ; then
           this=${0##*/}
           test "${OPTARG}" = debug -o ${OPTARG##*=} = ${this} && set -x
        elif [ "${OPTARG:0:4}" = line ] ; then
           searchLine=${OPTARG:5}
           isSearchLine=t
        fi
        ;;
   \?)  descript
  esac
done

shift $(( $OPTIND - 1 ))

declare -a blk

path=

# given files
if [ $# -gt 0 ] ; then
  fs=( $* )
  for(( i=0 ; i < ${#fs[*]} ; ++i )) ; do
    if [ ${fs[i]} != ${fs[i]##*/} ] ; then
       path[$i]=${fs[i]%/*}
       test ${#path[i]} -gt 0 && path[$i]=${path[i]}/
    else
       path[$i]=''
    fi

    test ${#dir} -gt 0 && mkdir -p ${path[i]}$dir
  done
fi

oldIFS="${IFS}"

if [ ${#fs[*]} -eq 0 -a ${#tokens[*]} -gt 0 ] ; then
  for t in ${tokens[*]//,/_} ; do
    fs[${#fs[*]}]=$( ls *$t*.log )
  done
fi

if [ ${#MERGE} -gt 0 ] ; then
  sed -i '1,/items:/ d' ${MERGE}.log
  cat $MERGE.log >> ${fs[0]}
  test $? -eq 0 && \rm -f $MERGE.log
fi

clearRedundantBlock

test ${isClearRedundant} = t && exit

if [ ${#grepArg[*]} -gt 0 ] ; then
   grepBlock
   exit
fi

if [ ${#tokens[*]} -gt 0 ] ; then
  # token can be defined in different files
  getByToken
  exit
fi

xtrctAnnotated
