#! /bin/bash

descript()
{
  echo -e "\nxtractNotes_from_log:"
  echo "purpose: extract notes from a logfile"
  echo "  Exclusive options:"
  echo "  -c       Clear file from redundant entries and exit."
  echo "           Note: a clearance is always done"
  echo "  -d dir   stdout directory; default: [file-path/]Annotations.yaml"
  echo "  -f str   Comma-sep-list of notes [default: all]"
  echo "  -g expr  Grep blocks containing expr (comma-sep-list)."
  echo "  -H       Output original header of input file."
  echo "  -h       Help."
  echo "  -i       Output the inverse; only with option -g or -r."
  echo "  -m       Merge QA results (automaticly in ONLY_SUMMARY mode)."
  echo "  -p       Print to output."
  echo "  -r expr  Remove blocks; equivalent to"
  echo "           -i -g expr -Q > same_File"
  echo "  -t str   Comma-sep-list of 'name,ensemble' pairs"
  echo "           where 'ensemble' may be omitted."
  echo "           for a default and for particular files."
  echo "  -Q       Suppress status message."
  echo "  --debug[=script]"
  echo "  --line=i only search the i-th line of each block."
  echo "  f(s)  these logfs (bash: *, ? allowed)"
  exit
}

add_partial_atomic()
{
  # events that are not atomic ones are marked to cancel from
  # the corresponding sub-temporal blocks

  local i j k
  local ivs iv_0 iv_1 tg # indexes events:, event: - begin, - end, tag
  declare -a iv_0 iv_1 f_tgs

  getBadIndexes

  local ablk nblk hblk

  # copy leading common block
  for(( i=0 ; i < ${ivs} ; ++i )) ; do
     hblk[${i}]="${blk[i]}"
  done

  local aCount=0
  local nCount=0
  local a_tgs

  splitString a_tgs , tags[ix]

  # placeholder for number of sub-temp events
  ablk[0]=''
  nblk[0]=''

  # go through the events
  for(( i=0 ; i < ${#f_tgs[*]} ; ++i )) ; do
     local is=f
     for(( j=0 ; j < ${#a_tgs[*]} ; ++j )) ; do
       if [ ${a_tgs[j]} = ${f_tgs[i]} ] ; then
         is=t
         break
       fi
     done

     if [ $is = t ] ; then
       for(( k=${iv_0[i]} ; k < ${iv_1[i]} ; ++k )) ; do
          # add to the atomic blk
          ablk[${#ablk[*]}]=${blk[k]}
       done
       aCount=$(( aCount +1 ))  # the number of remaining sub-temp events
     else
       for(( k=${iv_0[i]} ; k < ${iv_1[i]} ; ++k )) ; do
          # add to the current sub-temp blk
          nblk[${#nblk[*]}]=${blk[k]}
       done
       nCount=$(( nCount +1 ))  # the number of remaining sub-temp events
     fi
  done

  # should be only the status line, but who knows
  # the last line belongs to the next block
  local sz=${#blk[*]}

  for(( k=${iv_1[$((${#iv_1[*]}-1))]} ; k < sz ; ++k )) ; do
    ablk[${#ablk[*]}]=${blk[k]}
    nblk[${#nblk[*]}]=${blk[k]}
  done

  # adjust the number of sub-temp events
  ablk[0]="   events: ${aCount}"
  nblk[0]="   events: ${nCount}"

  # cat both to blk
  blk=()

  for(( k=0 ; k < ${#hblk[*]} ; ++k )) ; do
    if [ $k -eq $f_ix ] ; then
      # substitute 'file: ...' by 'atomic: ...}
      blk[${k}]="   atomic: ${scopeName[ix]}"
    else
      blk[${k}]=${hblk[k]}
    fi
  done
  for(( k=0 ; k < ${#ablk[*]} ; ++k )) ; do
    blk[${#blk[*]}]=${ablk[k]}
  done

  for(( k=0 ; k < ${#hblk[*]} ; ++k )) ; do
    blk[${#blk[*]}]=${hblk[k]}
  done
  for(( k=0 ; k < ${#nblk[*]} ; ++k )) ; do
    blk[${#blk[*]}]=${nblk[k]}
  done

  return
}

adjustBadAtomic()
{
  local tg

  # eventually for no trailing empty line
  if [ ${isNew} = t ] ; then
    isTotallyAtomic[${ix}]=t
    tags[${ix}]=${tag}
  elif [ ${isOld} = t -a "${isTotallyAtomic[ix]}" != f ] ; then
    if [ $tag != ${tags[${ix}]} ] ; then
      # is at least one or more tags remainig atomic?
      local tagx tagsx
      splitString tagsx , tags[ix]  # provide separator ','
      splitString tagx , tag
      for tgs in ${tagsx[*]} ; do
        for tg in ${tagx[*]} ; do
          test ${tgs} = ${tg} && continue 2
        done

        # this one is good at least one time; take it out
        tags[${ix}]=${tags[ix]/${tgs},/}
        isTotallyAtomic[${ix}]=p
      done

      if [ "${tags[ix]}" = '' ] ; then
        isTotallyAtomic[${ix}]=f
        noScope[${#noScope[*]}]=${scopeName[ix]}
        scopeName[${ix}]=''
      fi
    fi
  fi

  return
}

atomicBadConversion()
{
  local k line
  local bad out
  local blk
  declare -a blk

  for(( k=0 ; k < ${#fs[*]} ; ++k )) ; do
#    f=${fs[k]##*/}

    if [ ${#dir} -gt 0 ] ; then
      bad="${path[k]}${dir}bad/${f%.log}.note"
      out=${bad}.$$
    fi

    # read from file
    exec 9<&0 # save stdin
    exec 0< ${bad}

    #note that there is no header
    # init reading of blocks
    read line
    blk[${#blk[*]}]="$line"

    while read line ; do
      if [ "${line:0:8}" = ' - date:' ] ; then
        atomicBadConversion_blk
        unset blk
      fi

      blk[${#blk[*]}]=$line
    done

    # the last block
    atomicBadConversion_blk
    unset blk

    # save the results
    test -e $out && mv ${out} ${bad}

    # restore stdin and free #9
    exec 0<&9 9<&-
  done

  return
}

atomicBadConversion_blk()
{
  local i ix j
  local f_ws
  local f_ix=-1
  local e_ix=-1

  declare -a f_ws

  local sz=${#blk[*]}

  for(( i=0 ; i < sz ; ++i )) ; do
    # skip leading spaces
    for(( j=0 ; j < ${#blk[i]} ; ++j )) ; do
       test "${blk[i]:j:1}" != ' ' && break
    done

    # find next file
    if [ "${blk[i]:j:1}" = 'f' -a "${blk[i]:j:5}" = 'file:' ] ; then
      splitString f_ws blk[i]
      f_ix=$i
    elif [ "${blk[i]:j:1}" = 'e' -a "${blk[i]:j:4}" = 'end:' ] ; then
      e_ix=$i
      break
    fi
  done

  # not a usual block, e.g. qa_version
  test ${i} -eq ${sz} -a ${f_ix} -eq -1 && return

  # look for a matching atomic scope
  for(( ix=0 ; ix < ${#scopeName[*]} ; ++ix )) ; do
    test ${#scopeName[ix]} -eq 0 && continue # defined and later cancelled

    sz=${#scopeName[ix]}

    if [ ${f_ws[1]:0:${sz}} = ${scopeName[ix]} ] ; then
      if [ ${isTotallyAtomic[ix]} = t ] ; then
        # all events are atomic; redefine the block totally as atomic
        blk[${f_ix}]="   atomic: ${scopeName[ix]}"

        # adjust period:
        test ${e_ix} -gt -1 && blk[${e_ix}]="    end: ${scopeEnd[ix]}"

        isTotallyAtomic[ix]=c  # remove subsequent matching blocks
        break
      elif [ ${isTotallyAtomic[ix]} = p ] ; then
        # events are only partially atomic; print them
        # this will change to 'pc' after the forst occurrence
        add_partial_atomic
        isTotallyAtomic[ix]=pc  # remove subsequent matching events
        break

      elif [ ${isTotallyAtomic[ix]} = c ] ; then
         # remove the block simply by skipping
         return

      elif [ ${isTotallyAtomic[ix]} = pc ] ; then
         # remove only the event(s) given by 'tags'
         remove_atomic_events

         break
      fi
    fi
  done

  processBlock $out

  return
}

atomicConversion()
{
  # this has to come first
  unset scopeName noScope isTotallyAtomic tags scopeEnd
  getBadAtomicScopes
  atomicBadConversion

  unset scopeName noScope isTotallyAtomic tags scopeEnd

  getGoodAtomicScopes
  atomicGoodConversion

  # good and bad
  for(( k=0 ; k < ${#fs[*]} ; ++k )) ; do
    if [ ${#dir} -gt 0 ] ; then
      good="${path[k]}${dir}good/${f%.log}.note"
      bad="${path[k]}${dir}bad/${f%.log}.note"

      # it is possible that bad files exist without any contents, but a single '',
      # which is not a word
      local t
      t=$( wc -w  ${bad})
      if [[ ! ( ${t:0:1} = '0' && ${t:1:1} = ' ' ) ]] ; then
        mv ${bad} ${path[k]}${dir}${f}
      else
        \rm -f $bad
      fi

      \rm -f $good
      rmdir ${path[k]}${dir}good ${path[k]}${dir}bad 2> /dev/null
    fi

  done

  return
}

atomicGoodConversion()
{
  local k line
  local good out
  local blk
  declare -a blk

  for(( k=0 ; k < ${#fs[*]} ; ++k )) ; do
    if [ ${#dir} -gt 0 ] ; then
      good="${path[k]}${dir}good/${f%.log}.note"
      out=${good}.$$
    fi

    # read from file
    exec 9<&0 # save stdin
    exec 0< ${good}

    #note that there is no header
    # init reading of blocks
    read line
    blk[${#blk[*]}]="$line"

    while read line ; do
      if [ "${line:0:8}" = ' - date:' ] ; then
        atomicGoodConversion_blk
        unset blk
      fi

      blk[${#blk[*]}]=$line
    done

    # the last block
    atomicGoodConversion_blk
    unset blk

    # save the results
    mv ${out} ${good}

    # restore stdin and free #9
    exec 0<&9 9<&-
  done

  return
}

atomicGoodConversion_blk()
{
  local i ix j
  local f_ws
  local f_ix e_ix

  declare -a f_ws

  local sz=${#blk[*]}

  for(( i=0 ; i < sz ; ++i )) ; do
    # skip leading spaces
    for(( j=0 ; j < ${#blk[i]} ; ++j )) ; do
       test "${blk[i]:j:1}" != ' ' && break
    done

    # find next file
    if [ "${blk[i]:j:1}" = 'f' -a "${blk[i]:j:5}" = 'file:' ] ; then
      splitString f_ws blk[i]
      f_ix=$i
    elif [ "${blk[i]:j:1}" = 'e' -a "${blk[i]:j:4}" = 'end:' ] ; then
      e_ix=$i
      break
    fi
  done

  # look for a matching atomic scope
  for(( ix=0 ; ix < ${#scopeName[*]} ; ++ix )) ; do
    test ${#scopeName[ix]} -eq 0 && continue # defined and later cancelled

    if [ "${f_ws[1]:0:${#scopeName[ix]}}" = ${scopeName[ix]} ] ; then
      if [ ${isTotallyAtomic[ix]} = t ] ; then
        # all events are atomic; redefine the block totally as atomic
        blk[${f_ix}]="   atomic: ${scopeName[ix]}"

        # adjust period:
        blk[${e_ix}]="    end: ${scopeEnd[ix]}"

        isTotallyAtomic[ix]=c  # remove subsequent matching blocks
        break

      elif [ ${isTotallyAtomic[ix]} = c ] ; then
         # remove the block simply by skipping
         return
      fi
    fi
  done

  processBlock $out

  return
}

clear_out()
{
  test ${isOut:-f} = t && return

  if [ ${countHeaderLines} -eq $( cat ${out} | wc -l ) \
      -o ! -s ${out} ] ; then
    \rm -f $out
  fi

  return
}

clearRedirection()
{
   test ${isOut:-f} = t && return

#   test ${#dir} -gt 0 && exec 1<&7 7<&-
   return
}

clearRedundantBlock()
{
  # remove all but the most recent unique entry

  local countLines
  local isFound=f
  local pattern

  local isInverse=t
  local isOldFile=t
  local dir=""
  local isOut=f

  local grepArg
  declare -a grepArg

  local out

  exec 7<&1

  for(( i=0 ; i < ${#fs[*]} ; ++i )) ; do
    f=${fs[i]##*/}

    exec 9<&0 # save stdin
    exec 0< ${path[i]}$f

    out="${path[i]}tmp_${f}"
    exec 1>$out

    IFS=''

    # skip header
    countLines=0
    while read line ; do
      countLines=$(( countLines + 1 ))
      if [ ${isAddHeader} = t ] ; then
        echo "${line}"
      fi

      test "${line}" = 'items:' && break
    done

    countHeaderLines=$(( countLines - 1 ))

    local line
    unset blk

    # init reading of blocks
    read line
    blk[${#blk[*]}]=$line

    while read line ; do
      countLines=$(( countLines + 1 ))

      # read a block respecitvely an item
      if [ "${line:0:2}" = ' -' ] ; then
        # the end of a block
        if findRedundantBlocks ; then
          processBlock
          isFound=t
        fi

        unset blk
      fi

      blk[${#blk[*]}]=$line
    done

    # process the last block
    if findRedundantBlocks ; then
       processBlock
      isFound=t
    fi

    # remove empty output file or just containing the headline
    clear_out

    if [ -s "$out" -a ${isOldFile:-f} = t ] ; then
      if [ ${isFound} = t ] ; then
        mv $out ${path[i]}${f}
      else
        \rm -f $out
      fi
    fi

    # restore stdin and free #9
    exec 0<&9 9<&-
  done

  exec 1<&7 7<&-

  IFS=$oldIFS

  return
}

findBlock2Xtract()
{
  # return 0 for a xtracting a block
  local i j tag tags
  declare -a tags

  # the last line belongs to the next block
  local sz=$(( ${#blk[*]} -1 ))

  # find all tags in the block
  for(( i=0 ; i < sz ; ++i )) ; do
    # skip spaces
    for(( j=0 ; j < ${#blk[i]} ; ++j )) ; do
      test "${blk[i]:j:1}" != ' ' && break
    done

    # find next tag
    if [ "${blk[i]:j:1}" = 't' -a "${blk[i]:j:4}" = 'tag:' ] ; then
      tags[${#tags[*]}]=${blk[i]:6}
    fi
  done

  test ${#tags[*]} -eq 0 && return 1

  # xtract only specified flags; skips leading 'T'
  isNoFlag=t
  for flag in ${flags[*]} ; do
    for tag in ${tags[*]} ; do
      test "${tag}" = "$flag" && return 1
    done
  done

  return 0
}

findRedundantBlocks()
{
  # find redundant entries in terms of full file name
  local i j last matches pattern
  local is=t
  declare -a matches

  # the last line belongs to the next block
  local sz=$(( ${#blk[*]} -1 ))

  # find all tags in the block
  for(( i=0 ; i < sz ; ++i )) ; do
    # skip spaces
    for(( j=0 ; j < ${#blk[i]} ; ++j )) ; do
      test "${blk[i]:j:1}" != ' ' && break
    done

    # find file:
    if [ "${blk[i]:j:1}" = 'f' -a "${blk[i]:j:5}" = 'file:' ] ; then
      pattern=${blk[i]:$((j+6))}
      is=f
      break
    fi
  done
  test $is = t && return 0 # this block has no file: item

  local IFS=$oldIFS

  # note: first array item of pattern is FILE:
  matches=($(grep -n "[[:space:]]*file:[[:space:]]*${pattern}" ${path}${f} ))

  # a unique block is represented by two matches per line
  test ${#matches[*]} -eq 3 && return 0

  last=${matches[$(( ${#matches[*]} - 3 ))]}
  last=${last%:}

  IFS=''
  if [ ${last} -gt ${countLines} ] ; then
    return 1
  else
    return 0
  fi
}

getBadIndexes()
{
  # use variables from the outer scope

  # find events:
  local i j words sz v_indent indent
  declare -a words

  v_indent=0

  sz=${#blk[*]}

  for(( i=0 ; i < sz ; ++i )) ; do
     # count leading spaces
     for(( indent=0 ; indent < ${#blk[i]} ; ++indent )) ; do
       test "${blk[i]:indent:1}" != ' ' && break
     done

     splitString words  blk[i]

     if [ ${words[0]} = 'events:' ] ; then
       ivs=$i
     elif [ "${words[1]}" = 'event:' ] ; then
       v_indent=${indent}

       # points to the next event
       iv_0[${#iv_0[*]}]=$i
       test ${#iv_0[*]} -gt 1 && iv_1[${#iv_1[*]}]=${iv_0[$(( ${#iv_0[*]} - 1 ))]}
     elif [ ${indent} -le ${v_indent}  ] ; then
       iv_1[${#iv_1[*]}]=$i
     elif [ ${words[0]} = 'tag:' ] ; then
       f_tgs[${#f_tgs[*]}]=${words[1]}  # no index but the tag itself
     fi
  done

  # when there was no status: line
  test ${#iv_1[*]} -lt ${#iv_0[*]} && iv_1[${#iv_1[*]}]=$i

  return
}

gBAS_block()
{
  isNew=f  # a new atomic scope name
  isOld=f # same atomic scope as found before; go on in the block
  tag=

  local words
  declare -a words

  local sz=${#blk[*]}
  local range

  # the first line is always ' - date: ...'
  for(( i=1 ; i < sz ; ++i )) ; do
    splitString words blk[i]

    if [ "${words[0]}" = 'file:' ] ; then
      words[1]=${words[1]%.nc}

      if range=$(expr match "${words[1]}" \
                     '.*_\([[:digit:]]\+-[[:digit:]]\+\)' 2> /dev/null ) ; then
        fBase=${words[1]%_${range}}
      elif range=$(expr match "${words[1]}" \
                     '.*_\([[:digit:]]\+\)' 2> /dev/null ) ; then
        fBase=${words[1]%_${range}}
      else
        fBase=${words[1]%.*}
      fi

      # is this scope also available in 'good', then bad is not atomic
      for(( j=0 ; j < ${#noScope[*]} ; ++j )) ; do
         test ${noScope[j]} = $fBase && break 2
      done
      if grep -q -m 1 $fBase $good ; then
         noScope[${#noScope[*]}]=$fBase
         break
      fi

      # scopeName and already found
      for(( ix=0 ; ix < ${#scopeName[*]} ; ++ix )) ; do
        if [ "${scopeName[ix]}" = $fBase ] ; then
          isOld=t
          continue 2
        fi
      done

      isNew=t
      ix=${#scopeName[*]}
      scopeName[${ix}]=$fBase
      scopeEnd[${ix}]=$(grep -A 10 "file: $fBase" $bad \
                        | grep 'end:' | awk 'END{print $NF}' )
      continue
    fi

    if [ "${words[0]}" = 'tag:' ] ; then
      tag=${tag}${words[1]},
    fi
  done

  adjustBadAtomic

  return
}

getBadAtomicScopes()
{
  local fBase i ix j k line words range
  local good bad
  local blk
  declare -a blk

  # on global scope: isTotallyAtomic scopeName tags

  for(( k=0 ; k < ${#fs[*]} ; ++k )) ; do
    f=${fs[k]##*/}

    if [ ${#dir} -gt 0 ] ; then
      good="${path[k]}${dir}good/${f%.log}.note"
      bad="${path[k]}${dir}bad/${f%.log}.note"
    fi

    # read from file
    exec 9<&0 # save stdin
    exec 0< ${bad}

    #note that there is no header
    local is isNew isOld
    local blkCount=0

    # read: no need to preserve leading blanks
    # init reading of blocks
    read line
    blk[${#blk[*]}]=$line

    while read line ; do
      if [ "${line:0:8}" = ' - date:' ] ; then
        # examine the  block
        gBAS_block
        unset blk
      fi

      blk[${#blk[*]}]=$line
    done

    # the final block
    gBAS_block

    # restore stdin and free #9
    exec 0<&9 9<&-
  done

  return
}

getByToken()
{
  local is isNoFlag

  for token in ${tokens[*]} ; do
    ts=( ${token//,/ } )

    set -f
    if [ ${#ts[*]} -eq 1 ] ; then
      t=*${token}*
    else
      t=*
      for(( i=0 ; i < ${#ts[*]} ; ++i )) ; do
        t=${t}${ts[i]}*
      done
    fi
    set +f

    fs=( $( ls -d ${t}.log ) )

    xtrctGoodBad
  done

  return
}

gGAS_block()
{
  local words
  declare -a words

  isNew=f  # a new atomic scope name

  # the last line belongs to the next block
  local sz=${#blk[*]}
  local j

  # the first line is always ' - date: ...'
  for(( i=1 ; i < sz ; ++i )) ; do
    splitString words blk[i]

    if [ "${words[0]}" = 'file:' ] ; then
      if range=$(expr match "${words[1]}" \
                     '.*_\([[:digit:]]*-[[:digit:]]*.*\.nc\)' 2> /dev/null \
                   || expr match "${words[1]}" '.*_\([[:digit:]]*\.nc\)' 2> /dev/null ) ; then
        fBase=${words[1]%_${range}}

        # is this scope also available in 'good', then bad is not atomic
        for(( j=0 ; j < ${#noScope[*]} ; ++j )) ; do
           test ${noScope[j]} = $fBase && break 2
        done
        if grep -q -m 1 $fBase $bad ; then
           noScope[${#noScope[*]}]=$fBase
           break
        fi

        # scopeName; already found
        for(( j=0 ; j < ${#scopeName[*]} ; ++j )) ; do
          test ${scopeName[j]} = $fBase && return
        done

        isNew=t
        j=${#scopeName[*]}
        scopeName[${j}]=$fBase
        scopeEnd[${j}]=$(grep -A 10 "file: $fBase" $good \
                        | grep 'end:' | awk 'END{print $NF}' )
        isTotallyAtomic[${j}]=t
        return
      else
        return # fixed or atomic
      fi
    fi
  done

  return
}

getGoodAtomicScopes()
{
  local fBase  # used in gGAS_block()
  local i ix j k line words range
  local good bad
  local blk
  declare -a blk

  # on global scope: isTotallyAtomic scopeName tags

  for(( k=0 ; k < ${#fs[*]} ; ++k )) ; do
    f=${fs[k]##*/}

    if [ ${#dir} -gt 0 ] ; then
      good="${path[k]}${dir}good/${f%.log}.note"
      bad="${path[k]}${dir}bad/${f%.log}.note"
    fi

    # read from file
    exec 9<&0 # save stdin
    exec 0< ${good}

    #note that there is no header
    local is isNew isOld
    local blkCount=0

    # read: no need to preserve leading blanks
    # init reading of blocks
    read line
    blk[${#blk[*]}]=$line

    while read line ; do
      if [ "${line:0:8}" = ' - date:' ] ; then
        # examine the  block
        gGAS_block
        unset blk
      fi

      blk[${#blk[*]}]=$line
    done

    # the final block
    gGAS_block

    # restore stdin and free #9
    exec 0<&9 9<&-
  done

  return
}

grepBlock()
{
  test ${isOut:-f} = f && exec 7<&1

  for(( i=0 ; i < ${#fs[*]} ; ++i )) ; do
    f=${fs[i]##*/}

    if [ ${#dir} -gt 0 ] ; then
        out="${dir}${f%.log}.note"
    else
      test ${#path[i]} -gt 0 && mkdir -p ${path[i]}
    fi

    if [ ${isOut:-f} = f ] ; then
      out="${dir}${f%.log}.note"
    fi

    if [ ${isOldFile:-f} = t ] ; then
      out="${path}tmp_${f}"
    fi

    test ${#out} -gt 0 && exec 1>$out

    exec 9<&0 # save stdin
    exec 0< ${path}$f

    # skip header
    while read line ; do
      test "${line}" = 'items:' && break
    done

    IFS=''

    # init reading of blocks
    read line
    blk[${#blk[*]}]=$line

    while read line ; do
      if [ ${line:0:2} = ' -' ] ; then
        # the begin of a block
        splitString words ${line}
        test "${words[0]}" = '-' -a "${words[1]}" = ' date:' && unset blk

        blk[${#blk[*]}]="$line"
        continue
      fi

      # put out blocks, if any
      processBlock

      unset blk
      blk[${#blk[*]}]="$line"
    done

    # remove empty output file or just containing the headline
    clear_out

    if [ ${isOldFile:-f} = t ] ; then
      if [ -s ${out} ] ; then
        mv $out ${path}${f}
      elif [ ${isOldFile:-f} = t ] ; then
        test ${isInverse} = t && \rm ${path}${f}
        # try to remove an empty dir
        rmdir ${path} &> /dev/null
      fi
    fi

    # restore stdin and free #9
    exec 0<&9 9<&-
  done

  test ${isOut:-f} = f && exec 1<&7 7<&-
  return
}

onExit()
{
  clearRedirection
}

processBlock()
{
  local i
  local pr=f
  local gA
  local count=0

  local IFS=''

  # the last line belongs to the next block
  local sz=${#blk[*]}

  # grep blocks
  if [ ${#grepArg[*]} -gt 0 ] ; then
    for(( i=0 ; i < sz ; ++i )) ; do
      count=$(( count + 1 ))
      if [ $isSearchLine = t ] ; then
         test $count != $searchLine && continue
      fi

      # find blocks containing a specified string
      for gA in ${grepArg[*]} ; do
        if expr match "${blk[i]}" ".*$gA" &> /dev/null ; then
          pr=t
          break 2
        fi
      done
    done

    if ! ( [ ${isInverse} = f -a $pr = t ]     ||
              [ ${isInverse} = t -a $pr = f  ]    ) ; then
       return
    fi
  fi

  # xtract notes
  if [ $# -gt 0 ] ; then
    for(( i=0 ; i < sz ; ++i )) ; do
      test "${blk[i]}" != cancel && echo "${blk[i]}" >> $1
    done
  else
    for(( i=0 ; i < sz ; ++i )) ; do
      test "${blk[i]}" != cancel && echo "${blk[i]}"
    done
  fi

  return
}

remove_atomic_events()
{
  # atomic events are marked to cancel from the corresponding sub-temporal blocks

  local i j k tgs
  local ivs iv_0 iv_1 tg # indexes events:, event: - begin, - end, tag
  declare -a iv_0 iv_1 f_tgs

  getBadIndexes

  local count=0
  local a_tgs

  splitString a_tgs , tags[ix]

  for(( i=0 ; i < ${#f_tgs[*]} ; ++i )) ; do
     # cancel for matching of an atomic tag with a sub-temporal one
     local is=f
     for(( j=0 ; j < ${#a_tgs[*]} ; ++j )) ; do
       if [ ${a_tgs[j]} = ${f_tgs[i]} ] ; then
         is=t
         break
       fi
     done

     if [ $is = t ] ; then
       for(( k=${iv_0[i]} ; k < ${iv_1[i]} ; ++k )) ; do
          blk[${k}]="cancel"
       done
     else
       count=$(( count +1 ))  # the number of remaining sub-temp events
     fi
  done

  if [ ${count} -eq 0 ] ; then
    # this sub-temp file is represented entirely by atomic events
    blk=()
  else
    # adjust the number of sub-temp events
    blk[${ivs}]="   events: ${count}"
  fi

  return
}

splitString()
{
 local arg=$1

  if [ $# -eq 2 ] ; then
    local IFS=' '
    shift
  elif [ $# -eq 3 ] ; then
    local IFS="$2"
    shift 2
  fi

  # a '#' could harm, but that is not looked for
  eval ${arg}=\( ${!1} \) 2> /dev/null
  return
}

xtrctGoodBad()
{
  local blk
  declare -a blk

  local file i line

  for(( i=0 ; i < ${#fs[*]} ; ++i )) ; do
    file=${fs[i]##*/}

    if [ ${#dir} -gt 0 ] ; then
      mkdir -p ${path[i]}${dir}good ${path[i]}${dir}bad
      good="${path[i]}${dir}good/${file%.log}.note"
      bad="${path[i]}${dir}bad/${file%.log}.note"
      echo -n '' > $good
      echo -n '' > $bad
#      out="${path[i]}${dir}${f%.log}.note"
#      exec 1>$out
    fi

    test "${file##*.}" != log && continue

    # save stdin
    exec 9<&0 # save stdin
    exec 0< ${path[i]}$file

    IFS=''

    #skip file header
    local countHeaderLines=0
    while read line ; do
      countHeaderLines=$(( countHeaderLines +1 ))

      if [ ${isAddHeader} = t ] ; then
        echo "${line}" >> $good
      fi

      test "${line}" = 'items:' && break
    done

    # init reading of blocks
    unset blk
    read line
    blk[${#blk[*]}]="$line"

    while read line ; do
      if [ "${line:0:8}" = ' - date:' ] ; then
        # the end of a block
        out=$good
        if findBlock2Xtract ; then
          out=$bad
        fi
        processBlock $out

        unset blk
      fi

      if expr match "${line}" '.*creation_date:' &> /dev/null ; then continue ; fi
      if expr match "${line}" '.*tracking_id:'   &> /dev/null ; then continue ; fi
      if expr match "${line}" '.*checksum:'      &> /dev/null ; then continue ; fi

      blk[${#blk[*]}]="$line"
    done

    # last block
    out=$good
    if findBlock2Xtract ; then
      out=$bad
    fi
    processBlock $out

    # remove empty output file or just containing the headline
#    clear_out

    # restore stdin and free #9
    exec 0<&9 9<&-

    atomicConversion
  done

  IFS=$oldIFS

  return
}

# -------  main -----
test $# -eq 0 && descript

trap onExit EXIT

isInternalExclude=f
isOut=f
dir=Annotations.yaml/
isInverse=f
isClearRedundant=f
isSearchLine=f
isAddHeader=f

while getopts cd:f:g:hHim:pr:st:-: option ${args[*]}
do
  case $option in
    c)  isClearRedundant=t
        ;;
    d)  dir=${OPTARG}/ ;;
    f)  flags=( ${flags[*]} ${OPTARG//,/ } ) ;;
    g)  grepArg=( ${OPTARG//,/ } )
        unset dir ;;
    H)  isAddHeader=t ;;
    h)  descript ;;
    i)  isInverse=t ;;
    m)  MERGE=${OPTARG}
        isClearRedundant=t
        ;;
    p)  dir="" ;;
    r)  isInverse=t
        grepArg=( ${OPTARG//,/ } )
        isOldFile=t
        dir=""
        ;;
    s)  isOut=t ;;
    t)  tokens=( ${tokens[*]} ${OPTARG} ) ;;
    -)  if [ "$OPTARG" = "help" ] ; then
           descript
        elif [ "${OPTARG%%=*}" = "debug" ] ; then
           this=${0##*/}
           test "${OPTARG}" = debug -o ${OPTARG##*=} = ${this} && set -x
        elif [ "${OPTARG:0:4}" = line ] ; then
           searchLine=${OPTARG:5}
           isSearchLine=t
        fi
        ;;
   \?)  descript
  esac
done

shift $(( $OPTIND - 1 ))

declare -a blk

#set -x

path=

# given files
if [ $# -gt 0 ] ; then
  fs=( $* )
  for(( i=0 ; i < ${#fs[*]} ; ++i )) ; do
    if [ ${fs[i]} != ${fs[i]##*/} ] ; then
       path[$i]=${fs[i]%/*}
       test ${#path[i]} -gt 0 && path[$i]=${path[i]}/
    else
       path[$i]=''
    fi

    test ${#dir} -gt 0 && mkdir -p ${path[i]}$dir
  done
fi

oldIFS="${IFS}"

if [ ${#fs[*]} -eq 0 -a ${#tokens[*]} -gt 0 ] ; then
  for t in ${tokens[*]//,/_} ; do
    fs[${#fs[*]}]=$( ls *$t*.log )
  done
fi

if [ ${#MERGE} -gt 0 ] ; then
  sed -i '1,/items:/ d' ${MERGE}.log
  cat $MERGE.log >> ${fs[0]}
  test $? -eq 0 && \rm -f $MERGE.log
fi

clearRedundantBlock

test ${isClearRedundant} = t && exit

if [ ${#grepArg[*]} -gt 0 ] ; then
   grepBlock
   exit
fi

if [ ${#tokens[*]} -gt 0 ] ; then
  # token can be defined in different files
  getByToken
  exit
fi

declare -a scopeName noScope isTotallyAtomic tags scopeEnd

xtrctGoodBad
