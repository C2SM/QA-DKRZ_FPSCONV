#! /bin/bash

##/*! \file qaConfiguration.h
## \brief Parse configuration given by file or command-line

## Priority: command-line statements overwrite all previous
## settings. If a <<t>> -f conf-file<</tt>> and <<t>> -t task-file <</t>>
## are available, then statements in the task-file overrules
## the conf-file. Task-files and config-file are formatted equivalently.\n \n
## Syntax of statements in a configuration file.
## Note: Default values in []\n
## SYNTAX: key[[+]=value[,value[,value,\newline ...]] \n
## -# There are key-words, assignments, comments. Key-words are always
## uppercase. Assignments of multiple values may be given as
## comma-separated lists. A comment is everything following the '#'
## character. Empty lines, and spaces are discarded.
## Notice that the spelling of key-words is not checked. Assignments may
## be anything. Unknown key-words (or typos) are ignored. Significant
## spaces (I hope there are none for CMIP5) have to be escaped by '\'.
## BUT, #this is not implemented. Will be done only on request!
## -# Assignment to a key-word is given by: key-word=value.
## -# Enabling/disabling features is done by assigning t/f to a
## key-word.
## A pure key-word on a text line defaults to true [t]
## e.g. ARITHMETIC_MEAN is equivalent to ARITHMETIC_MEAN=t.
## Disabling by assigning 'f' is equivalent to commenting out.
## -# Multiple line assignments. Multiple assignments must have
## key-word += value. Omittion of '+' overwrites previous assignments.\n
## -# SELECT/LOCK has a special syntax (with [] indicating optional):\n
## SELECT [path1[, path2, ...] = ] [var1[, var2, ...]]\n
## Note: '=' has a special meaning for SELECT; mulitple assignments just add.
## Same for LOCK.
##*/

# ##//! Default setting for some key-words.

setDefaults()
{
  # the comment 'export' denotes keywords which must be submitted
  # to the calling qaDirector

  # you should not leave this unchanged in the config file
  test ${#QA_RESULTS} -eq 0 && setKWL QA_RESULTS=${QA_SRC}/results

  setKWL QA_MANAGER_HOST=$HOSTNAME

  setKWL QA_BIN=${HOSTNAME}:${QA_SRC}/bin

  # A list of machines executing asynchronous jobs.
  setKWL QA_EXEC_HOSTS=$HOSTNAME

  # If a process cannot be run, because e.g. the data base
  # is not available or a server is absent, then, after a
  # sleep, retry. But only for the number of times spefied below.
  setKWL REATTEMPT_LIMIT=5 # export

  # In order to enable trapping signals, long sleeping period are
  # subdivided into smaller intervals of consecutive sleep commands.
  setKWL HARD_SLEEP_PERIOD=10        # [s] export

  # if not there then 'mail' will be set after a successful check
  setKWL MAIL=mailx

# List of number(s) of simultaneous entity of executors per host.
# This is a friendly act against your colleagues.
# Special: the one and only number is assigned to all QA_EXEC_HOSTS.
# Fine tuning: each positional number in the list corresponds to a
# position in the QA_EXEC_HOSTS list. If less positions are given
# than in QA_EXEC_HOSTS, then the last position is assigned to
# the omitted positions.
  setKWL NUM_EXEC_THREADS=1

  setKWL SLEEP_PERIOD=300            # [s] export
}

add2qaConf()
{
  local prospect=$1

  if [ ${prospect:0:2} = './' ] ; then
    prospect=${prospect:2}
  elif [ ${prospect:0:3} = '../' ] ; then
    local myPwd=$(pwd)
    prospect=${myPwd%/*}/${prospect:3}
  fi

  # found a name
  # test whether this name was already specified
  for(( i=0 ; i < ${#qaConf[*]} ; ++i )) ; do
    test "${qaConf[i]}" = "${prospect}" && return 1
  done

  qaConf[${#qaConf[*]}]=${prospect}

  return 0
}

changeGroupPermission()
{
  local sendText

  # Give permissions to all group members
  if [ ${#GROUP_NAME} -gt 0 ] ; then
    # change to new group name
    item=$( ls -ld $1 | awk '{print $4}' )
    if [ "$item" != "$GROUP_NAME" ] ; then
      if ! chgrp -R $GROUP_NAME $1 &> /dev/null ; then
        std_out "qaConfiguration::changeGroupPermission(): chgrp "
        std_out "Invalid group or you are probably not allowed to change group."
        std_out "If so, please ask your admin to chgrp -R $GROUP_NAME $1"
        std_out flush
        exit 1
      fi
    fi

    # set SGID bit
    item=$( ls -ld $1 | awk '{print $1}' )
    if [ ${#sendText} -eq 0 -a ${item:6:1} != s ] ; then
      # It would be amazing if chmod would not be allowed, but chgrp was
      find $1 -type d -exec chmod g+srwx {} \;
      find $1 -type f -exec $QA_SRC/scripts/cpMod {} \;
    fi
  fi
}

##//! Check availabillity of tools.

checkTools()
{
  local sendText  # failed checks will accumulate text
  local isExit=f;
  local str

  # check only tools, display, and exit
  CHECK_TOOLS=${CHECK_TOOLS:-f}

  # we know that it's bash

  if [ $CHECK_TOOLS = t ] ; then
    if [ ! -e $QA_SRC ] ; then
      std_out "$QA_SRC\t\t directory not found"
    else
      std_out "QA_SRC\t\t $QA_SRC"
    fi
  fi

  # all machines must share the same file system

  # invoke execution paths
  local bin l nnn
  for(( l=0 ; l < ${#QA_BIN[*]} ; ++l )) ; do
    bin=${QA_BIN[l]}
    bin=${bin%/}  # rm trailing '/'
    if ! mkdir -p ${bin#*:} &> /dev/null ; then
       std_out "Fatal error: could not mkdir ${bin#*:}"
    fi

    # valid on the qa-DKRZ host
    if [ "${bin#*:}" = "${bin}" ] ; then
      PATH=${bin}:$PATH  # this is 'imported' by qa-DKRZ
    elif [ "${bin%:*}" = "${HOSTNAME}" ] ; then
      PATH=${bin#*:}:$PATH  # this is 'imported' by qa-DKRZ
    fi
  done

  # test initial existance of some basic commands

  if [ ${#CHECKSUM} -gt 0 ] ; then
    local cs
    if [ ${CHECKSUM} = t ] ; then
      cs=md5
    else
      cs=${CHECKSUM%sum}
    fi

    if [ ! -x $cs ] ; then
      if tryExist com ${cs}sum ; then
         test $CHECK_TOOLS = t && std_out "${cs}sum\t\t available"
      else
         str="${cs}sum\t\t not found; switch to md5sum."
         test $CHECK_TOOLS = t && std_out "$str"
         CHECKSUM=md5
      fi
    fi
  fi

  if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
    # try mailx
    if tryExist com ${MAIL} void ; then
      test $CHECK_TOOLS = t && std_out "${MAIL}\t\t available"
    else
      MAIL=mail
      if tryExist com ${MAIL}  ; then
        test $CHECK_TOOLS = t && std_out "${MAIL}\t\t available"
      else
        EMAIL_TO=
        str="${MAIL}(x)\t\t not found; email notification disabled"
        test $CHECK_TOOLS = t && std_out "$str"
      fi
    fi
  fi

  if [ ${#HLEVD} -gt 0 ] ; then
    if tryExist com cdo ; then
      test $CHECK_TOOLS = t && std_out "cdo\t\t available"
    else
      std_out "cdo\t\t not found; disable HLEV."
      std_out "\t\tHLEVD is disabled."
      std_out "\t\tTo make it run, please, install CDO in PATH."
    fi
  fi

  local cprog
  for cprog in unixTime.x fModTime.x diskUsage.x; do
    if tryExist com ${cprog} ; then
      test $CHECK_TOOLS = t && std_out "${cprog}\t\t available"
    else
      std_out "${cprog}\t\t not available. Please, check installation."
      isExit=t
    fi
  done

  local cpp
  for cpp in getNC_att.x qA-${PROJECT_AS}.x syncFiles.x testValidNC.x ; do
    if tryExist com $cpp ; then
      test $CHECK_TOOLS = t && std_out "${cpp}\t\t available"
    else
      isExit=t
      std_out "${cpp}\t\t not available; please, check installation."
    fi
  done

  if tryExist com ping ; then
    test $CHECK_TOOLS = t && std_out "ping\t\t available"
  else
    unset PING_ENABLED
    std_out "ping\t\t not available"
  fi

  # a few simple commands
  local cmd
  for cmd in basename 'date +\'%F%T'' \
bc git grep kill ls mkdir mv perl rm sleep ssh svn test
  do
    if tryExist com $cmd ; then
      test $CHECK_TOOLS = t && std_out "${cmd}\t\t available"
    else
      isExit=t ;
      std_out "command: ${cmd}\t\t not available"
    fi
  done

  if  which awk &> /dev/null || which gawk &> /dev/null ; then
     test $CHECK_TOOLS = t && std_out "(g)awk\t\t available"
  else
     isExit=t ;
     std_out "(g)awk\t\t not available"
  fi

  if which expr &> /dev/null ; then
     if expr match asdf234 '.*f\([[:digit:]]*\)' &> /dev/null ; then
       test $CHECK_TOOLS = t && std_out "expr\t\t available"
     else
       sendText="${sendText}\nexpr match asdf234 \'.*f\([[:digit:]]*\)\': no"
       isExit=t ;
       std_out "expr\t\t available, but not working"
     fi
  else
     isExit=t ;
     std_out "expr\t\t not available"
  fi

  # no email notification
  test ${CHECK_TOOLS} = t && exit 1

  if [ ${isExit} = t ] ; then
    std_out flush
    exit 1
  fi
}

##//! Description of usage on the terminal

##/*!
## In case of --help or invalid command-line argument.
##*/

descript()
{
  local com localDev text

  if [ -c "${TTY}" ] ; then
    # output to a terminal
    com=cat
    localDev="> $TTY"
  else
    # EMail
    if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
      if which mail &> /dev/null ; then
        com="mail -s $sendSubject ${EMAIL_TO[*]}"
      elif which mailx &> /dev/null ; then
        com="mailx -s $sendSubject ${EMAIL_TO[*]}"
      fi
    elif [ ${#SESSION_LOGDIR} -gt 0  ] ; then
       # session log-file
       com=cat
       localDev='>> $SESSION_LOGDIR/session.log'
    elif [ ${#QA_SRC} -gt 0 ] ; then
      # NoDevice
      local str0
      str0="undeliv_$( date +'%FT%T' )_${HOSTNAME%%.*}".txt
      if mkdir -p $QA_SRC/NoDevice &> /dev/null ; then
        com=cat
        localDev='>> ${QA_SRC}/NoDevice/$str0'
      fi
    fi
  fi

  # provide text for -E_ enabled option description
  local enableOptText
  displayComLineOptions # text appended below


  eval $com $localDev <<!
$sendText

Usage: qa-DKRZ options

  Quality Control of file system based ${PROJECT} experiments.

  QA for file system (FS) based data of climatological experiments
  contained in netCDF files.
  The QA builds directories for storage of check-log files, session
  annotations and time series (netCDF) of QA specific data. The
  latter is given in a directory tree similar to the one of the original
  data, i.e. arranged for variables and the corresponding frequency.
  The logfiles for checked experiments are stored within directory
  'check_logs', which contain sub-dirs _Notes and _Periods for
  annotations of failed checks and checked time-range, respectively.
  Please, have a look at QA-DKRZ/doc/qa-user-manual.pdf for more details.

  A run is usually started by executing:
     path/QA-DKRZ/scripts/qa-DKRZ options
  where options contain usually -c 'file' and/or -f 'file' for
  one or two configuration files.
  A configuration file with processing directives may contain a link
  to another configuration file with lower priority; there is no
  maximal nesting depth.

  Assignments on the command-line may overwrite those of
  the configuration file. However, most of command-line options
  are for short-term purposes (debugging, displaying status etc.).
  Usage of configuration file(s) is recommended.
  Each configuration assignment may be given on the command-line, but
  prefixed by '-E_'.

  Regular Expressions are permitted as applicable to the 'expr' command.
  Definition: A list is comma-separated in a single string.

  Usually key-words will be given only once, but are overruled
  corresponding to the priority of configuration files; but
  assignments could be appended by '+='.

  Assignments ot key words SELECT and LOCK exhibit identical,
  but specific behaviour. The assignment character '=' is replaced
  by a space. However, continuation of assignments (appending) is
  done with '+=*. SELECT and LOCK, respectively, may be substituted
  by -S and -L on the command-line.
  Syntax: [path1[,path2,...]]=[var1[,var2,...]]
  Examples ('path' denotes a sub-path continuing the
  one in PROJECT/DATA, 'var' inidcates a starting sub-string for
  file names [e.g. tas_.*day]):
  1) path=var
     specifies a path where to look for a single variable; the path
     may fork to and continue with several sub-paths (e.g. for frequencies).
  2) p1,p2=var
     two paths to look for a variable.
  3) a) p1=
     b) p1,p2=
     one and two paths, respectively, with every variable;
     equivalent to p1,p2=.*
  4) p1=v1,v2
     one path [in the sense of 1)] with two variables.
  5) var[,v2,v3]
     specified variables in every path.
  6) p1=,p2=v1...  --> This is an ERROR.
  7) no '=' character
     a) not a path: variable(s) in all sub-paths prolonging the one
        in PROJECT_DATA, equivalent to '.*', e.g.
        by -S var on the command-line.
     b) contains at least a single '/' character; this is
        equivalent to 3a).

  But, if you want to make a run only for a specific variable
  or a group of entries using Regular Expression, then using
  the command-line is reasonable. Also some features are only
  enabled via the command-line, e.g. -E_DEBUG_... .

  Options:
   -E_...    Enable where ... indicates a configuration directive.
             An key-word with appended '=' character expects a value;
             items without assignments are boolean switches (t or f) where
             a key-word without any assign,ment expands to (t).
             Detailed description is given in file
             QA-DKRZ/example/CORDEX_qa.conf .
   -c name   Read configuration.
   -f name   Read configuration.
             Note: one configuration file may contain frequently
             modified assignments while the other hold all time
             assignments. If a name without leading path component
             is not available locally, then QA-DKRZ/tables is searched.
             Note: files for -c and -f are arbitrarily convertible.
   -h/--help This description.
   -L        Locking of paths and variables
   -m        Monitor variable name most recently qa'ed in status line.
   -P        Project name (usually PROJECT= in a config-file).
   -S        Selection of paths and variables (see config-file).
   -x        Equivalent to -E_DEBUG_C -E_DEBUG_E -E_DEBUG_M.
   --auto-up[=disable]
             Permanently enable/disable automatic svn updates:
             no assigment enables, disabling by: --auto-up=d or --auto-up=disable .
   --pb[=filename[,step]]
             Progress bar properties.
             Output of number of processed data files and total number of data files;
             if a filename is not provided, then to stdout. Note that stdout should be
             redirected if option -m is also active. The step defines the stepping rate
             of the output in terms of percentage; 1% by default.
             Note that a filename must contain at least a single alpha char and
             that the step must not.
   --project_as=string
             The current PROJECT is treated as PROJECT=string, but with
             the name kept.

${enableOptText}
!
  exit 1
}

displayComLineOptions()
{
      enableOptText="\

      Additional options usually enabled on the command-line:
      CHECK_TOOLS           Check and show availability of tools and exit.
      DEBUG_C[ONFIGURATOR]  Log qaConfiguration processing to stderr.
      DEBUG_E[XECUTOR]      Log qaExecutor processing to files corresponding to
                            variable names (where qa-DKRZ was started).
      DEBUG_M[ANAGER]       Execution log of the qa-DKRZ to stderr.
      DEBUG_X[=script]      Enable debugging of external script; default all.
      FLOW_TRACE            Flow trace analysis of the qa-DKRZ main-loop.
                            Note that specific commenting-in is required.
      NEXT[=num]            Process the next num variables.
      ONLY_SUMMARY          Post-processed by default when ever a check
                            was performed (usually not necessary, because
                            this is performed at the end of a run).
      SHOW_CALL             Show the qA_main.x call; no execution.
      SHOW_CONF             Show configuration and exit.
      SHOW_EXP              Show names of paths with scheduled variables.
      SHOW_NEXT[=num}       Show num next scheduled variables and paths.
      REFRESH_CF_STANDARD   wget original sources from PCMDI into QA-DKRZ/tables.
      REUSE_PATH_LIST       Use a path-list left previously for a resumed session.
"

  test $# -eq 0 && return

  if [ -c "$TTY" ] ; then
    echo '' > $TTY
    cat > $TTY <<!
$enableOptText
!
  fi

}

findEmbeddedConf()
{
  local item
  local currConf=$1

  # look for a PROJECT setting in the current conf-files.
  local txt
  txt=$(grep '^[[:space:]]*[^#][[:space:]]*ROJECT=' ${currConf} )
  if [ ${#txt} -gt 0 ] ; then
    txt=${txt#*=}
    setKWL PROJECT=${txt%%#*}
  fi

  # look for a PROJECT_AS setting in the current conf-files.
  local txt2
  txt2=$(grep '^[[:space:]]*[^#][[:space:]]*ROJECT_AS=' ${currConf} )
  if [ ${#txt2} -gt 0 ] ; then
    txt2=${txt2#*=}
    setKWL PROJECT_AS=${txt2%%#*}
  elif [ ${#PROJECT_AS} -eq 0 -a ${#PROJECT} -gt 0 ] ; then
    setKWL PROJECT_AS=${PROJECT}
  fi

  # Is there a QA_CONFIG assignment embedded in the current file?
  # This separates commented-out from enabled QA_CONF assignment
  item="$(grep 'QA_CONF=' "${currConf}" 2> /dev/null )"
  item="${item// /}"
  item=( ${item} )           # several lines are possible
  item=( ${item[*]%%\#*} )
  item=( ${item[*]} )
  item=${item#QA_CONF=}

  # backward compatibility
  if [ ${#item} -eq 0 ] ; then
    item="$(grep 'QC_CONF=' "${currConf}" 2> /dev/null )"
    item="${item// /}"
    item=( ${item} )           # several lines are possible
    item=( ${item[*]%%\#*} )
    item=( ${item[*]} )
    item=${item#QC_CONF=}
  fi

  test ${#item} -eq 0 && return

  local ix p
  local pDir  # index 0 -> 3 provides precedence

  pDir[0]=''  # absolute or local path
  pDir[1]=${QA_SRC}/tables
  pDir[2]=${QA_SRC}/tables/${PROJECT_AS}
  pDir[3]=${QA_SRC}/tables/projects
  pDir[4]=${QA_SRC}/tables/projects/${PROJECT_AS}
  local ix

  for(( ix=0 ; ix < 5 ; ++ix )) ; do
    if [ -f ${pDir[ix]}/${item} ] ; then
       p=${pDir[ix]}/
       test ${ix} -eq 0 && p=$(pwd)/

       if add2qaConf ${p}${item##*/} ; then
         findEmbeddedConf ${p}${item##*/}
       fi
    fi
  done

  return
}

findStr()
{
  # find position of sub-string in string
  # $1: the string
  # $2: sub-string to find
  # $3: 'return' the position, if $3 exists

  local i
  local len=${#2}
  local end=$(( ${#1} - len + 1 ))

  for(( i=0 ; i < end ; ++i )) ; do
    if [ "${1:i:len}" = "$2" ] ; then
      test ${#3} -gt 0 && eval ${3}=$i
      return 0
    fi
  done

  return 1
}

getConfPriority()
{
  # the first two items of array 'task_priority' would have been
  # set while performing getops().

  test "${PROJECT}" = NONE && return

  local i item qaResults swp sz1 sz

  # in case there are multiple conf files, then 'task' files followed by
  # the sequence of embedded QA_CONF assignments get
  # priority with the order the task-files are specified.
  sz1=$(( ${#qaConf[*]} -1 ))
  sz=${#qaConf[*]}
  local i1 i2

  for(( i1=0 ; i1 < sz1 ; ++i1 )) ; do
    for((i2=i1+1 ; i2 < sz ; ++i2 )) ; do
      if [ "${qaConf[i1]##*.}" != task -a "${qaConf[i2]##*.}" = task ] ; then
      swp=${qaConf[i1]}
      qaConf[${i1}]=${qaConf[i2]}
      qaConf[${i2}]=${swp}
    fi
    done
  done

  # resolve relative paths
  for(( i1=0 ; i1 < sz ; ++i1 )) ; do
    if [ ${qaConf[i1]:0:2} = './' ] ; then
      qaConf[i1]=${qaConf[i1]:2}
    elif [ ${qaConf[i1]:0:3} = '../' ] ; then
      item=$(pwd)
      item=${item%/*}
      qaConf[i1]=${item}/${qaConf[i1]:3}
    fi
  done

  # if a config file found so far is not a valid file, then try in
  #   1) QA_SRC/tables
  #   2) QA_SRC/tables/projects

  # go through the chain of config files unless no more
  # is found or a path found before is found again;
  # an invalid file would also break processing
  sz=${#qaConf[*]}
  local j

  for(( i=0 ; i < sz ; ++i )) ; do
    # attach a chain of embedded conf-files
    # sets also PROJECT if found in the sequence of conf-files.
    if ! add2qaConf ${qaConf[i]} ; then
      findEmbeddedConf ${qaConf[i]}
    fi
  done

  # PROJECT is given, then try for a default name in the
  # paths: local, tables, tables/projects
  if [ ${#PROJECT_AS} -gt 0 ] ; then
    local name
    name=${PROJECT_AS}_qa.conf

    local p
    for p in '' ${QA_SRC}/tables/ ${QA_SRC}/tables/projects/ ; do
      if [ -f ${p}${name} ] ; then
         # add to qaConf array preserving uniquness
         if ! add2qaConf ${p}${name} ; then
           findEmbeddedConf ${p}${name}
         fi
      fi
    done
  fi

  # construct a comma-sep-list
  test ${#qaConf[*]} -gt 0 && QA_CONFS=${qaConf[0]}

  for(( i=1 ; i < ${#qaConf[*]} ; ++i )) ; do
    QA_CONFS="${QA_CONFS},${qaConf[i]}"
  done

  if [ ${#qaC} -gt 0 ] ; then
    setKWL TASK=${qaConf[0]##*/}
  fi

  return
}

initSession()
{
  # Create sub-dir structure for different logs, but
  # the check_logs. md5sum checksums of conf and task
  # (all may be omitted and substituted by '-') are written to a file.
  # Specific command-line options (SHOW_*)
  # will write 'test_session', i.e. set RESUME_SESSION=f.
  # A session is definded by conf and task files given
  # in array QA_CONF.
  # When all checkums of the current files are found in a previous session,
  # then the latter is resumed, i.e. RESUME_SESSION=t.
  # Explicit RESUME_SESSION=f disables.

  # base path to sessions
  test ! -d ${QA_RESULTS}/session_logs && mkdir -p ${QA_RESULTS}/session_logs

  setKWL RESUME_SESSION=t  # by default

  # force a new session, although resuming would be possible
  test ${FORCE_NEW_SESSION:-f} = t && setKWL RESUME_SESSION=f

  # find test-cases from command-line options
  local i j cl testCase

  for(( i=0 ; i < ${#comLine[*]} ; ++i )) ; do
    cl=${comLine[i]}

    test ${cl:0:7} = '-E_SHOW'  \
        && testCase=t \
             && setKWL RESUME_SESSION=f \
                 && break
  done

  # current checksums; note: md5sum ouputs two items: checksum and filename
  # (filename is substituted by '-' for reading from input)
  local curr_md5
  declare -a curr_md5
  local currDate=$( date +'%F_%T' )

  local qaC qaCs
  qaCs=( ${QA_CONFS[*]//,/ } )

  if [ ${#qaCs[*]} -gt 0 ] ; then
    for qaC in ${qaCs[*]}  ; do
      curr_md5=( ${curr_md5[*]} $( md5sum $qaC | awk '{print $1}') )
    done
  else
    curr_md5=( '-' )
  fi

  # test for resuming a session
  if [ ${RESUME_SESSION} = t ] ; then
    local k l sDates
    local dates0 dates1
    declare -a dates0 dates1

    # look for a previous identical session given in file sess_md5.txt
    if [ -f ${QA_RESULTS}/session_logs/sess_md5.txt ] ; then
      # first item is a date, second is a checksum.
      dates0=( $(grep "${curr_md5[0]}" \
                ${QA_RESULTS}/session_logs/sess_md5.txt 2> /dev/null \
                | awk '{print $1}' ) )

      for(( k=1 ; k < ${#qaCs[*]} ; ++k )) ; do
        dates1=( $(grep "${curr_md5[k]}" \
                 ${QA_RESULTS}/session_logs/sess_md5.txt 2> /dev/null \
                 |  awk '{print $1}' ) )

        for(( i=${#dates0[*]}-1 ; i >-1 ; --i )) ; do
          for(( j=0 ; j < ${#dates1[*]} ; ++j )) ; do
            # compare to the date of another conf/task file
            if [ ${dates0[i]} = ${dates1[j]} ] ; then
              continue 2
            fi
          done
          unset dates0[${i}]
        done
      done

      dates0=( ${dates0[*]} )  # remove empty items

      if [ ${#dates0[*]} -eq 1 ] ; then
        setKWL SESSION=${dates0[0]}
      else
        local is=t
        for(( j=1 ; j < ${#dates0[*]} ; ++j )) ; do
          test ${dates0[0]} != ${dates0[j]} && is=f
        done
        test ${is} = f -o ${#dates0[*]} -eq 0 && setKWL RESUME_SESSION=f
      fi
    else
      setKWL RESUME_SESSION=f
    fi
  else
    if [ ${testCase:-f} = t ] ; then
      setKWL SESSION=test_session
      test -d ${QA_RESULTS}/session_logs/test_session && \
         \rm -r ${QA_RESULTS}/session_logs/test_session
    fi

    setKWL RESUME_SESSION=f
  fi

  # session date wasn't set externally.
  if [ ${RESUME_SESSION} = f -a ${testCase:-f} = f ] ; then
    for(( k=0 ; k < ${#qaCs[*]} ; ++k )) ; do
      # write a new entry for each conf/task file
      echo -e -n "${currDate}\t" \
             >> ${QA_RESULTS}/session_logs/sess_md5.txt
      echo -e -n "${curr_md5[k]}\t" \
             >> ${QA_RESULTS}/session_logs/sess_md5.txt
      echo       "${qaCs[k]}" \
             >> ${QA_RESULTS}/session_logs/sess_md5.txt
    done

    setKWL SESSION=${currDate}
  fi

  setKWL SESSION_LOGDIR=${QA_RESULTS}/session_logs/${SESSION}
  mkdir -p ${SESSION_LOGDIR}

  return
}

loadSetting()
{
  local tmp

  if [ ${#QA_SRC} -eq 0 ] ; then
    sendSubject='QA: initialisation error'
    std_out "QA_SRC must be set. Exit."
    std_out flush
    exit 1
  fi

  if [ ! -d "$QA_SRC" ] ; then
    sendSubject='QA: initialisation error'
    std_out "Source dir $QA_SRC must exist and must be writable. Exit."
    std_out flush
    exit 1
  fi

  if [ ${#QA_RESULTS} -eq 0 ] ; then
    sendSubject='QA: initialisation error'
    std_out "missing QA_RESULTS assignment. Exit."
    std_out flush
    exit 1
  fi

  tmp=(${PROJECT_DATA[*]//,/ })
  tmp=(${tmp[*]%/})  # rm trailing '/'

  # completion of relative paths
  for(( i=0 ; i < ${#tmp[*]} ; ++i )) do
    test ${tmp[i]:0:1} = '/' && continue

    if [ ${tmp[i]:0:2} = './'  ] ; then
      tmp[${i}]=$(pwd)${tmp[i]:1}
    elif [ ${tmp[i]:0:3} = '../'  ] ; then
      myPwd=$(pwd)
      tmp[${i}]=${myPwd%/*}${tmp[i]:2}
    else
      tmp[${i}]=$(pwd)/${tmp[i]}
    fi
  done

  tmp="${tmp[*]}"
  PROJECT_DATA=${tmp// /,}

  QA_SRC=${QA_SRC%/}  # rm trailing '/'

  QA_RESULTS=${QA_RESULTS%/}  # rm trailing '/'
  if [ ${QA_RESULTS:0:1} != '/' ] ; then
    if [ ${QA_RESULTS:0:2} = './'  ] ; then
      QA_RESULTS=$(pwd)${QA_RESULTS:1}
    elif [ ${QA_RESULTS:0:3} = '../'  ] ; then
      myPwd=$(pwd)
      QA_RESULTS=${myPwd%/*}${QA_RESULTS:2}
    else
      QA_RESULTS=$(pwd)/${QA_RESULTS}
    fi
  fi

  for pD in ${PROJECT_DATA[*]//,/ } ; do
    if [ ! -d "$pD" ] ; then
      std_out "PROJECT_DATA: $pD not found"
      std_out flush
      exit 1
    fi

    if [ "$pD" = "$QA_RESULTS" ] ; then
      # this must not happen
      sendSubject='QA: configuration error'
      std_out "Conflict: QA_RESULTS and PROJECT_DATA are identical. Exit."
      std_out flush
      exit 1
    fi

  done


  if [ ${#PROJECT_DATA} -eq 0 ]  ; then
    local isRoot=t
    for(( i=0 ; i < ${#pathList[*]} ; ++i )) ; do
      test ${pathList[i]:0:1} != '/' && isRoot=f && break
    done

    if [ ${isRoot} = t ] ; then
      # get it from SELECT with absolute path
      for(( i=0 ; i < ${#pathList[*]} ; ++i )) ; do
        test ${#PROJECT_DATA} -gt 0 && PROJECT_DATA="${PROJECT_DATA},"

        PROJECT_DATA="${PROJECT_DATA}${pathList[i]%/*}"
        pathList[i]=${pathList[i]##*/}
      done

      setKWL PROJECT_DATA=${PROJECT_DATA}
    else
      std_out "missing PROJECT_DATA assignment."
      std_out flush
      exit 1
    fi
  fi

  # Naming and placement of the base dirs in QA_RESULTS.
  # Inits also session-logs
  naming

  # change permissions
  changeGroupPermission $QA_SRC
  if [ "${QA_RESULTS:0:${#QA_SRC}}" != "$QA_SRC" ] ; then
    changeGroupPermission $QA_RESULTS
  fi

  # any error case happened before is written now
  if [ ${#sendSubject} -gt 0 ] ; then
    std_out flush
    exit 1
  fi

  # check required directories, files and executables
  checkTools

}

parseConfigurationFile()
{
  local confFile=$1

  local isBlockBeg=t
  local block

  if [ ${#confFile} -gt 0 ] ; then
     if [ ! -e $confFile ] ; then
       return
     fi
  else
     return
  fi

  # now parse the configuration file.

  confLine=

  # Assignments from multiple lines infer their termination from
  # the next comment/blank line.
  # Reading lines happens in function parseLines (clear comments)

  # connect filename to input; keep it open for the while-loop
  exec 0< $confFile

  set -f

  while parseLines ; do
    if [ $isBlockBeg = t -a ${#line} -gt 0 ] ; then
      if findStr "$line" ':=' ; then
        # assignement of multi-line block.
        # Requires an empty or comment line underneath.
        isBlockBeg=f  # reset to true for a new- or comment-line
        line=${line/:=/=}
      fi

      block=
    fi

    # parsing for: key-word[=...]
    # find the key-word
    block=${block}${line}

    # read next line of a block
    test $isBlockBeg = f && continue

    # special: SELECT and LOCK syntax
    if [ "${block:0:6}" = 'LOCK+=' ] ; then
       sel_lock L ${block:4}
       continue
    elif [ "${block:0:5}" = 'LOCK=' ] ; then
       sel_lock L ${block:4}
       continue
    elif [ "${block:0:4}" = LOCK ] ; then
       # compatibility: multiple of such assignments are added
       if [ ${#pathList[*]} -eq 0 ] ; then
         sel_lock L =${block:4}
       else
         sel_lock L +=${block:4}
       fi
       continue
    fi

    if [ "${block:0:8}" = 'SELECT+=' ] ; then
       sel_lock S ${block:6}
       continue
    elif [ "${block:0:7}" = 'SELECT=' ] ; then
       sel_lock S ${block:6}
       continue
    elif [ "${block:0:6}" = SELECT ] ; then
       # compatibility: multiple of such assignments are added
       if [ ${#pathList[*]} -eq 0 ] ; then
         sel_lock S =${block:6}
       else
         sel_lock S +=${block:6}
       fi
       continue
    fi

    # assignment (blocks) are parsed
    parseKeyWordList
  done

  set +f
  # disconnect filename to input
  exec 0<&-
}

naming()
{
  # A change in the placement of results.

  # QA_RESULTS will contain sub-dirs:
  # tables, data, check_logs,
  # and checksum; the latter only on request.
  # Sub-dir session_logs contains config, tasks, processing information.
  # As before, directory data/${PROJECT} will get the dir-tree spanned by
  # PROJECT_DATA=.*/project-name/dir-tree

  setKWL QA_RESULTS=$QA_RESULTS

  # the place for general log-messages
  initSession

  # sub-dir for experiment logs
  setKWL EXP_LOGDIR=${QA_RESULTS}/check_logs
  mkdir -p $EXP_LOGDIR

  if ! mkdir -p ${QA_RESULTS}/data ; then
    sendSubject='QA: initialisation error'
    std_out "Could not mkdir ${QA_RESULTS}/data. Exit."
    std_out flush
    exit 1
  fi

  # determine the final table paths

  # project table
  if [ ${#TABLE_PATH} -eq 0 ] ; then
    TABLE_PATH=${QA_RESULTS}/tables
    test ! -d ${TABLE_PATH} && mkdir -p ${TABLE_PATH}
    setKWL TABLE_PATH=${TABLE_PATH}
  else
    # provided by configuration file
    # rm trailing '/'; does nothing, if such is not there
    TABLE_PATH=${TABLE_PATH%/}
  fi

  if [ ! -d "${TABLE_PATH}" ] ; then
    std_out "Expecting a directory ${TABLE_PATH}. Please, check the configuration file."
    std_out flush
    exit 1
  fi
}

parseKeyWordList()
{
   local key val tmp
   key=${block%%=*}

   if [ "$key" = "${block}" ] ; then
     val=
   else
     # Note: leading blanks have already been removed in parseLines()
     val="${block#*=}"   # remove ${key}=
   fi

   # compatibility
   if [ ${key} = IGNORE_REPLICATED_RECORDS ] ; then
      key=REPLICATED_RECORD
      val=ignore,${val/%,/}
   fi
   if [ ${key} = DISCARD_REPLICATED_RECORDS ] ; then
      key=REPLICATED_RECORD
      val=discard,${val/%,/}
   fi

   # allow RECORDS as well as RECORD (the latter will be used)
   pos=$(( ${#key} - 7 ))
   if [ "${key:pos}" = RECORDS ] ; then
     key=${key:0:$(( ${#key} -1 ))}
   fi

   # enable by just naming
   test ${#val} -eq 0 && val=t

   setKWL ${key}="${val/%,/}"  # remove trailing ',', if present
   return
}

##//! Parse single lines of a configuration file

##/*!
## Discard comments and spaces.
##*/

parseLines()
{
  local line_
  local status
  unset line

  while : ; do
     # read a line
     read -r line_
     status=$?
     test ${status} -eq 1 -a ${#line_} -eq 0 && return 1

     # remove trailing comments from the line
     line_=$( expr match "$line_" '\([^#]*\)' )

     # in case of not empty, a non-comment-line was found
     test ${#line_} -gt 0  && break

     # reaching this indicates that a comment- or newline
     # was found

     if [ $isBlockBeg = f ] ; then
       # found the end of a block; process block
       isBlockBeg=t
       line=
       return 0
     fi
  done

  local i sz
  sz=${#line_}
  for((i=0 ; i < sz ; ++i )) ; do
    test "${line_:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    line_="${line_//QC/QA}"
  else
    local tmp0="${line_:0:i}"
    tmp0="${tmp0//QC/QA}"
    line_="${tmp0}""${line_:i}"
  fi

  # we'd like to remember effective lines in the conf file
  confLine=${confLine}"${line_}"\\n

  # replace accidently used key-word: LOCKED or SELECTED
  test "$( echo -n "${line_:0:6}" \
     | tr [:lower:] [:upper:])" = "LOCKED" \
       && line_="LOCK${line_:6}"

  test "$( echo -n "${line_:0:8}" \
     | tr [:lower:] [:upper:])" = "SELECTED" \
       && line_="SELECT${line_:8}"

  # remove blanks from line
  line="${line_// /}"

  return 0
}

##//! Parse command-line options.

parseOPTARG()
{
  local key value

  key=${1:1}

  value=
  test $# -eq 2 && value=$2

  if [ "${key}" = "ADD_PROG_ARG" ] ; then
    ADD_PROG_ARG=( ${ADD_PROG_ARG[*]} ${value} )
    keyWordList[${#keyWordList[*]}]=ADD_PROG_ARG
    return
  fi

  if [ "${key}" = "CHECK_TOOLS" ] ; then
    CHECK_TOOLS=t
    checkTools
    exit 1
  fi

  test "${key}" = CYCLE && \
    setKWL CYCLE=${value:-1} && return

  test "${key:0:7}" = DEBUG_C && \
    set -x && return

  test "${key:0:7}" = DEBUG_E && \
    setKWL DEBUG_EXECUTOR=t && return

  test "${key:0:7}" = DEBUG_M && \
    setKWL DEBUG_MANAGER=${value:-t} && return

  test "${key}" = NEXT && \
    setKWL NEXT=${value:-1} && return

  test "${key}" = SHOW_OPT && \
    displayComLineOptions 'dumb' && exit 1

  if [ "${key}" = NOTE ] ; then
    for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
      if [ "${key}" = ${keyWordList[i]} ] ; then
        NOTE="${value}","${NOTE[*]// /,}"
        return
      fi
    done

    setKWL NOTE="${value}"
  elif [ "${key}" = OUTLIER_TEST ] ; then
    for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
      if [ "${key}" = ${keyWordList[i]} ] ; then
        OUTLIER_TEST="${value}","${OUTLIER_TEST[*]// /,}"
        return
      fi
    done

    setKWL OUTLIER_TEST="${value}"
  else
    # no more syntax checks; invoke all
    setKWL ${key}=${value:-t}
  fi
}

##//! parse SELECT and LOCK assignments
sel_lock()
{
  # Note for SELECT, LOCK, -S and -L usage:
  # General setting:  {space, = ,+=}[path[=]][variable]

  # Examples:
  # leading character(s) supplied by the calling instances
  # -) '=' define or overwrite
  # -) '+=' prolong array of paths/variables
  # -) no leading '=' character equivalent to +=
  # -) not a path: variable(s) to path '.*', e.g. by -S var
  # -) contains '/', thus equivalent to 3)

    # 1) path=var
  #    specifies a single path where to look for a single variable
  # 2) p1,p2=var
  #    two paths to look for a variable
  # 3) p1,p2=
  #    two paths with every variable, equivalent to p1,p2=.*
  # 4) p1=v1,v2
  #    one path with two variables
  # 5) str1[,str2,str3]
  #    a) no '/' --> variables
  #    b) '/' anywhwere  --> only paths; no trapping of errors
  # 6) relative path without a '/' must have '=' appended
  # 7) p1=,p2=v1...  --> ERROR


  local i p v z

  # this is very special: a fully qualified file
  if [ -f $2 ] ; then
    z=${2%/*}=${2##*/}
  elif [ -f ${2:1} ] ; then
    z=${2%/*}=${2##*/}
  else
    z=$2
  fi

  while : ; do
    if [ ${z:0:1} = '=' ] ; then
      if [ $1 = S ] ; then
        pathList=
        varList=
      elif [ $1 = L ] ; then
        lockPathList=
        lockVarList=
      fi

      z="${z:1}"
    elif [ ${z:0:2} = '+=' ] ; then
      z=${z:2}
    elif [ ${z//=/} = ${z} -a ${z//\//} != ${z} ] ; then
#     z=${z}= # 7b), thus again
      break
    else
      if [ $1 = S ] ; then
        # only variable, no path
        if [ ${#pathList[*]} -gt 0 -a "${z//=/}" = "${z}" ] ; then
          z="${pathList[$((${#pathList[*]} -1 ))]}=${z}"
          pathList=
          varList=
        fi
      elif [ $1 = L ] ; then
        if [ ${#lockPathList[*]} -gt 0 -a "${z//=/}" = "${z}" ] ; then
          z="${lockPathList[$((${#lockPathList[*]} -1 ))]}=${z}"
          lockPathList=
          lockVarList=
        fi
      fi
    fi

    break;
  done;

  # now assignment mode is determined; parse on
  v=${z#*=}
  p=${z%=*}

  # no path, but only variable?
  if [ "$p" = "$v" ] ; then
    # test for a slash
    if [ "${p/\/}" = "${p}" ] ; then
      # no path; only variable
      p='.*'
    else
      v='.*'
    fi
  elif [ ${#p} -eq 0 -a ${#v} -gt 0 ] ; then
      # no path; only variable
      p='.*'
  elif [ ${#p} -gt 0 -a ${#v} -eq 0 ] ; then
      # no variable; only path
      v='.*'
  elif [ ${#v} -eq 0 ] ; then
    # there is only a path, but no explicit variable
    v='.*'
  fi

  # path and variable

  # multiple, comma-separated paths?
  local j pp vv
  pp=( ${p//,/ } )
  vv=( ${v//,/ } )
  p=()
  v=()

  for(( i=0 ; i < ${#pp[*]} ; ++i )) ; do
    for(( j=0 ; j < ${#vv[*]} ; ++j )) ; do
      p[${#p[*]}]=${pp[i]}
      v[${#v[*]}]=${vv[j]}
    done
  done

  # selection or a lock?
  if [ $1 = 'S' ] ; then
    pathList=( ${pathList[*]} ${p[*]} )
    varList=( ${varList[*]} ${v[*]} )
  elif [ $1 = 'L' ] ; then
    lockPathList=( ${lockPathList[*]} ${p[*]} )
    lockVarList=( ${lockVarList[*]} ${v[*]} )
  fi

  return
}

sendEMail()
{
  if [ ${#EMAIL_TO[*]} -eq 0 ] ; then
    sendText=
    sendSubject=
    return
  fi

  # activate backslash escaped chars
  sendText="$( echo -e $sendText )"

  eval ${MAIL} -s \"\$sendSubject\"  ${EMAIL_TO[*]} <<!
$sendText
!

  sendText=
  sendSubject=

  return
}

sendInitEMail()
{
  # activate backslash escaped chars
  sendText="$( echo -e $sendText )"

  eval ${MAIL} -s "$sendSubject"  ${EMAIL_TO[*]} <<!
$sendText

Configuration File Setting:
$( echo -e $confLine )

Command-line parameters:
$( echo "${comLine[*]}" )

Current Paths:
Source directory: $QA_SRC
QA data directory: $QA_RESULTS/data
FS data directory: ${PROJECT_DATA[*]}
!

  # this is required at some places
  sendText=
  sendSubject=

  return
}


##//! Convert assignment literals to Bash variables.

setKWL()
{
  local key item value i val vals isAdd
  item="$*"

  for(( i=0 ; i < ${#item} ; ++i )) ; do
     if [ "${item:i:1}" = '+' ] ; then
        isAdd=t
        key="${item%%+=*}"

        break
     fi
     if [ "${item:i:1}" = '=' ] ; then
        isAdd=f
        key="${item%%=*}"
        break
     fi
  done

  key=$( echo "${key/% /}" | tr "[:lower:]" "[:upper:]" )
  value="${item#*=}"

  # disable --> f
  test "${value:0:7}" = disable && value=f

  # take deprecated SHOW_EXP_NAME into account
  test "${key:0:8}" = SHOW_EXP && key=SHOW_EXP
  test "${key:0:9}" = POST_PROC && key=POST_PROC
  test "${key}" = HIDDEN_DIRECTORY_DESCENT && key=HIDDEN_DIRECTORIES

#  eval ${key}="${value// /\\ /}"

  # special: QA_BIN
  if [ "$key" = QA_BIN ] ; then
    value=${value%/}  # rm a trailing '/'
    vals=( ${value//,/ } )
    local host hosts
    for(( i=0 ; i < ${#vals[*]} ; ++i )) ; do
      val=${vals[i]}
      if [ "${val#*:}" = "${val}" ] ; then
        hosts[i]=''
      else
        hosts[i]="${val%:*}:"
      fi
      val=${val#*:}
      test "${val}" != "${vals[i]}" && vals[i]=${val}
    done

    # rearrange the array: the bin-dir of HOSTNAME is set
    # to the first position.
    for(( i=0 ; i < ${#vals[*]} ; ++i )) ; do
       if [ "${hosts[i]}" = "${HOSTNAME}:" \
                -o  ${#hosts[i]} -eq 0 ] ; then
         if [ $i -eq 0 ] ; then  # right order
           hosts[0]=''
           break
         fi

         local tmp
         tmp="${hosts[0]}"
         hosts[0]="${hosts[i]}"
         hosts[i]=$tmp

         tmp="${vals[0]}"
         vals[0]="${vals[i]}"
         vals[i]=$tmp

         break
       fi
    done

    QA_BIN=
    # convert relative paths to abolute ones
    test "${vals[0]:0:1}" != '/' && vals[0]=${QA_SRC}/${vals[0]}
    QA_BIN[0]=${vals[0]}

    for(( i=1 ; i < ${#vals[*]} ; ++i )) ; do
      # convert relative paths to abolute ones
      test "${vals[i]:0:1}" != '/' && vals[$i]=${QA_SRC}/${vals[i]}

      QA_BIN[${#QA_BIN[*]}]=${hosts[i]}${vals[i]}
    done
    value="${QA_BIN[*]}"
    value=${value// /,}
    unset QA_BIN

    # to be applied within this script
    curr_QA_BIN=${value%%,*}
  fi

  # was key already defined?
  for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
     if [ "${keyWordList[i]}" = "$key" ] ; then

      # plain assignments require to unset before reassignments
      if [ $isAdd = f ] ; then
#        eval unset $key
        eval ${key}=${value}
      else
        tmp=${keyWordList[i]}
        eval $key=\${$tmp},${value// /\\ }
      fi

      return
    fi
  done

  # new key
  eval ${key}="${value}"

  # add key to the list
  keyWordList[${#keyWordList[*]}]=$key

  return
}

std_out()
{
  # if a tty device is connected, then output immediately,
  # else collect contents and print to a default file and/or
  # send by email.

  test $# -eq 0 && return

  if [ "$1" = ttyOnly ] ; then
    if is_TTY ; then
       shift
       echo -e -n "$*" > $TTY
    fi
    return
  fi

  if [ "$1" = flush ] ; then
    local j str0

    test ${#outputText[*]} -eq 0 && return

    if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
      for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
        # each item begins with \n
        sendText="${sendText}\n${outputText[j]}"
      done
      if [ ${#sendSubject} -eq 0 ] ; then
        sendSubject="qaConfiguration: message"
      fi
      sendEMail
    elif [ ${#SESSION_LOGDIR} -gt 0 ] ; then
      str0="$( date +'%F %T' ) ${HOSTNAME%%.*}:qaConfiguration"
      echo -e "\n${str0}" >> $SESSION_LOGDIR/session.log

      for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
        echo -e "${outputText[j]}" >> $SESSION_LOGDIR/session.log
      done
    else
      # str0 gets the filename for undeliverables
      str0="undeliv_$( date +'%FT%T' )_${HOSTNAME%%.*}".txt
      if mkdir -p $QA_SRC/NoDevice &> /dev/null ; then
        for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
          echo -e "${outputText[j]}" >> $QA_SRC/NoDevice/$str0
        done
      fi
    fi
  else
    if [ -c "${TTY}" ] ; then # character device is open?
      echo -e "$*" > $TTY
    else
      outputText[${#outputText[*]}]="$*"
    fi
  fi
}

tryExist()
{
  # if test fails, then something is written to sendText

  # $1:   'dir' | 'file' | 'com'
  # $2:    name of directory, file or command
  # $3:   key-word: 'compile' ; default: scan the path for the command.
  # $3:   key-word: 'void' ; return -1 without notification.

  #return 0 ==> exists
  #return 1 ==> no

  if [ "$1" = 'dir' ] ; then
    if [ ! -d $2 ] ; then
      sendText="${sendText}\nDirectory $1 not found."
      return 1
    fi

    return 0
  fi

  if [ "$1" = 'file' ] ; then
    if [ ! -e $2 ] ; then
      sendText="${sendText}\nFile $1 not found."
      return 1
    fi

    return 0
  fi

  if [ "$1" = 'com' ] ; then
    if which ${curr_QA_BIN#*:}/$2 &>/dev/null ; then
      return 0
    elif [ "$3" != 'compile' ] ; then
      if which $2 &>/dev/null ; then
        return 0
      fi
      test "$3" != 'void' && \
         sendText="${sendText}\n command $2 not found."
      return 1
    fi

    # try a C compilation
    if [ -e ${QA_SRC}/src/${2%.x}.c ] ; then
      if [ ${#CC} -eq 0 ] ; then
        sendText="${sendText}\nC compiler not found."
        return 1
      fi

      local answ status
      answ=$( $CC ${CFLAGS[*]} -o ${curr_QA_BIN#*:}/$2 \
          ${QA_SRC}/src/${2%.x}.c )

      status=$?
      if [ ${status} -eq 0 ] ; then
        return 0
      else
        sendText="${sendText}\n${answ}"
        return 1
      fi

    # try a C++ compilation
    elif [ -e ${QA_SRC}/src/${2%.x}.cpp ] ; then
      if [ ${#CXX} -eq 0 ] ; then
        sendText="${sendText}\nC++ compiler not found CXX=${CXX}."
        return 1
      fi

      local answ status
      answ=$( $CXX ${CPPFLAGS[*]} -o ${curr_QA_BIN#*:}/$2 \
          ${QA_SRC}/src/${2%.x}.cpp &> /dev/null )

      status=$?
      if [ ${status} -eq 0 ] ; then
         return 0
      else
        sendText="${sendText}\n${answ}"
        return 1
      fi
    else
      if [ ! -e ${curr_QA_BIN#:*}/$2 ] ; then
        sendText="${sendText}\n${2%.x}.c|cpp not found in ${QA_SRC}/src."
        sendText="${sendText} No compilation."
        return 1
      fi

      return 0  # ok
    fi

    std_out 'qaConfiguration:tryExist() we never shall arrive here'
    std_out flush
    exit 1
  fi
}

tr_option()
{
  local phrase="${!1}"

  local sz i
  local sz=${#phrase}
  for((i=0 ; i < sz ; ++i )) ; do
    test "${phrase:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    phrase=$( echo "${phrase/% /}" | tr "[:lower:]" "[:upper:]" )
  else
    local tmp0="${phrase:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    phrase="${tmp0}""${phrase:i}"
  fi

  eval ${1}=\${phrase}
  return
}

unsetKWL()
{
  local key
  item="$*"

  key=$( echo "${item}" | tr "[:lower:]" "[:upper:]" )

  # was key already defined?
  local i
  for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
     if [ "${keyWordList[i]}" = "$key" ] ; then

      # plain assignments require to unset before reassignments
      eval unset $key
      unset keyWordList[$i]
      break
    fi
  done

  return
}


##main()
##{

# ############### main ###############
umask 002

# called by qa-DKRZ

# very specific: convert -E_SELECT or -E_LOCK into -S or -L respectively.
# Also, accept -E_SELECT param or -E_LOCK param, i.e. separated by a space
for(( i=1 ; i <= $# ; ++i )) ; do
  item=${!i}
  tr_option item

  arg=

  if [ ${item:0:9} = '-E_SELECT' -o ${item:0:7} = '-E_LOCK' ] ; then
    j=$((i+1))
    if [ ${item#*=} != ${item} ] ; then
       arg="-${item:3:1} ${item#*=}"  # prefixed by -S or -L followed by arg
    elif [ ${!j:0:1} != '-' ] ; then
       arg="-${item:3:1} ${!j}"
       j=$((j+1))
    fi
  fi

  if [ ${#arg} -gt 0 ] ; then
     set -- ${*:1:$((i-1))} ${arg} ${*:j}
     arg=
  fi
done

# stage 0: scan for configuration files etc.
while getopts :c:d:D:e:E:f:hmP:p:QqL:S:s:T:Vx-: option
do
  UOPTARG=${OPTARG}
  tr_option UOPTARG

  case $option in
    c)  qaConf[${#qaConf[*]}]=${OPTARG}
        test ! -f ${OPTARG} && noSuchFile=( ${noSuchFile[*]} ${OPTARG} )
        ;;
    e|E)  if [ ${UOPTARG:0:8} = '_DEBUG_C' ] ; then
          set -x
        elif [ ${UOPTARG:0:9} = '_PROJECT=' ] ; then
          setKWL ${OPTARG:1}
        elif [ ${UOPTARG:0:11} = '_PROJECT_AS=' ] ; then
          setKWL ${UOPTARG:1}
        fi
        ;;
    f)  qaConf[${#qaConf[*]}]=${OPTARG}
        test ! -f ${OPTARG} && noSuchFile=( ${noSuchFile[*]} ${OPTARG} )
        ;;
    h)  isHelp=t ;;
    p)  setKWL QA_SRC=$OPTARG ;;
    P)  setKWL PROJECT=$OPTARG ;;
    T)  TTY=${OPTARG} ;;
    x)  set -x ;;
    -)  test "$OPTARG" = "help" && isHelp=t && continue
        test "${UOPTARG%=*}" = "PROJECT_AS" && setKWL PROJECT_AS=${OPTARG#*=} && continue
        ;;
   \?)  ;;
  esac
done

if [ ${isHelp:-f} = t ] ; then
  descript
  exit 1
fi

if [ ${#noSuchFile[*]} -gt 0 ] ; then
  for nsf in ${noSuchFile[*]} ; do
    test -c "$TTY" && echo "${nsf}: no such file" > $TTY
  done

  exit 1
fi

# may be overwritten by configuration file or command-line
setDefaults

# get valid configuration files corresponding to the priority list
getConfPriority

# proceed from low to high priority
for(( i=${#qaConf[*]}-1 ; i > -1 ; --i )) ; do
  parseConfigurationFile ${qaConf[i]}
done

test ${#PROJECT} -eq 0 && setKWL PROJECT=NONE
test ${#PROJECT_AS} -eq 0 && setKWL PROJECT_AS=${PROJECT}

# command-line overwrites configuration file assignments
comLine=( $* ) # for e-mail and initSession

test ${#QA_CONFS} -gt 0 && setKWL QA_CONF=${QA_CONFS}

# Note: option -T is used internally, when the qa-DKRZ
#       executes the qaConfiguration script.
set -f

# stage1
unset OPTIND
while getopts c:d:D:e:E:f:hmP:p:QqL:S:s:T:x-: option
do
  UOPTARG=$OPTARG
  tr_option UOPTARG

  case $option in
    c)  # already done
        ;;
    d|D) # disable previously enabled options
         unsetKWL ${OPTARG} ;;
    e|E) # Enable features or set parameters
        test ${UOPTARG:0:8} != '_DEBUG_C' && parseOPTARG ${UOPTARG/=/ }
        ;;
    f)  # already done
        ;;
    h)  # already done
        exit 1  ;;
    L)  sel_lock L ${OPTARG}
        set +f
        ;;
    m)  setKWL SIMPLE_STATUS_LINE=t ;;
    p)  # already done
        ;;
    P)
        setKWL PROJECT=$UOPTARG ;;
    Q)  setKWL NO_STATUS=t ;;
    q)  setKWL QUIET=t ;;
    S)  sel_args=( ${OPTARG//,/} )
        ;;
    s)  setKWL SESSION_DATE=${OPTARG} ;;
    T)  # already caught
        ;;
    x)  setKWL DEBUG_MANAGER=t
        setKWL DEBUG_EXECUTOR=t
        ;;  # already done for this script
    -)  test "$OPTARG" = "help" && descript && exit 1

        if [ "${UOPTARG%=*}" = "AUTO-UP" ] ; then
          if [ "${OPTARG#*=}" = disable -o "${OPTARG#*=}" = f -o "${OPTARG#*=}" = d ]
          then
            if grep -i -q auto-up ${QA_SRC}/.conf &> /dev/null; then
              setKWL AUTO_UPDATE=f
            fi
          elif ! grep -i -q auto-up ${QA_SRC}/.conf &> /dev/null; then
                setKWL AUTO_UPDATE=t
          fi
          continue
        fi

        test "${OPTARG:0:4}" = fpid && setKWL FORMER_PID=$OPTARG && continue
        test "$OPTARG" = "help" && continue # done before
        test "${UOPTARG%=*}" = "PROJECT_AS" && continue # done before

        if [ "${OPTARG:0:2}" = pb ] ; then
          if [ ${OPTARG} = ${OPTARG#*=} ] ; then
            setKWL PROGRESS_BAR=t
          else
            setKWL PROGRESS_BAR=${OPTARG#*=}  # file to write to
          fi

          continue
        fi

        test "${UOPTARG:0:4}" = POST && setKWL POST_PROC=t && continue

        echo "invalid option --${OPTARG}" > /dev/stderr
        descript
        exit 1
        ;;
   \?)  descript
        exit 1;;
  esac
done

shift $(( $OPTIND - 1 ))
test $# -gt 0 && sl_args=( ${sl_args[*]} ${*//,/ } )

set +f

# for downward compatibility
test ${#QA_DATA_ROOT} -gt 0 && setKWL QA_RESULTS=${QA_DATA_ROOT}
test ${#DATA_ROOT_FS} -gt 0 && setKWL PROJECT_DATA=${DATA_ROOT_FS}

# almost everything is done here
loadSetting

# Return the configuration and selected experiments
# and parameters to the calling director.

set -f

# selection on the command-line cancels any selection in config-files
if [ ${#sl_args[*]} -gt 0 ] ; then
  pathList=
  varList=

  for(( i=0 ; i < ${#sl_args[*]} ; ++i )) ; do
    if [ ${sl_args[i]:0:1} = '/' ] ; then
      # rule: if absolute path on cmd-line, then cancel previous
      unsetKWL PROJECT_DATA
    fi

    sel_lock S ${sl_args[i]}
  done
fi

# NOTE: arrays of experiments and parameters are provided
#       by the file LOGIDR/cache_request_SESSION.txt

# Synchronise QA_EXEC_HOSTS and NUM_EXEC_THREADS
if [ ${#NUM_EXEC_THREADS[*]} -lt ${#QA_EXEC_HOSTS[*]} ] ; then
  myLastPos=$(( ${#NUM_EXEC_THREADS[*]} -1 ))
  myLastNum=${NUM_EXEC_THREADS[myLastPos]}
  for(( j=myLastPos+1 ; j < ${#QA_EXEC_HOSTS[*]} ; ++j )) ; do
    NUM_EXEC_THREADS[j]=$myLastNum
    # add key to the list
  done

  keyWordList[${#keyWordList[*]}]=NUM_EXEC_THREADS
fi

# sort and remove duplicates
# Note: echo add a blank between items
#       thus, the leading blank in the "" expression is required.
keyWordList=( $(echo -e " ${keyWordList[*]/%/\\n}" | sort -b | uniq ) )

test ${unset_PD:-f} = t && unsetKWL PROJECT_DATA

# Prepare the settings as key=val, where val could also be an array.
for key in ${keyWordList[*]} ; do
  test QA_DATA_ROOT = ${key} && continue
  test DATA_ROOT_FS = ${key} && continue
  test QA_PROJECT   = ${key} && continue

  eval val=( \${${key}[*]} )
  test ${#val} -gt 0  &&  array[${#array[*]}]=${key}=${val[*]}
done

# special treatmeant to preserve regExp
if [ ${#pathList[*]} -gt 0 ] ; then
  array[${#array[*]}]=SELECT_PATH_LIST="${pathList[*]//,/ }"
  array[${#array[*]}]=SELECT_VAR_LIST="${varList[*]//,/ }"
fi

# special treatmeant to preserve regExp
if [ ${#lockPathList[*]} -gt 0 ] ; then
  array[${#array[*]}]=LOCK_PATH_LIST="${lockPathList[*]//,/ }"
  array[${#array[*]}]=LOCK_VAR_LIST="${lockVarList[*]//,/ }"
fi

# display all assignments made
if [ ${SHOW_CONF:-f} = t ] ; then
  for(( j=0 ; j < ${#array[*]} ; ++j )) ; do
    std_out ${array[j]}
  done

  std_out flush
  test ${SHOW_EXP:-f} = f && exit 1
fi

# Submit the setting to the caller
# It is necessary to change the field separator to keep embedded arrays distinct.
IFS='%'

for(( j=0 ; j < ${#array[*]} ; ++j )) ; do
  echo -n "${array[j]}%"
done

std_out flush

##}
