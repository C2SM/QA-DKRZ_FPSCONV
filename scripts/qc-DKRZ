#! /bin/bash

# ##/*! \file qcDKRZ.h
## \brief Start script for the QC

## This script starts a Quality Control (QC) session.\n
## The script is started on the command-line with optional parameters.\n
## Example: <tt> path/QC-0.4/scripts/qcDKRZ -f file.conf [opts] </tt> \n
## The script keeps track of netCDF files scheduled for processing
## (and those which have been processed). A quality check is performed
## by an executable of the \a qc_main.cpp file within
## the script \a qcExecutable_FS which in turn was launched by
## \a qcDKRZ asynchronously parallel in the back-ground.
## User provided parameters from a configuration and/or task
## file as well as from the command-line are parsed by the
## script \a qcConfiguration.\n
##*/

##//! Apply rules for SELECTing and LOCKing of paths and files.
#
##/*! Syntax Rules of SELECT / LOCK ( [] indicates optional):\n
## <tt>SELECT [path1[, path2, ...] = ] [var1[, var2, ...]]</tt>\n
## SELECT/LOCK has a special syntax (with [] indicating optional):\n
## Note: '=' has a special meaning; mulitple assignments just add.
## Same for LOCK.

## A path is a sub-path appended to the tree given by PROJECT_DATA.
## Several SELECT and LOCK statements, respectively, are cumulative.
## There must be no assignment character '=' following key-words
## or SELECT or LOCK.
## Each variable specification is applied to all paths.\n
## Assignments may contain (and usually do) regular expressions.
## The rules of the RegExp must be those of the 'expr' command explained
## in 'man  grep'.
## This implies that each regExpr must begin from the first character
## with the caret ^ omitted. E.g. SELECT .* /historical /.* /Amon =
## Omitting path and variable defaults to all, respectively, i.e. '.*'\n
## Important: selecting one or more paths requires a '=' character behind
## the last path. Otherwise, it is taken as selection for variables.
## SELECT := starts a multiple line selection (same rules as for multiple
## line assignment).\n
## Same for LOCK. Multiple lines SELECTions may be mixed
## with such given by a single line.\n
## Note: SELECT in a config-file and via command-line option '-S arg'
## are combined; arg (without key-word SELECT) is as a single-line.\n
## Examples: \n
## SELECT path=var # specifies a single path where to look for a single ## variable \n
## SELECT p1,p2=var  #  two paths to look for a variable \n
## SELECT p1,p2=  #  two paths with every variable, equivalent to #p1,p2=.*  \n
## SELECT p1=v1,v2  #   one path with two variables \n
## SELECT var[,v2,v3]  #   looks for variables in the entire DRS tree \n
## SELECT p1=,p2=v1...  --> error,  SELECT  p1,p2=v1...  --> ok. \n
##*/

applyRules()
{
   # return 0 :: true

   local retVal
   retVal=1  # go for a file
   local f

   # Is there a race condition? Yes? Then wait.
   if [ ${#PROC_POOL} -gt 0 ] ; then
     for f in $(ls ${PROC_POOL}/experiments/* 2> /dev/null) ; do
       if expr match "$f" ".*:${1}" &> /dev/null; then
         # the filename root matched. But, is it also the right path?
         # a race condition can also happen here in the pipe-line
         local tp
         tp="$( cat $f 2> /dev/null | head -n 3 | tail -n 1)"
         if [ ${#tp} -gt 0 ] ; then
           tp=${tp#SUB_PATH=}
           test "$tp" != "${subPath}" && break  # is different
         fi

         return 0
       fi
     done
   fi

   if applySelectionRules $1 ; then
     return 0  # not selected
   fi

   if applyLockRules $1 ; then
     retVal=0  # not selected
   fi

   return $retVal
}

applyLockRules()
{
  # return 0, if locked
  # return 1, if not

  local refName pl sP
  refName=$1

  sP=${subPath}
  test ${#sP} -eq 0 && sP='/.'

  test ${#LOCK_PATH_LIST[*]} -eq 0 -a ${#LOCK_VAR_LIST[*]} -eq 0 \
      && return 1

  # any path selected?
  for(( pl=0 ;  $pl < ${#LOCK_PATH_LIST[*]} ; ++pl )) ; do
    if expr match ${sP} "${LOCK_PATH_LIST[pl]}" &> /dev/null ; then
      if expr match ${refName} "${LOCK_VAR_LIST[pl]}" &> /dev/null ; then
        return 0
      fi
    fi
  done

  return 1  # no locks found
}

applySelectionRules()
{
  # return 1, if selected
  # return 0, if not

  local refName pl sP
  refName=$1

  sP=${subPath}
  test ${#sP} -eq 0 && sP='.'

  test ${#SELECT_PATH_LIST[*]} -eq 0 -a ${#SELECT_VAR_LIST[*]} -eq 0 && return 1

  # any path selected?
  for(( pl=0 ;  $pl < ${#SELECT_PATH_LIST[*]} ; ++pl )) ; do
    if expr match ${sP} "${SELECT_PATH_LIST[pl]}" &> /dev/null ; then
      # special: only the path is to be tested
      test "$1" = PATH && return 1

      # if no variable was selected, then all variables match
      if expr match ${refName} "${SELECT_VAR_LIST[pl]}" &> /dev/null ; then
        return 1
      fi
    fi
  done

  return 0  # no selection for the current sub-path
}

bind_checksum()
{
  local fs
  fs=( ${*##*/} ) # just the filename

  local type

  # extension corresponding to the checksum method
  cs_ext=md5

  if [ "${CHECKSUM}" = t ] ; then
    type='--type=md5'
  else
    cs_ext=${CHECKSUM%sum}
    cs_ext=${cs_ext##*/}
    type="--type=${CHECKSUM}"
  fi

  if [ ${#CS_DIR} -gt 0 ] ; then
    if [ ${CS_DIR:0:1} = '/' ] ; then
      CS_TABLE="${CS_DIR}"
    else
      CS_TABLE="${QC_RESULTS}/${CS_DIR}"
    fi
  else
    test ${CS_STAND_ALONE:-f} = f && CS_TABLE="${QC_RESULTS}/cs_table"
  fi

  if [ ${CS_STAND_ALONE:-f} = t ] ; then
    if [ ${#CS_TABLE} -eq 0 ] ; then
      CS_TABLE=${QC_RESULTS}/data/${subPath}
    fi
  fi

  local email
  if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
     email="${EMAIL_TO[*]}"
     email="-m ${email// /,}"
  fi

  getExperimentName ${subPath}

  # calculate the checksum(s)
  ${QC_SRC}/scripts/checkSum -b ${QC_BIN#*:} $type \
      -q ${QC_RESULTS} ${YAML:+--yaml} ${CS_NO_HISTORY:+--no_history} \
      ${CS_STAND_ALONE:+-w}  $email ${CS_TABLE:+-t} ${CS_TABLE} \
      ${CURR_EXP_NAME:+-x} ${CURR_EXP_NAME} \
      -P ${PROJECT_DATA} -S ${subPath} ${fs[*]}

  return $?
}

callPing()
{
  # no ping necessary
  test "$1" == "$HOSTNAME" && return 0

  if [ ${PING_ENABLED:-f} = t ] ; then
    if $myPing -c 1 $1 &> /dev/null ; then
      return 0
    fi
  fi

  return 1
}

##//! User provided configuration setting from file and command-line.

##/*!
## Detailed comments on configuration parameters are given in files
## \a path/QC-0.4/tables/projects/*_qc.conf
##*/

callQcConfig()
{
# setting defaults, parsing of the configuration file and command-line  is left to the
# qcConfiguration, which returns key-word assignments and lists.
# NOTE: arrays of experiments and parameters are provided by the file
# LOGIDR/cache_request.txt.

  local items i key

# necessary for returning embedded arrays from qcConfiguration
  OLD_IFS="$IFS"
  IFS="%"

  setF -f

# calling the configuration script
  if ! items=( $( $QC_SRC/scripts/$QC_CONFIGURATOR -p $QC_SRC $* ) ) ; then
    # not necessarily an error; also SHOW_CONF, CHECK_TOOLS and
    # no argument for displaying help will return exit 1
    exit
  fi

  IFS="$OLD_IFS"

  if [ ${#items[*]} -eq 0 ] ; then
    std_out flush "nothing configured, nothing to do.\nabnormal termination."
    lastStatus=1  # exit status of this script
    exit
  fi

  #enable settings for the qcDKRZ
  for(( i=0 ; i < ${#items[*]} ; ++i )) ; do
    key="${items[i]%%=*}"

    # very specific: map PROJECT_DATA --> PROJECT_DATAV
    test ${key} = PROJECT_DATA && key=${key}V

    # any SHOW_... directive?
    test ${key:0:4} = SHOW && isShow=t

    if [ "${items[i]}" = "${items[i]// /}" ] ; then
      eval ${key}="${items[i]#*=}"
    else
      eval ${key}=\("${items[i]#*=}"\)
    fi

    setKWL ${key}

    # check for key-word POST in any assignment
    if expr match "${items[i]#*=}" 'POST' &> /dev/null ; then
      isPost=t
    fi
  done

# invoked by option -E_DEBUG_MANAGER
  if [ ${#DEBUG_MANAGER} -gt 1 ] ; then
    exec 7<&2
    dbgCycle=0
    exec 2>${DEBUG_MANAGER}.$dbgCycle
    set -x
  elif [ ${DEBUG_MANAGER:-f} = t ] ; then
    set -x
  fi

  if [ ${#DEBUG_X} -gt 0 ] ; then
    # debug-mode for external scripts
    if [ ${DEBUG_X} = t ] ; then
      DEBUG_X=--debug
    else
      DEBUG_X="--debug=${DEBUG_X}"
    fi
  fi

  test ${RESUME_SESSION:-f} = t && log_sessMessage "session resumed."

  # always set
  PATH=${QC_BIN#*:}:$PATH

  # add relevant compilation paths to LD_LIBRARY_PATH
  setLD_LIB_PATH

  #save for NIGHT_SHIFT operation
  save_QC_EXEC_HOSTS=( ${QC_EXEC_HOSTS[*]} )
  save_NUM_EXEC_THREADS=( ${NUM_EXEC_THREADS[*]} )

  QC_DATADIR=${QC_RESULTS}/data

  setF +f

  if [ ${#SHOW_CLEAR} -gt 0 -a "${SHOW_CLEAR}" != t ] ; then
    # SHOW_CLEAR may contain same assignment than CLEAR itself
    test ${#CLEAR} -eq 0 && CLEAR=${SHOW_CLEAR}
    SHOW_CLEAR=t
  fi

  return
}

##//! Launcher of the executable of QC main-program qc_main.cpp

##/*!
## The script runs in the back-round. Hence, multiple instances may
## be proccessed in parallel. The script processes also annotations.
##*/

callQcExecutor()
{
  local nextFile
  local nextPeriod

  local i args item keyW w

  # this is the ultimative test (and unnecessary)
  test $# -eq 0 && return

  local EXP_NAME=$CURR_EXP_NAME

  nextFile=$1
  nextPeriod=$( getDateRange $nextFile )

  # Create semaphore file.
  local str
  str=${nextFile%.nc}

  local DT
  DT=$( date +'%F_%T' )

  # with next identification number
  procFile=$PROC_POOL/"${nextHost%%.*}:${str}_$((++EX_ID)).txt"

  local text
  text="NEXT_FILE=${nextFile}"

  test ${#nextPeriod} -gt 0 \
      && text="${text}\nNEXT_PERIOD=${nextPeriod}"
  test ${#subPath} -gt 0  \
      && text="${text}\nSUB_PATH=${subPath}"

  # 'export' the terminal device
  test -c "$TTY" && text="${text}\nTTY=${TTY}"

#  log_sessMessage \
#    "${nextHost%%.*}: ${subPath}/${nextFile}: start"

  local k
  k=0 # index for optional keyW items

  # key-words with assignment for the executor
  keyW=( ${keyW[*]} \
          ADD_PROG_ARG \
          APPLY_MAXIMUM_DATE_RANGE \
          ARITHMETIC_MEAN \
          CASE_INSENSITIVE_VARIABLE_NAME \
          CF \
          CF_CHECK_LIST \
          CF_STANDARD_NAMES \
          CHECK_LIST \
          CHECK_MODE \
          CHECKSUM \
          CS_STAND_ALONE \
          CS_TABLE \
          DATA_IN_PRODUCTION \
          DISABLE_INF_NAN \
          DISABLE_SLEEP \
          DISABLE_TIME_BOUNDS_CHECK \
          EMAIL_TO \
          EXLUDE_FLAG_FROM_EMAILING \
          EXCLUDE_ATTRIBUTE \
          EXCLUDE_VARIABLE \
          EXP_LOGDIR \
          EXP_NAME \
          FD_BARS \
          FD_EXPLICIT_PROPS \
          FD_PLAIN \
          FD_PROPERTY_PATH \
          FD_TIME_PART \
          FILE_SEQUENCE \
          FOLLOW_CF_RECOMMENDATIONS \
          FREQ_DIST \
          HAS_PARENT \
          HLEVD \
          HLEVD_DELETE_FILE \
          HLEVD_DETREND \
          HLEVD_KEEP_THRESHOLD_FILE \
          HLEVD_THRESHOLD \
          IMPORTED_PATH \
          IGNORE_REFERENCE_DATE \
          IGNORE_REF_DATE_ACROSS_EXP \
          LOG_CPU_TIME \
          MAIL \
          NEVER_BREAK_SESSION \
          NEXT_RECORDS \
          NICE \
          NIGHT_SHIFT \
          NON_REGULAR_TIME_STEP \
          NOTE \
          NOTE_ALWAYS \
          NOTE_LEVEL_LIMIT \
          OUTLIER_TEST \
          PARENT_CHILD_CHECK_ONLY \
          PARENT_EXP_ID \
          PARENT_EXP_RIP \
          PARENT_PATH_PREFIX \
          PARENT_ENSEMBLE_MEMBER \
          PARENT_VERSION \
          PING_ENABLED \
          POST_PROC \
          PRINT_GREP_MARK \
          PROC_POOL \
          PROJECT \
          PROJECT_AS \
          PROJECT_DATA \
          PROJECT_TABLE \
          QC \
          QC_MANAGER_HOST \
          QC_NCFILE_FLAGS \
          QC_RESULTS \
          QC_SRC \
          REATTEMPT_LIMIT \
          REPLICATED_RECORD \
          REQUIREMENTS_TABLE \
          SESSION \
          SESSION_LOGDIR \
          SHOW_CALL \
          SLEEP_TIME \
          STANDARD_TABLE \
          TABLE_GCM_NAME \
          TABLE_PATH \
          TABLE_REQUIREMENTS \
          TABLE_RCM_NAME \
          TIME_LIMIT \
          TIME_TABLE \
          TOTAL_PERIOD \
          TRACKING_ID_ONLY \
          USE_STRICT \
          WORK_AT_LOW_LOAD \
          )
  i=0

  test ${#DEBUG_MANAGER} -eq 0 && pauseX

  #use keywords and corresponding values to construct file in pool

  for item in ${keyW[*]} ; do
     eval w="\${${item}[*]}"
     test -z "$w" && continue

     text="${text}\n${item}=${w}"
  done
  test ${#DEBUG_MANAGER} -eq 0 && pauseX

  # call qcExecutor with arg-list: format: name=value
  # Note: if execution takes place on a host different than
  # the one where qcDKRZ runs, then all paths must be
  # accessible.

  local prevPID=$currPID
  local ca
  test ${FLOW_TRACE:-f} = t && ca="FLOW_TRACE=t "
  test ${DEBUG_EXECUTOR:-f} = t && ca="${ca} DEBUG_EXECUTOR=t "

  if [ "$nextHost" = "${HOSTNAME:0:${#nextHost}}" ] ; then
    # use the first item of the QC_BIN array

    text="${text}\nIMPORTED_PATH=${QC_BIN#*:}"
    echo -e "$text" > $procFile

    $QC_SRC/scripts/$QC_EXECUTOR "${ca}QC_SRC=${QC_SRC} PROC_POOL=$PROC_POOL PROC_FILE=${procFile##*/} PAR_PID=${rootPID}" &
  else
    local bin
    for bin in ${QC_BIN[*]} ; do
      if [ "${nextHost}" = ${bin%:*} ] ; then
        text="${text}\nIMPORTED_PATH=${bin#*:}"
        break
      fi
    done


    echo -e "$text" > $procFile

    if callPing ; then
      ssh $nextHost $QC_SRC/scripts/$QC_EXECUTOR "PROC_POOL=$PROC_POOL PROC_FILE=${procFile##*/} PAR_PID=${rootPID} &" &> /dev/null
    fi
  fi

  currPID=$!

  return
}

##//! Process scheduler
##/*!
## A frame function with life-span over the entire session.
## Keeps track of paths, files and running processes.
##*/

check()
{
  # The sequence of sub-temporal files is stored in a stack, which
  # is processed on after another. This is different to the
  # horizontal approach, when, after having processed the next
  # sub-temp file  of a given variable, the next variable is touched,
  # also only for the very next sub-temporal file.
  # There are a number of stacks corresponding to the number of hosts and
  # threads prescribed in the configuration.
  nFcurr=0
  nFmax=0
  currPID=0
  countActivePipes=0
  waitCounter=0

  local line subPath
  declare -a line

  # save stdin
  exec 9<&0

  # connect file to input;
  # keep it open for reading while more paths may be appended.
  exec 0< ${pathListFile}

  while : ; do

    while : ; do
      # read next sub path from pathListFile, get all variables
      # contained within after having looked for locks.

#trace \
      getNextSubPath

      for(( ix=0 ; ix < ${#fBase[*]} ; ++ix )) ; do

        if \
#trace \
          operatePipes ${subPath} ; then break 3 ; fi

#trace \
        checkClosedMessages
      done
    done

  done

  # restore stdin and free #9
  exec 0<&9 9<&-

  # this is for a wipe out run
  test ${isCLEAR_ONLY:-f} = t && exit

  # don't remove everything done so far in the next looping
  test ${#CLEAR} -gt 0 && unset CLEAR

  # Just wait, give the qcExecutor(s) a chance to finish.
  # This does not work for qcExecutor instances launched by ssh.
#trace \
  wait_fnct

  return
}

##//! Finialisation of annotations of each check.

##/*!
## Communication between \a qcDKRZ and \ qcExecutor is done
## by temporary files. After closing an qcExecutor instance, this
## function finalises annotation processes.
##*/

checkClosedMessages()
{
  # qcExecutors have added locked or closed files for finished runs
  local expName f fs ffs ff g

  fs=( $( ls $PROC_POOL/*.closed 2> /dev/null ) )

  for f in ${fs} ; do
    expName="$( grep EXP_NAME= $f )"
    expName=${expName#EXP_NAME=}

    # experiment log-file
    ffs=( $( ls $PROC_POOL/experiments/$expName.*.log 2> /dev/null ) )
    for ff in ${ffs[*]} ; do
      if \
         tryCom get_status \
         test -s $ff  ; then
         tryCom \
         cat "$ff" >> $EXP_LOGDIR/${expName}.log
         tryCom \
         \rm -f "$ff"

         isAnythingDone=t
      fi
    done

    # logs of qC.x execution time
    if [ ${LOG_CPU_TIME:-f} = t ] ; then
      ffs=( $( ls $PROC_POOL/experiments/$expName.*.time 2> /dev/null ) )
      local line items
      declare -a items
      for ff in ${ffs[*]} ; do
        if \
           tryCom get_status \
           test -s $ff
        then
           # remove obsolete entries, thus we have to read one by one
           while read line ; do
             items=( ${line} )
             if grep -q ${items[3]} $EXP_LOGDIR/${expName}.time &> /dev/null ] ; then
                sed -i "/${items[3]}/d" $EXP_LOGDIR/${expName}.time
             fi

             echo "$line" >> $EXP_LOGDIR/${expName}.time
           done < $ff
           \rm -f "$ff"
        fi
      done
    fi

    # session log-file
    ffs=( $( ls $PROC_POOL/session/$SESSION.*.log 2> /dev/null ) )
    for ff in ${ffs[*]} ; do
      if \
         tryCom get_status \
         test -s $ff  ; then
         cat $ff >> $SESSION_LOGDIR/session.log
         \rm -f "$ff"
      fi
    done

    \rm  $f
  done

  return
}

##//! Look for lock-files preventing processing of a file.

##/*!
## Certain level of annotation cause the creation of a lock-file,
## which inhibits further processing of a given variable.
##*/

checkLockFile()
{
   # return 0 :: true
   # $1 == PATH: check only paths

   # any variable locked?
   ls ${QC_RESULTS}/data/${subPath}/*_lock_${1}${2}.txt &> /dev/null
   local x_lock=$?

   if [ ${LOCK_NOTES:-f} = t ] ; then
     ls ${QC_RESULTS}/data/${subPath}/*_note_${1}${2}.txt &> /dev/null
     local x_note=$?
   fi

   if [ ${x_note:-1} -eq 0 -o ${x_lock:-1} -eq 0 ] ; then
     if [ ${IGNORE_LOCK_FILES:-f} = f ] ; then
       return 0 # option says: don't ignore a blocking file
     else
       # option says: ignore blocking file
       if ! ls ${QC_RESULTS}/data/${subPath}/qc_${1}${2}.nc &> /dev/null
       then
         # no qc-result.nc file; block always
         return 0
       fi
     fi
   fi

   return 1
}

checkValidNcFile()
{
  # Probe corrupt file due to a crash.
  # Return 0, i.e. true, if there is no solution
  local fs p v

  p=$1 # path
  v=$2 # filename name

  tryCom \
  test -d $p

  fs=$( ls $p/z_qc_${v}.nc 2> /dev/null)

  # Any previous backup file available? Yes. Then a crash happened.
  # Restore backup.
  if [ ${#fs} -gt 0 ] ; then
    mv $p/z_qc_${v}.nc $p/qc_${v}.nc

    if [ -d $p/Z_fd_${v} ] ; then
      \rm -f $p/fd_${v}*.build
      if ls $p/Z_fd_${v}/* &> /dev/null ; then
        cp $p/Z_fd_${v}/* $p &> /dev/null
      fi
      rmdir $p/Z_fd_${v}/* &> /dev/null
    fi

    return 1
  fi

  # A crash happened while the file was open the first time.
  # No backup is available.
  fs=$( ls $p/qc_${v}.nc 2> /dev/null)

  if [ ${#fs} -eq 0 ] ; then
    return 1 # no previous check at all
  fi

  if ! testValidNC.x $fs ; then
    # clear a corrupt file
    \rm -f "$fs"
  fi

  return 1
}

##//! Clear lock-files

##/*!
## Lock-files from a previous session are removed.
##*/

clear()
{
  local f fs t tx ts
  local isFL=f
  local isResume=f
  local isMessage=f

  isClear=t  # global scope

  # arbitrary order of arguments
  for f in ${CLEAR//,/ } ; do
    test ${CLEAR} = t && break  # unconditional

    isClear=f

    if [ "$f" = follow_links ] ; then
       test ${DEREFERENCE_SYM_LINKS:-f} = f && isFL=t
       isClear=t
    elif [ "${f:0:3}" = res ] ; then
       isResume=t
       isClear=t
    elif [ "$f" = only ] ; then
       isCLEAR_ONLY=t
       isClear=t
    elif [ "${f:0:4}" = lock ] ; then
       # locked  files
       if ls ${QC_RESULTS}/data/${subPath}/qc_lock_${fBase[ix]}* &> /dev/null ; then
         isClear=t
       fi
    elif [ "${f:0:4}" = note ] ; then
       # if any note
       if ls ${QC_RESULTS}/data/${subPath}/qc_note*_${fBase[ix]}* &> /dev/null ; then
         isClear=t
       fi
    elif [ "${f:0:4}" = mark ] ; then
       # only pass those that are locked; redo erroneous cases
       if ls ${QC_RESULTS}/data/${subPath}/clear.mark &> /dev/null \
            && ls ${QC_RESULTS}/data/${subPath}/${fBase[ix]}.clear &> /dev/null ; then
         isClear=t
       fi
    elif [ ${f%=*} = level ] ; then
       f="^${f#*=}-"

       # clear specified level
       if grep -q $f ${QC_RESULTS}/data/${subPath}/qc_note_${fBase[ix]}* &> /dev/null
       then
         isClear=t
       elif grep -q $f ${QC_RESULTS}/data/${subPath}/qc_lock_${fBase[ix]}* &> /dev/null
       then
         isClear=t
       fi
    elif [ ${f} != ${f/=/} -a ${f%=*} = tag ] ; then
       # e.g. L1-${tag}: where tag=CF_12 would match CF_12, CF_12x etc.
       f="^[[:alnum:]]*-*${f#*=}.*: "

       # clear specified level and/or flag
       if grep -q $f ${QC_RESULTS}/data/${subPath}/qc_note_${fBase[ix]}* &> /dev/null
       then
         isClear=t
       elif grep -q $f ${QC_RESULTS}/data/${subPath}/qc_lock_${fBase[ix]}* &> /dev/null
       then
         isClear=t
       fi
    elif [ ${f} != ${f/=/} -a ${f%=*} = var ] ; then
       # CLEAR=var=name
       if expr match ${fBase[ix]} "${f}" &> /dev/null ; then
         if ls ${QC_RESULTS}/data/${subPath}/*_${fBase[ix]}* &> /dev/null
         then
           isClear=t
         fi
       fi
    else
       # CLEAR=varName
       f=${f%_} # this would allow for a variable 't_', which can be confused
                # without '_' with 't' meaning enabled.

       if expr match ${fBase[ix]} "${f}" &> /dev/null ; then
         if ls ${QC_RESULTS}/data/${subPath}/*_${fBase[ix]}* &> /dev/null
         then
           isClear=t
         fi
       fi
    fi

    test ${isClear} = t && break
  done

  if [ ${isClear} = t ] ; then
    if [ "${isFL}" = t ] ; then
      fs=( $( \
           tryCom \
           ls ${QC_RESULTS}/data/${subPath}/*_${fBase[ix]}* 2> /dev/null ) )

      for f in ${fs[*]} ; do
        if [ -h $f ] ; then
           deref_link target ${f}
           target=${target%/*}

           ts=( $( \
                tryCom \
                ls ${target}/*_${fBase[ix]}* 2> /dev/null  ) )

           for t in ${ts[*]} ; do
             if [ $isResume = t ] ; then
                tx=${t##*/}
                test "${tx:0:7}" != 'qc_lock' && continue
             fi

             if [ ${SHOW_CLEAR:-f} = t ] ; then
               std_out ttyOnly "SUB-PATH=${subPath}"
               std_out ttyOnly "\t${t}\tLINK\n"
             else
               # note: '\rm -f any' returns always 'true'
               if \
                  tryCom get_status \
                  \rm $t  ; then
                  isMessage=t
               fi
             fi
           done

           break
        fi
      done

      if [ $isMessage = t ]  ; then
        if [ $isResume = t ] ; then
          # only write a log message if targets of sym links were removed
          headerText="File:\t\tqc_${fBase[ix]}\n\
QC result path: ${target}\nResume: removed qc-break file by following links."
        else
          headerText="File:\t\tqc_${fBase[ix]}\n\
QC result path: ${target}\nRemoved QC results by following links."
        fi

        log_sessMessage "$headerText"
        isMessage=f
      fi
    fi

    # clearing section for regular files
    local isClearTables=f
    local isRm=f

    fs=( $( \
            tryCom get_status \
            ls ${QC_RESULTS}/data/${subPath}/*_${fBase[ix]}* 2> /dev/null ) )

    test -e ${QC_RESULTS}/data/${subPath}/core && fs[${#fs[*]}]=core

    for f in ${fs[*]} ; do
      if [ $isResume = t ] ; then
        tx=${f##*/}
        if [ "${tx:0:7}" = 'qc_lock' -o "${tx}" = 'core' ] ; then
          fs=($f)
          isRm=t
          break
        fi
      else
        # remove all

        isRm=t
        break
      fi
    done

    if [ ${isRm} = t ] ; then
       if [ ${SHOW_CLEAR:-f} = t ] ; then
         std_out ttyOnly "SUB-PATH=${subPath}"
         std_out ttyOnly "\t${fBase[ix]}\n"
       else
         # remove selected
         tryCom \
         \rm -f "${fs[*]}"
         isMessage=t
       fi
    fi

    # also delete table entries
    if [ $isClearTables = t ] ; then
      local prg
      prg=${QC_SRC}/scripts/xtractNotes_from_log

      test ${#prg} -gt 0 && \
        /bin/bash ${prg} -Q -r ${fBase[ix]} $EXP_LOGDIR/$CURR_EXP_NAME.log
    fi

    if [ "$isMessage" != f ] ; then
      local note
      if [ ${isResume} != f ] ; then
         note="Resume: removed only qc-lock file."
      elif [ ${#target} -gt 0 ] ; then
         note="Removed symbolic links."
      else
         note="Cleared QC results."
      fi

      # only write a log message if anything was removed
      headerText="File:\t\tqc_${fBase[ix]}\nPath: \t\t$PROJECT_DATA\n\
QC result path: $QC_RESULTS/data\nDRS tree:\t${subPath}\n${note}"

      log_sessMessage "$headerText"
    fi
  fi

  test ${isCLEAR_ONLY:-f} = t && return 0  # no qc
  test ${SHOW_CLEAR:-f}   = t && return 0  # no qc

  return 1
}

copyPreamble()
{
  local i zsTxt

# if [ -e $EXP_LOGDIR/${CURR_EXP_NAME}.log ] ; then
#    # a new qc svn revision number?
#    local rev_0 rev_1

#    # i) grep revision num save in
#    rev_0=( $(grep 'qc_svn_revision' $EXP_LOGDIR/${CURR_EXP_NAME}.log 2> /dev/null \
#         | awk -F: '{print $2}') )

#    if [ ${#rev_0[*]} -eq 0 ] ; then
#      rev_0=0
#    else
#      rev_0=${rev_0[$(( ${#rev_0[*]} - 1 ))]}
#    fi

#    # ii) svn revision number saved in .conf
#     getRevNum rev_1

#    # is it newer
#    if [ ${rev_0[0]} -lt ${rev_1} ] ; then
#      if [ ${#sTxt[*]} -gt 0 ] ; then
#        for(( i=0 ; i < ${#sTxt[*]} ; ++i )) ; do
#          zsTxt[i]="${sTxt[i]}"
#        done
#        unset sTxt
#      fi

#      sTxt[0]="3qc_svn_revision: ${rev_1}"
#      log
#    fi
# else
#    if [ ${isShow:-f} = f ] ; then
       cp ${SESSION_LOGDIR}/session.prmbl $EXP_LOGDIR/${CURR_EXP_NAME}.log

#       local rev_1
#       getRevNum rev_1

#      if [ ${#sTxt[*]} -gt 0 ] ; then
#        for(( i=0 ; i < ${#sTxt[*]} ; ++i )) ; do
#          zsTxt[i]="${sTxt[i]}"
#        done
#        unset sTxt
#      fi

#      sTxt[0]="3qc_svn_revision: ${rev_1}"
#      log
#    fi
# fi

# if [ ${#zsTxt[*]} -gt 0 ] ; then
#   for(( i=0 ; i < ${#zsTxt[*]} ; ++i )) ; do
#     sTxt[i]="${zsTxt[i]}"
#   done
# fi

  return
}

displayStatusLine()
{
  local pbForStatus

  if [ ${progressTotalFileNum:-0} -gt 0 -a ${#progressFileNum} -gt 0 ] ; then
    pbForStatus=" (${progressFileNum}/${progressTotalFileNum})"

    local perc=$( echo "${progressFileNum} / ${progressTotalFileNum} * 100" | bc -l)
    # use if-construct, because this only works on AIX
    local is=$( echo "if ( ${perc} >= ${progressNext} ) 1" | bc -l )
    if [ ${is:-0} -eq 1 ] ; then
      # get next step
      is=$( echo "$perc / $progressStep" | bc -l )
      #discard decimal
      local i
      for(( i=0 ; i < ${#is} ; ++i )) ; do
         test ${is:i:1} = '.' && break
      done
      progressNext=$( echo "${is:0:i} * $progressStep +$progressStep" | bc -l)

      if [ ${#PROGRESS_BAR} -gt 0 ] ; then
        eval echo "${progressFileNum} ${progressTotalFileNum}" ${progressFile}
      fi
    fi
  fi

  # no status line
  test ${SIMPLE_STATUS_LINE:-f} = f && return

  local num=$1
  shift
  local line="$*"

  local blank='          '
  local rpts=$(( repeats + 1 ))
  for(( l=0 ; l < rpts ; ++l )) ; do
    blank=${blank}'          '
  done
  std_out ttyOnly "\r${blank}\r"

  test ${num} -eq 0 && return

  std_out ttyOnly "${line} $pbForStatus"
  rp_num=$(( ${num} +15 ))
  repeats=$(( rp_num / 10 ))

  return
}

deref_link()
{
  # this is a robust version to dereference links, indepent on
  # the number of items given as output by 'ls -l'

  # $1: variable name to store the dereferenced file name
  # $2: the link

  local arr ipos
  arr=( $( \
           tryCom \
           ls -l $2 ) )

  for(( ipos=${#arr[*]}-1 ;ipos > -1 ; --ipos )) ; do
     test "${arr[ipos]}" = '->' && break
  done

  eval ${1}=${arr[$((ipos+1))]}

  return
}

executorRequestedExit()
{
  std_out flush "An executor instance requested EMERGENCY_STOP\nPlease, look for the reason in the session log-file."

  finally
  return
}

##//! Terminate current session

finally()
{
  test ${ONLY_SUMMARY:-f} = f && displayStatusLine 0

  wait_fnct  # give background processes a chance to finish;
             # locked processes are killed after a longer while

  if [ ${isTERM:-f} = t ] ; then
     # clear current results
     \rm -rf $PROC_POOL/*
  fi

  # release file with pid, if the session finished
  # rm filename with appended pid
  tryCom \
  \rm -f $QC_RESULTS/session_logs/PID/pid.$rootPID

  # directory containing files with PIDs of current qcDKRZ runs.
  rmdir $SESSION_LOG/PID &> /dev/null # only if empty

  test ${FLOW_TRACE:-f} = t && tracePrint

  # Note: there could be 2 sub-dirs and files in PROC_POOL during operation.
  local f fs
  fs=( $( ls -d $PROC_POOL/* 2> /dev/null) )

  local count=0
  while [ ${#fs[*]} -gt 2 ] || ls -d $PROC_POOL/*/* 2> /dev/null ; do

    # the OS may have slow FS operations
    if [ $((count++)) -lt 5 ] ; then
      # final update of log-files
      checkClosedMessages

      sleep 0.1
      fs=( $( ls -d $PROC_POOL/* 2> /dev/null) )
      continue
    fi

    sendSubject=" PROC_POOL not cleared"
    sendText="qcDKRZ.finally: ${PROC_POOL} was not cleared."

    log_sessMessage "$sendText"
    sendEMail
    break
  done

  std_out flush

  # rm PROC_POOL
  \rmdir ${PROC_POOL}/* 2> /dev/null
  \rmdir ${PROC_POOL}   2> /dev/null

  # rm pid-saving file
  \rm -f ${SESSION_LOGDIR}/pid.$rootPID

  if [ ${isShow:-f} = f ] ; then
    if [ ${isAnythingDone:-f} = t -a ${NO_SUMMARY:-f} = f ] ; then
      taskSum
    fi
  fi

  if [ ${#DEBUG_MANAGER} -gt 1 ] ; then
    set +x
    exec 2<&7 7<&-
    test ${dbgCycle} -eq 0 && \
      tryCom \
      mv ${DEBUG_MANAGER}.${dbgCycle} ${DEBUG_MANAGER}
  fi

  # remove empty paths from the results
  rmEmptyPaths

  if [ ${isTERM:-f} = t ] ; then
    kill -INT $$ 2&> /dev/null
  else
    exit ${lastStatus:-0}
  fi
}

##//! Show selected experiment names and exit.
getAllExps()
{
  local countLines
  local line
  local supPath
  local timeCounter=0

  declare -a line

  # save stdin
  exec 9<&0

  # connect file to input;
  # keep it open for reading while more paths may be appended.
  exec 0< $pathListFile

  while : ; do  # this loop resets when a race was lost

    while read -a line ; do
      test ${line[0]} = '---EOF---' && break 2

      subPath=${line[1]}
      PROJECT_DATA=${PROJECT_DATAV[${line[0]}]}

      # generate an experiment name; CURR_EXP_NAME gets a 'return value'
      getExperimentName ${subPath}

      if [ ${SHOW_EXP:-f} = t ] ; then
        std_out ttyOnly "\r${blank}\r"
        std_out ttyOnly "EXP_NAME=${CURR_EXP_NAME}"
        std_out ttyOnly "\tPATH=${PROJECT_DATA##*/}/${subPath}\n"
      fi
    done

    if [ ${SHOW_EXP:-f} = t ] ; then
      if [ ${timeCounter} -eq 50 ] ; then
        std_out ttyOnly "\r${blank}\r"
        timeCounter=0
      fi
      test ${SIMPLE_STATUS_LINE:-f} = f && std_out ttyOnly '.'
      timeCounter=$(( timeCounter + 1 ))
      sleep 1
    fi
  done

  # restore stdin and free #9
  exec 0<&9 9<&-
}

getCF_STD_NAME()
{
  local p
  p=${QC_SRC}/tables/projects/CF

  local name=cf-standard-name-table.xml

  # a short-cut. It is not necessary to poll pcmdi each call.
  if [ ${REFRESH_CF_STANDARD:-f} = t ] ; then
    wget --tries=3 -q -N --no-use-server-timestamps \
      --directory-prefix=$p \
      http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/${name} \
      &> /dev/null
  fi

  return
}

getDateRange()
{

  # echo a date interval, or an instantaneous date none
  local f r

  test $# -eq 0 && return

  f=${1%.nc}

  # e.g. extracts both 186001-186612 and 186001-186612-clim
  r=$( expr match $f '.*_\([[:digit:]]*-[[:digit:]]*.*\)' )

  if [ ${#r} -eq 0 ] ; then
    # no 'appendix allowed'
    r=$( expr match $f '.*_\([[:digit:]]*\)' )
  fi

  test ${#r} -gt 0 && echo $r

  return
}

##//! Determine experiments to be processed during this session
##/*!
## The format of experiment names is ruled by the EXP_PATH_INDEX configuration option.
##*/

getExperimentName()
{
  # extract the name of the experiment from subPath
  # see function initExperimentName()

  # EXP_NAME was defined in initExperimentName() and will never be
  # changed again

  if [ ${#EXP_PATH_INDEX} -eq 0 ] ; then
    CURR_EXP_NAME=${EXP_NAME:-${PROJECT:-NONE}}
  else
    # decompose the path
    local pcs
    pcs=${PROJECT_DATA}/$1
    pcs=( ${pcs//\// } )

    # if the last item on the right side is a kind of version, then skip
    local sz=$((${#pcs[*]}-1))
    local c expPathIndex

    expPathIndex=( ${EXP_PATH_INDEX[*]} )

    if expr match ${pcs[sz]} 'v[[:digit:]]' &> /dev/null
    then
      # adjust indexes, because there is a trailing version_path_item
      local sz=$(( ${#expPathIndex[*]} -1 ))

      if [ ${expPathIndex[sz]} -gt 1 ] ; then
        for(( c=0 ; c < ${#expPathIndex[*]} ; ++c )) ; do
          expPathIndex[${c}]=$(( ${expPathIndex[c]} +1 ))
        done

        expPathIndex[${#expPathIndex[*]}]=1
      fi
    fi

    # check for path component 'output'
    local isOutput=f
    local N
    N=${#pcs[*]}
    for(( c=0 ; c < N ; ++c )) ; do
      if [ "${pcs[c]}" = output ] ; then
         expPathIndex=( $(( N - c )) ${expPathIndex[*]} )
         break
      fi
    done

    # compose the name
    CURR_EXP_NAME=
    for c in ${expPathIndex[*]} ; do
      if [ $c -lt $N ] ; then
        # subtract the reversed positional index from array size
        CURR_EXP_NAME=${CURR_EXP_NAME}${pcs[$(( N - c ))]}_
      else
        CURR_EXP_NAME=unknownExp
        break
      fi
    done
    CURR_EXP_NAME=${CURR_EXP_NAME%_}
  fi

  local iex
  for(( iex=0 ; iex < ${#EXP_NAMES[*]} ; ++iex )) ; do
    if [ ${EXP_NAMES[iex]} = ${CURR_EXP_NAME} ] ; then
      return
    fi
  done

  # a new entry
  EXP_NAMES[${#EXP_NAMES[*]}]=${CURR_EXP_NAME}

  copyPreamble
}

getFilenameBase()
{
  local f i j k tmp

  unset fBase

  fileNames=($(find ${PROJECT_DATA}/${subPath} -maxdepth 1 -name "*.nc"))
  test ${#fileNames[*]} -eq 0

  if [ ${IGNORE_BROKEN_LINKS:-f} = t ] ; then
    for(( j=${#fileNames[*]} - 1 ; j >= 0 ; --j )) ; do
      if [ -h ${fileNames[j]} -a ! -e ${fileNames[j]} ] ; then
        unset fileNames[$j]
      fi
    done
  fi

  fBase=( ${fileNames[*]#${PROJECT_DATA}/${subPath}/} )

  # find all available files: same root, but different time periods
  # is there any qc_*.nc ? Rather circuitous, but safe.
  # works also for names without appended date

  fBase=( ${fBase[*]%.nc} )

  # distinguish asd_range from asdf_range
  for(( i=0 ; i < ${#fBase[*]} ; ++i )) ; do
    tmp=$( getDateRange ${fBase[i]} )
    fBase[i]=${fBase[i]%_${tmp}}
  done

  # remove duplicates
  local sz
  sz=${#fBase[*]}
  for(( i=0 ; i < ${sz} ; ++i )) ; do
    test ${#fBase[i]} -eq 0 && continue

    for(( j=i+1 ; j < ${sz} ; ++j )) ; do
      test "${fBase[i]}" = "${fBase[j]}" && unset fBase[j]
    done
  done

  fBase=( ${fBase[*]} )

  return
}

##//! Get the name of a host ready for a start of the \a qcExecutor

##/*!
## All host must share the same file system. Names of hosts is
## supplied by the configuration option QC_EXEC_HOSTS. Maximum number of
## simultaneous qcExecutor instances is given by NUM_EXEC_THREADS.
##*/

getHost()
{
  # determination of a next host. The limits by
  # QC_EXEC_HOSTS and NUM_EXEC_THREADS are applied.

  # before that, however, check for closed message-files
  checkClosedMessages

  local loadShort load15min
  local currSec fileSec filePID xx

  local i j currHost currNum
  declare -a currNum

  if [ ${NIGHT_SHIFT:-f} = t ] ; then
    # only work at night time
    local dayTime
    dayTime=$(date +'%H')
    if [ $dayTime -lt 8 -o $dayTime -gt 18 ] ; then
      QC_EXEC_HOSTS=( ${save_QC_EXEC_HOSTS[*]} )
      NUM_EXEC_THREADS=( ${save_NUM_EXEC_THREADS[*]} )
    else
      QC_EXEC_HOSTS=( $HOSTNAME )
      NUM_EXEC_THREADS=( 1 )
    fi
  fi

  # preset
  for(( i=0 ; i < ${#QC_EXEC_HOSTS[*]} ; ++i )) ; do
    currNum[i]=0
  done

#  currSec=$( date +'%s' )  # works only for unix
  currSec=$( ${QC_BIN#*:}/unixTime.x )
  local f
  for f in $( ls -1 $PROC_POOL/*.lock 2> /dev/null ) ; do
    f=${f%.lock}

    # extract host name from the file
    currHost=${f%%:*}

    # check whether the process is old and if yes,
    # whether it is still alive

#    fileSec=$( fModTime.x $PROC_POOL/$f 2> /dev/null )
#    test ${#fileSec} -eq 0 && continue  # lost the race

    # only for linux
# #   fileSec=$( ls -l --time-style=+'%s' $PROC_POOL/$line \
#              2> /dev/null |  awk '{print $6}' )


    # is file older than 2 hours?
#    if [ $(( currSec - fileSec - 7200 )) -gt 0 ] ; then
#      # is there any pending pid?
#      filePID=$( expr match $line '.*:.*:\(.*\)' )
#      if [ ${#filePID} -gt 0 ] ; then
#         if [ "${currHost}" == "${HOSTNAME}" ] ; then
#           xx=$(ps hp $filePID)
#         else
#           xx=$(ssh $currHost ps hp $filePID)
#         fi

#         if [ ${#xx} -eq 0 ] ; then
           #dead
#           \rm -f $PROC_POOL/$line   # lost the race
#           continue
#         fi
#      fi
#    fi

    # Determine the host names currently in use and
    # the number of corresponding instances of executors.
    for(( i=0 ; i < ${#QC_EXEC_HOSTS[*]} ; ++i )) ; do
      if [ "${currHost}" = "${QC_EXEC_HOSTS[i]}" ] ; then
        currNum[i]=$(( ${currNum[i]} + 1 ))
        continue 2
      fi
    done
  done

  # look for a free slot
  for(( j=0 ; j < ${#QC_EXEC_HOSTS[*]} ; ++j )) ; do
    if [ ${currNum[j]} -lt ${NUM_EXEC_THREADS[j]} ] ; then
      nextHost=${QC_EXEC_HOSTS[j]}

      # only select a host, if it is reachable
#      if ping -c 1 $nextHost &> /dev/null ; then
#      if callPing $nextHost ; then
        #only select host, if load is lower some limits
#        upTime=( $(ssh $nextHost uptime) )
#        i=$(( ${#upTime[*]} - 3 ))
#        loadShort=${upTime[i++]}
#        load15min=${upTime[++i]}

#        if [ $( echo "a=0;if(${loadShort%,} < 1.5)a=1;a" | bc -l) -eq 1 -a \
#          $( echo "a=0;if(${load15min} < 1.0)a=1;a" | bc -l) -eq 1 ] ; then

          return 0
#        fi
#      fi
    fi
  done

  # return, if maximum number of executors per host is reached
  return 1
}

##//! Get a list of sub-temporal files of a given variable.

##/*!
## Variable in the sense of CMIP5(CORDEX: name and MIP tabele/frequency.
## Linked files are treated according to the configuration option
## DEREFERENCE_SYM_LINKS. Locked variables are recognised.
##*/

getNextVariable()
{
  # $1 fBase

  # return 0, if a qc-check shall not be done(, mostly because it
  #           was already done previously), then idle.
  # return 1, if the file nextFile is going to be checked.

  local ix
  local qc_fl text
  local status checksumTable

  local link_filenameBase=$1

  # the path to the candidates of files to be checked
  nextPath=${PROJECT_DATA}/${subPath}

  # get files with fBase (temporal information added)
  if [ ${QUERY_ALIEN_FILE:-f} = t ] ; then
    nV_fls=( $( find ${nextPath} -maxdepth 1 -type f -name "*" 2> /dev/null ) )
  else
    nV_fls=( $( find ${nextPath} -maxdepth 1 -name "${1}*.nc" 2> /dev/null ) )
  fi
  nV_fls=( ${nV_fls[*]#${nextPath}\/} )

  if [ ${#nV_fls[*]} -eq 0 ] ; then
    y_impact=L2
    y_caption='empty directory'
    y_tag=M1
    initLog $1

    nextFile=  # ignore, try next
    return 0
  fi

  # check for broken symbolic links
  local f l is

  for(( l=${#nV_fls[*]} - 1 ; l >= 0 ; --l )) ; do
    f=$nextPath/${nV_fls[l]}
    if [ -h $f -a ! -e $f ] ; then
      if [ ${IGNORE_BROKEN_LINKS:-f} = t ] ; then
        continue
      else
        y_impact=L2
        y_caption='broken link'
        y_tag=M2
        initLog ${nV_fls[l]}

        is=t
      fi
    fi
  done
  if [ ${is:-f} = t ] ; then
    nextFile=  # ignore, try next
    return 0
  fi

  for(( l=0 ;  l < ${#nV_fls[*]} ; ++l )) ; do
    f=$nextPath/${nV_fls[l]}
    if [ ! -s $nextPath/${nV_fls[l]} ] ; then
        local num=${#nV_fls[*]}
        progressFileNum=$(( ${progressFileNum:-0} + num ))

      if [ ${QUERY_EMPTY_FILE:-f} = t ] ; then
        y_impact=L2
        y_caption='empty data file'
        y_tag=M3
        initLog ${nV_fls[l]}
        unset nV_fls[${l}]
      fi

      is=t
    elif ! expr match ${nV_fls[l]} "${1}.*\.nc" &> /dev/null ; then
      local num=${#nV_fls[*]}
      progressFileNum=$(( ${progressFileNum:-0} + num ))

      if [ ${QUERY_ALIEN_FILE:-f} = t ] ; then
        y_impact=L2
        y_caption='invalid filename'
        y_tag=M6
        initLog ${nV_fls[l]}
        unset nV_fls[${l}]
      fi

      is=t
    fi
  done
  if [ ${is:-f} = t ] ; then
    nextFile=  # ignore, try next
    return 0
  fi

  nV_fls=( ${nV_fls[*]} )

  # check read permission on each file; this must be done prior the
  # call to syncFiles.x, because no permission would cause a
  # failed ambiguity check
  local f fp
  local is=f

  for(( f=0 ; f <  ${#nV_fls[*]} ; ++f )) ; do
    if [ ! -r $nextPath/${nV_fls[f]} ] ; then
      y_impact=L2
      y_caption='no permission to read netCDF file'
      y_tag=M4
      initLog ${nV_fls[l]}

      finally
    fi
  done

  # there is no warning, when all files of a given variable
  # are broken links.
  if [ ${IGNORE_BROKEN_LINKS:-f} = t -a ${#nV_fls[*]} -eq 0 ] ; then
    nextFile=  # ignore, try next
    return 0
  fi

  # Note: if the first attempt of creating a qc-nc file
  # was interrupted by a system crash before closing it properly,
  # then the qc-nc file is corrupt. If a crash happened at any
  # further attempt to continue writing, then there will be a
  # back-up file available. Note: return value 0 (true) would happen
  # only, if there are more than one qc-files backup files.
  # The function shall clear such.
  if checkValidNcFile ${QC_RESULTS}/data/${subPath} $1 ; then
    nextFile=  # ignore, try next
    return 0
  fi

  # container for parameter passed to syncFiles.x
  syncOpts=$syncOptsInit

  # get name of file that has to be processed next (or none)
  local isMixingRefused=t
  if [ ${SYNC_FILE_AMBIGUITY_CHECK:-f} != f ] ; then
     local sfa
     local is
     for sfa in ${SYNC_FILE_AMBIGUITY_CHECK//,/ } ; do
       if [ ${sfa} = no_mod ] ; then
         is=f
       elif [ ${sfa} = mixed ] ; then
         syncOpts="${syncOpts} -m"
         isMixingRefused=f
       fi

       test ${is:-t} = t && syncOpts="${syncOpts} -M"
     done
  fi

  # Did checksums change?
  if [ ${#CHECKSUM} -gt 0 ] ; then
    bind_checksum ${nV_fls[*]}
    status=$?

    # checksum has changed; remove qc results
    test $status -gt 1 && \rm ${QC_RESULTS}/data/${subPath}/qc_${1}.* 2> /dev/null

    if [ $status -eq 6 ] ; then
      # creation_date and/or tracking_id was kept
      nextFile=  # ignore, try next
      return 0
    fi
  fi

  qc_fl=($( ls ${QC_RESULTS}/data/${subPath}/qc_${1}.nc 2> /dev/null))

  # sync with qc_file if available
  #exception: only scan for the tracking id
  if [ ${#qc_fl} -gt 0 -a ${TRACKING_ID_ONLY:-f} = f ] ; then
    syncOpts="${syncOpts} -p ${qc_fl}"
  fi

  # any time limit specified?
  local tl
  test ${#TIME_LIMIT} -gt 0 && syncOpts="${syncOpts} -l ${TIME_LIMIT}"

  unset nextFile

  if [ ${isMixingRefused} = t -a ${IGNORE_TEMP_FILES:-f} = t ] ; then
    local tf tff tfs
    declare -a tfs
    declare -a tff

    for tf in ${nV_fls[*]} ; do
      # exclude fixed variables from ignoring
      tff=${tf#*_}
      tff=${tff%%_*}

      if [ "${tff}" != fx ] ; then
        tff=
        tff=$( getDateRange $tf )
        test ${#tff} -eq 0  && continue
      fi

      tfs[${#tfs[*]}]=$tf
    done

    nV_fls=( ${tfs[*]} )

    if [ ${#nV_fls[*]} -eq 0 ] ; then
      nextFile=  # ignore, try next
      return 0
    fi
  fi

  nextFile="$(echo ${nV_fls[*]} | ${QC_BIN#*:}/syncFiles.x \
     ${isPost:+--post} $syncOpts -P ${nextPath} )"

  status=$?

  test ${SHOW_SYNC:-f} = t && \
       std_out flush "${nextFile[*]/%/\\n}"

  local nFsSz=${#nextFile[*]}

  # up-to-date
  if [ ${status} -eq 1 ] ; then
#    if [ ${#PROGRESS_BAR} -gt 0 ] ; then
      # get number of data files for progress estimation
      # note: all files no matter whether processed or locked
      local num=${#nV_fls[*]}
      progressFileNum=$(( ${progressFileNum:-0} + num ))
#    fi

    # --post option caused to output the last filename
    if [ ${#qc_fl} -eq 0 -a ${isPost:-f} = t ] ; then
      if [ ${#qc_fl} -gt 0 ] ; then
        # check global attributes for outlier_test=done
        local att
        att=$( getNC_att.x ${qc_fl} postponed_operations )
        att=${att#*=}
        att=${att%% }
      fi

      test ${#att} -eq 0 -o ${FORCE_POST:-f} = t && return 1
    fi

    nextFile=
    return 0
  fi

  if [ $status -eq 3 ] ; then
#    if [ ${#PROGRESS_BAR} -gt 0 ] ; then
      local num=${#nV_fls[*]}
      progressFileNum=$(( ${progressFileNum:-0} + num ))
#    fi

    isAnythingDone=t

    y_impact=L2
    y_caption='syncFiles.cpp with unspecific failure'
    y_tag=M5
    y_meta_data=OMIT
    y_time_values=FAIL
    y_status=${status}

    local k
    for(( k=0 ; k < ${#nextFile[*]} ; ++k )) ; do
      y_text[${k}]="${nextFile[k]}"
    done

    initLog $1

    nextFile=  # ignore, try next
    return 0
  fi

  # a fixed variable?
  if [ $status -eq 4 ] ; then
    # already processed?
    if [ ${#qc_fl} -gt 0 ] ; then
#      if [ ${#PROGRESS_BAR} -gt 0 ] ; then
        # get number of data files for progress estimation
        # note: all files no matter whether processed or locked
        local num=${#nV_fls[*]}
        progressFileNum=$(( ${progressFileNum:-0} + num ))
#      fi

      nextFile=
      return 0
    fi

    # fixed field
  fi

  # SYNC_FILE_AMBIGUITY_CHECK failed?
  if [ $status -gt 10 ] ; then
#    if [ ${#PROGRESS_BAR} -gt 0 ] ; then
      local num=${#nV_fls[*]}
      progressFileNum=$(( ${progressFileNum:-0} + num ))
#    fi

    isAnythingDone=t

    # issue annotation
    y_impact=L2
    y_caption='syncFiles.cpp: sub-temporal file sequence ambiguities.'
    y_tag=M6
    y_meta_data=OMIT
    y_time_values=FAIL
    y_status=${status}

#    local k
#    for(( k=0 ; k < ${#nextFile[*]} ; ++k )) ; do
      y_text[${k}]="${nextFile[k]}"
#    done

    initLog $1

    nextFile= # ignore, try next
    return 0
  fi

  # expand \n
  nextFile=( ${nextFile//\\n/ } )

  # nextFile is the first sub-temporal file, i.e. candidate for
  # a parent check.
  HAS_PARENT=f
  test ${#qc_fl} -eq 0 && HAS_PARENT=t

  if [ ${DEREFERENCE_SYM_LINKS:-f} = f -a \
        -h ${PROJECT_DATA}/${subPath}/$nextFile ] ; then
    # make links for QC results, where links are in the DRS tree
    # (not for links to the outside of the DRS tree).
    testFileLink $1
    nextFile= # ignore, try next
    unset nV_fls
    return 0
  fi

  return 1
}

##//! Get sub-path to a variable scheduled next.

getNextSubPath()
{
  # subPaths from a temporary file redirected to stdin.
  local ix line

  # init progress estimation
#  if [ ${#PROGRESS_BAR} -gt 0 ] ; then
    if [ ${progressTotalFileNum:-0} -eq 0 ] ; then
      if [ "$(tail -n 1 ${pathListFile})" = '---EOF---' ] ; then
        progressTotalFileNum=0
        local fs lline
        while read -a lline ; do
          test ${lline[0]} = '---EOF---' && break
          local num=$( ls ${PROJECT_DATAV[${lline[0]}]}/${lline[1]}/*.nc \
                      | grep -c . 2> /dev/null)

          progressTotalFileNum=$(( progressTotalFileNum + num ))
        done < ${pathListFile}
      fi
    fi
#  fi

  # pathListFile was connected to stdin in check()
  while : ; do  # for trapping the end

  while read -a line ; do
    # return 1: fade out operation
    if [ ${line[0]} = '---EOF---' ] ; then
      unset fBase
      fBase=''
      subPath=''
      return
    fi

    subPath=${line[1]}
    PROJECT_DATA=${PROJECT_DATAV[${line[0]}]}

    # if read returned true, although there was currently no more entry
    test "${prevLine}" = "${subPath}" && break
    prevLine=${subPath}

    # find the root of all files, stripping of date-periods;
    # puts names to fBase
#trace \
    getFilenameBase

    for(( ix = ${#fBase[*]} - 1 ; ix > -1 ; --ix )) ; do
      if [ ${#fBase[ix]} -gt 0 ] ; then
        # apply rules, clearings, and test for qc_note files
        if \
#trace \
           testLocks ; then
           unset fBase[ix]
           local hasChanged=t
           continue
        fi
      fi
    done

    # remove empty items
    test ${hasChanged:-f} = t && fBase=(${fBase[*]})

    # found unlocked variable (constraint: SHOW_CLEAR=f)
    mkdir -p ${QC_RESULTS}/data/${subPath}

    if [ ${waitCounter} -gt 0 ] ; then
      displayStatusLine 51 ''
      waitCounter=0
    fi

    return
  done

  # for EOF case
  # a getSelectedPath process is still running; kill it
  if ps -p ${getPathPID:-0} -o pid= &> /dev/null  ; then
    # the search for paths did not finish, yet.
    test ${waitCounter} -eq 0 && displayStatusLine 51 "."
    waitCounter=$(( waitCounter + 1 ))

    test ${waitCounter} -eq 50 && waitCounter=0

    std_out ttyOnly '.'
    sleep 1
  fi

  done

  return
}

##//! Get paths to all variables scheduled for processing.

##/*!
## The function runs in the back-ground and writes all paths found
## to a temporary file. SELECTion and LOCK assigned in the configuration
## are applied.
##*/

getPaths()
{
  test ${#DEBUG_MANAGER} -eq 0 && pauseX
  # if set -x enabled, then disable for this function

  # Get all paths to sub-dirs that contain netCDF file(s)
  # and list these in a temp file in the directory Project_table.

  # filename
  pathListFile=${SESSION_LOGDIR}/path-list.txt

  PROJECT_DATAV=( ${PROJECT_DATAV[*]//,/ } )

  test ${SHOW_PATH_SEARCH:-f} = t && set -x
  test ${ONLY_SUMMARY} && REUSE_PATH_LIST=t

  # only those paths that are selected and contain netCDF files
  if [ ${REUSE_PATH_LIST:-f} = f \
       -o ! -f ${SESSION_LOGDIR}/path-list.txt ] \
       || ! grep -q -- '---EOF---' ${SESSION_LOGDIR}/path-list.txt ; then
    \rm -f "${pathListFile}"

    if is_TPUT ; then
      echo "getPaths ... " > $TTY
    fi

    getSelectedPaths ${PROJECT_DATAV[*]} &
    getPathPID=$!
  fi

  if [ ${SHOW_PATH_SEARCH:-f} = t ] ; then
    set +x
    wait
    exit
  fi

  # Only pass the loop when the file is already partially filled.
  # Then, it is garantueed that there will be an EOF mark.
  while : ; do
    test ! -e ${pathListFile} && continue

    while [ ! -s ${pathListFile} ] ; do
      sleep 1
    done

    break
  done


  if [ "$( head -n 1 $pathListFile)" = '---EOF---' ] ; then
    if [ ${#PROJECT_DATAV[*]} -eq 1 ] ; then
      sTxt[0]="3data_path: ${PROJECT_DATAV}"
    else
      local tt="${PROJECT_DATAV[*]}"
      sTxt[0]="3data_path: [${tt// /, }]"
    fi

    sTxt[1]="3text: 1"
    sTxt[2]="3 - no valid sub-path found in data_path"

    std_out flush "${sTxt[0]:1}\n${sTxt[2]:4}"

    sendSubject="qcDKRZ: SELECT/LOCK conflict"

    sendEMail
    lastStatus=1  # exit status of this script
    exit
  fi

  test ${#DEBUG_MANAGER} -eq 0 && pauseX # roll back enabled set -x
}

getProjectTableName()
{
  # extract the name of the project table from subPath
  # see function initExperimentName()

  PROJECT_TABLE=$PRJCT_BASENAME

  # no automatic construction
  test ${#PT_PATH_INDEX} -eq 0 && return

  # decompose the path
  local pcs
  pcs=$PROJECT_DATA/$1
  pcs=( ${pcs//\// } )

  # if the last item on the right side is a kind of version, then skip
  local c ptPathIndex
  ptPathIndex=( ${PT_PATH_INDEX[*]} )

  local sz=$((${#pcs[*]}-1))

  if expr match ${pcs[sz]} 'v[[:digit:]]' &> /dev/null
  then
    # adjust indexes, because there is a trailing version_path_item
    for(( c=0 ; c < ${#ptPathIndex[*]} ; ++c )) ; do
      ptPathIndex[${c}]=$(( ${ptPathIndex[c]} +1 ))
    done
  fi

  # compose the name
  local N=${#pcs[*]}

  for c in ${ptPathIndex[*]} ; do
    if [ $c -lt $N ] ; then
      # subtract the reversed positional index from array size
      PROJECT_TABLE=${PROJECT_TABLE}${pcs[$(( N - c ))]}_
    else
      PROJECT_TABLE=unknownExp
      break
    fi
  done
  PROJECT_TABLE=${PROJECT_TABLE%_}.csv

  return
}

getRevNum()
{
  # get the number saved in QC_SRC/.conf as revision=num
  local rev revs
  revs=( $( grep 'revision=' ${QC_SRC}/.conf 2> /dev/null \
       | awk -F= '{print $2}' ) )

  if [ ${#revs[*]} -eq 0 ] ; then
    rev=-1
  elif [ ${#revs[*]} -eq 1 ] ; then
    rev=${revs[0]}
  else
    // several numbers are available by mistake; get the highest one
    rev=0
    local r
    for r in ${revs[*]} ; do
      test $r -gt $rev && rev=$r
    done
  fi

  eval $1=${rev}
  return
}

getSelectedPaths()
{
  # descent recursively into dirs and write all sub-paths,
  # containing at least one netCDF file,
  # into a file.
  test ${SHOW_PATH_SEARCH:-f} = f && set +x

  local currDirs projectDataIndex
  declare -a currDirs projectDataIndex

  local e i j k l s

  if [ ${isStart:-t} = t ] ; then
    isStart=f

    # first depth
    if [ ${#SELECT_PATH_LIST[*]} -eq 0 ] ; then
      SELECT_PATH_LIST=( '.*' )
      SELECT_VAR_LIST=( '.*' )
    fi

    splCount=${#SELECT_PATH_LIST[*]}
    lplCount=${#LOCK_PATH_LIST[*]}

    for(( k=0 ; k < lplCount ; ++k )) ; do
      LOCK_PATH_LIST[${k}]=".*${LOCK_PATH_LIST[k]}"
    done

    local item items sub0 sub1 projectDataPath
    declare -a items projectDataPath

    projectDataPath=( $* ) # actually PROJECT_DATA paths
    recurrCount=0

    set -f
    for(( k=0 ; k < ${#projectDataPath[*]} ; ++k )) do

      for(( l=0 ;  l < ${#SELECT_PATH_LIST[*]} ; ++l )) ; do
        # split selected path into components
        item=${SELECT_PATH_LIST[l]}
        items=( ${item//\// } )

        sub0=

        # look for an alpha-numeric sub-path leading a selected path
        for(( i=0 ; i < ${#items[*]} ; ++i )) ; do
          if expr match ${items[i]} "[[:alnum:]_-]\{${#items[i]}\}" &> /dev/null ; then
            # only accept valid paths
            sub1=${sub0}/"${items[i]}"
            test ! -e ${projectDataPath[k]}$sub1 && break

            sub0=$sub1
          else
            break
          fi
        done

        currDirs[${#currDirs[*]}]=${projectDataPath[k]}$sub0
        basePaths[${#basePaths[*]}]=${projectDataPath[k]}
        projectDataIndex[${#projectDataIndex[*]}]=$k
      done

    done
    set +f

    test ${#currDirs} -eq 0 && currDirs=( ${prjPaths[*]} )
  else
    # deeper recurrence level
    currDirs=( $* )
    recurrCount=$(( recurrCount + 1 ))
  fi

  local entries

  for(( i=0 ; i < ${#currDirs[*]} ; ++i )) ; do
    # Multiple currDirs and basePaths are only possible in the zero-th recursion level.
    # In higher levels, basePath inherits the value from the parent, when getSelected
    # was called there.
    currDir=${currDirs[i]}

    if [ ${recurrCount} -eq 0 ] ; then
      # will be inhereted in deeper recursion levels
      basePath=${basePaths[i]}
      prjDataIndex=${projectDataIndex[i]}
    fi

    entries=( $(ls -d $currDir/* 2> /dev/null) )

    if [ ${HIDDEN_DIRECTORIES:-f} = t ] ; then
      local hidden
      hidden=( $(ls -ad $currDir/.* 2> /dev/null) )
      if [ ${#hidden[*]} -gt 2 ] ; then
        # rm . and ..
        for(( j=${#hidden[*]}-1 ; j > -1 ; --j )) ; do
          test ${hidden[j]##*/} = '.' -o ${hidden[j]##*/} = '..' \
              && unset hidden[${j}]
        done

        entries=( ${entries[*]} ${hidden[*]} )
      fi
    fi

    # check for a variable selection (which is also a directory)
    for(( s=0 ; $s < $splCount ; ++s )) ; do
      if expr match "$currDir" ".*${SELECT_PATH_LIST[s]}" &> /dev/null
      then

        for entry in ${entries[*]} ; do
          # check only netCDF files
          test -d $entry -o ".${entry##*.}" != ".nc" && continue

          e=${entry##*/}

          if expr match "$e" "${SELECT_VAR_LIST[s]}" &> /dev/null
          then

            for(( l=0;  $l < $lplCount ; ++l )) ; do
              if expr match ${currDir} "${LOCK_PATH_LIST[l]}" &> /dev/null
              then
                if expr match ${e} "${LOCK_VAR_LIST[l]}" &> /dev/null
                then
                  # this dir and its descendents are locked. But,
                  # occurrence of multiple variables is possible, thus
                  # no return; just ignore this one and continue.
                  break 2
                fi
              fi
            done

            # found a valid selection; is it unique?
            if ! grep -q ${currDir#${basePath}} $pathListFile \
                  &> /dev/null ; then
              # write sub-path with a leading  slash
              echo "${prjDataIndex} ${currDir#${basePath}/}" >> $pathListFile

              # cap number of file
#              if [ ${NEXT:-0} -gt 0 -a ${NEXT:-0} -eq $(( ++fileCount )) ] ;  then
#                 return
#              fi
            fi

            # this break allows nc-files not only at the end-branches of
            # a directory structure.
            break 2  # only the path is needed
          fi
        done

      fi
    done

    # descend deeper
    for e in ${entries[*]} ; do
      if [ -d $e ] ; then

        # cancel entirely LOCKed directories
        for(( l=0;  $l < $lplCount ; ++l )) ; do
          if expr match ${e} "${LOCK_PATH_LIST[l]}" &> /dev/null
          then
             test "${LOCK_VAR_LIST[l]}" = '.*' && continue 2
          fi
        done

        getSelectedPaths $e
        recurrCount=$(( recurrCount - 1 ))
      fi
    done
  done

  # append End Of File mark
  test ${recurrCount} -eq 0 && echo '---EOF---' >> $pathListFile

  return
}

has()
{
  local c i j t

  if [ ${1:0:7} = '--char=' ] ; then
    if [ ${#1} -eq 7 ] ; then
      c=' '
    else
      c=${1#*=}
      if [ ${#c} -gt 1 ] ; then
        t=${c}
        unset c
        for(( i=0 ; i < ${#t} ; ++i )) ; do
          c[${#c[*]}]="${t:i:1}"
        done
      fi
    fi

    shift 1
  else
    c=','
  fi

  t=$*

  for(( j=0 ; j < ${#c[*]} ; ++j )) ; do
    for(( i=0 ; i < ${#t} ; ++i )) ; do
     test "${t:i:1}" = "${c[j]}" && return 0
   done
  done

  return 1
}


##//! Initialisation of a session

##/*!
## Starts script \a qcConfiguration.
##*/

init()
{
  # setting defaults, parsing of the configuration file and
  # command-line is left to the
  # qcConfiguration, which returns key-word assignments and lists.

  # look if argc contains a tty statement
  local is

  for(( i=1 ; i < $# ; ++i )) ; do
    test ${!i} = -x && set -x && continue
    if [ ${!i} = -T ] ; then
       i=$(( i + 1 ))
       TTY=${!i}
    fi
  done

  local T
  if [ -c "$TTY" ] ; then
    T=( -T ${TTY} )
  fi

  # some defaults
  CLOSED_TTY=f
  NO_STATUS=f
  isTPUT=f

  # configuration
  callQcConfig $* ${T[*]}

  if is_TTY  ; then
    if [ $NO_STATUS = f ] ; then
     if [ ${SIMPLE_STATUS_LINE:-f} = t ] ; then
       isTPUT=t
        if ! which tput &> /dev/null ; then
          isTPUT=f
        fi
      fi
    fi
  fi

  test ${#PROJECT} -eq 0 && PROJECT=NONE
  test ${#PROJECT_AS} -eq 0 && PROJECT_AS=${PROJECT}

  # automatic svn update
#  if [ "${AUTO_UPDATE}" = t ] ; then
#     ${QC_SRC}/install --auto-up --update
#  elif [ "${AUTO_UPDATE}" = f ] ; then
#     ${QC_SRC}/install --auto-up=disable
#  elif grep -q auto-up=enabled ${QC_SRC}/.conf 2> /dev/null ; then
#     ${QC_SRC}/install --update
#  fi

  # expand comma-sep-list to arrays
  EMAIL_SUMMARY=( ${EMAIL_SUMMARY//,/ } )
  EMAIL_TO=( ${EMAIL_TO//,/ } )
  QC_BIN=( ${QC_BIN//,/ } )
  QC_EXEC_HOSTS=( ${QC_EXEC_HOSTS//,/ } )
  NUM_EXEC_THREADS=( ${NUM_EXEC_THREADS//,/ } )

  # shut down any console messaging
  if [ ${QUIET:-f} = t ] ; then
    CLOSED_TTY=t
  fi

  if [ ${CHECKSUM:-f} = f ] ; then
    test ${#CS_STAND_ALONE} -gt 0 -o ${#CS_DIR} -gt 0 && CHECKSUM=t
  fi

  # no status for SHOW_CALL
  test ${SHOW_CALL:-f} = t && NO_STATUS=t
  test ${SIMPLE_STATUS_LINE:-f} = f && NO_STATUS=t

  # parse REATTEMPT_LIMIT and SLEEP_TIME
  initTryCom

  # Are the executables in QC_BIN applicable?
  if ! ${QC_BIN#*:}/unixTime.x &> /dev/null ; then
    sTxt[0]="3text: 1"
    sTxt[1]="3 - no executables in ${QC_BIN}"

    std_out flush "${sTxt[0]:1}\n${sTxt[1]:4}"
    sendEMail

    if is_TPUT ; then
      tput cuu 1 > $TTY
      tput dl 1 > $TTY
    fi

    finally
  fi

  # convert special characters to escaped ones.
  local i

  setF -f

  maxNumExecThreads=0
  local nET
  for nET in ${NUM_EXEC_THREADS[*]} ; do
    maxNumExecThreads=$(( maxNumExecThreads + nET ))
  done

  initProjectTableName

  # QC_SRC/tables -> QC_Results/tables
  initTables

  # save the configuration and init the session logfile
  if [ ${RESUME_SESSION:-f} = f ] ; then
    logConfiguration $*
  fi

  local pidFile=${SESSION_LOGDIR}/pid.$rootPID

  if [ ${SHOW_CALL:-f} = f ] ; then
    # file pid.$$ contains three lines:
    # 1) path to dir where this process was started.
    # 2) the command line arguments to start plus PID of this.
    # 3) the current session path and logfile name
    tryCom \
    echo "$(pwd)"             > $pidFile
    tryCom \
    echo -n "$*"             >> $pidFile
    tryCom \
    echo " --fpid $rootPID"  >> $pidFile
    tryCom \
    echo "$SESSION_LOGDIR/session.log" >> $pidFile
  fi

  maxSleep=1  # maximum duration of incremented sleep periods

  # temporary directory for exchanges between manager and executor
  PROC_POOL=$SESSION_LOGDIR/ProcPool

  if ! mkdir -p ${PROC_POOL} &> /dev/null ; then
    sTxt[0]= "3text: 1"
    sTxt[1]= "3 - could not mkdir PROC_POOL=${PROC_POOL}"

    std_out flush "${sTxt[2]:4}"

    sendSubject="could not mkdir PROC_POOL"
    sendEMail

    lastStatus=2  # exit status of this script
    exit
  fi

  # sub-dirs for temporary session- and experiment log-files
  tryCom \
  mkdir -p ${PROC_POOL}/session &> /dev/null
  tryCom \
  mkdir -p ${PROC_POOL}/experiments &> /dev/null

  # initialisation of the indexes of DRS tokens for the experiment name
  initExperimentName

  if [ ${#SUMMARY_ONLY} -gt 0 ] ; then
    ONLY_SUMMARY="${SUMMARY_ONLY}"
  elif [ ${#SUMMARY} -gt 0 ] ; then
    ONLY_SUMMARY="${SUMMARY}"
  fi
  if [ ${ONLY_SUMMARY:-f} != f -a ${isShow:-f} = f ] ; then
     if [ ${ONLY_SUMMARY} = t ] ; then
       getPaths
       getAllExps
     else
       EXP_NAMES=( ${ONLY_SUMMARY//,/ } )
       local i
       for(( i=0 ; i < ${#EXP_NAMES[*]} ; ++i )) ; do
         if [ ${EXP_NAMES[i]} != ${EXP_NAMES[i]%.log} ] ; then
           EXP_NAMES[${i}]=${EXP_NAMES[i]%.log}
         fi
       done
     fi

     taskSum
     exit
  fi

  # identifier for semaphore file (incremented)
  EX_ID=$rootPID  # just a starting point

  setF +f

  # get all selected, non-locked paths
  getPaths

  # reassure that TTY is still valid
  if [ ${ONLY_SUMMARY:-f} = f ] && is_TPUT ; then
    tput cuu 1 > $TTY
    tput dl 1 > $TTY
  fi

#  syncOptsInit="-s -T"
  syncOptsInit='-s --only-marked'

  # progress bar
#  if [ ${PROGRESS_BAR:-f} = t ] ; then
    # write to stdout
  if [ ${#PROGRESS_BAR} -gt 0 ] ; then
    # (over)write to a file and set percentage stepping
    local pbs=( ${PROGRESS_BAR//,/ } )
    local pb
    for pb in ${pbs[*]} ; do
      if expr match ${pb} '.*[[:alpha:]]' &> /dev/null ; then
        progressFile=" >> ${pb}"
      fi
      if ! expr match ${pb} '.*[[:alpha:]]' &> /dev/null ; then
        progressStep=$pb
      fi
    done

    test ${#progressStep} -eq 0 && progressStep=1  # %
    progressNext=$progressStep
  else
    progressStep=1  # %
    progressNext=1
  fi

  test ${USE_STRICT:-f} = t -a ${#CHECKSUM} -eq 0 && CHECKSUM=t

  # counter for NEXT
  fileCount=0

}

initExperimentName()
{
  # provided EXP_NAME has preference
  if [ ${#EXP_NAME} -gt 0 ] ; then
    unset EXP_PATH_INDEX
    return
  fi

  # extract the name of the experiment from subPath
  # Explanation: look for EXP_PATH_INDEX in a configuration file

  # we need a real array
  EXP_PATH_INDEX=( ${EXP_PATH_INDEX//,/ } )

  EXP_PATH_INDEX_MAX=100  # exceeds any number of path components

  test ${#EXP_PATH_INDEX} -eq 0 && return

  # note: the highest number points to the most left-side
  # path component

  EXP_PATH_INDEX_MAX=0

  local t
  for t in ${EXP_PATH_INDEX[*]} ; do
    test ${t} -gt ${EXP_PATH_INDEX_MAX} && EXP_PATH_INDEX_MAX=${t}
  done

  return
}

##//! Init annotation logging

initLog()
{
  sTxt[$((ix++))]="3file: $1"
  sTxt[$((ix++))]="3data_path: ${nextPath}"
  sTxt[$((ix++))]="3result_path: ${QC_DATADIR}/${subPath}"
  sTxt[$((ix++))]="3check:"
  sTxt[$((ix++))]="4meta_data: ${y_meta_data:-FAIL}"
  sTxt[$((ix++))]="4time_values: ${y_time_values:-OMIT}"
  sTxt[$((ix++))]="4data: ${y_data:-OMIT}"
  sTxt[$((ix++))]="3events:"
  sTxt[$((ix++))]="3 - event:"
  sTxt[$((ix++))]="7caption: \'${y_caption}\'"
  sTxt[$((ix++))]="7impact: ${y_impact}"
  sTxt[$((ix++))]="7tag: \'${y_tag}\'"

  y_meta_data=
  y_time_values=
  y_data=

  local i
  if [ ${#y_text[i]} -gt 0 ] ; then
    sTxt[$((ix++))]="7text:"
    for(( i=0 ; i < ${#y_text[*]} ; ++i )) do
      sTxt[$((ix++))]='7 - '"${y_text[i]}"
    done
    unset y_text
  fi

  sTxt[$((ix++))]="3status: ${y_status:-0}"
  y_status=

  local out=${QC_RESULTS}/data/${subPath}/qc_lock_${nV_fls[0]%.nc}.txt
  echo "Path: ${nextPath}"                  > $out
  echo "File: ${1}"                        >> $out
  echo "${impact}-${tag}: ${y_caption}" >> $out

  log

  sendSubject="Annotation: ${y_caption}"
  sendEMail
}

##//! Determination of various tables for the QC.

##/*!
## At the very first start, the script puts user-provided tables
## into QC_RESULTS/tables which are used during the further session.
##*/

initProjectTableName()
{
  if [ ${#PROJECT_TABLE_PREFIX} -gt 0 ] ; then
    local sz=${#PROJECT_TABLE_PREFIX}
    test ${PROJECT_TABLE_PREFIX:$((sz-1)):1} != '_' && \
       PROJECT_TABLE_PREFIX=${PROJECT_TABLE_PREFIX}_
  fi

  if [ ${#PROJECT_TABLE} -eq 0 ] ; then
    # generate default name
    test ${#PROJECT_TABLE_PREFIX} -eq 0 && PROJECT_TABLE_PREFIX=pt_

    test ${#PT_PATH_INDEX} -eq 0 && PROJECT_TABLE=${PROJECT}
  fi

  PRJCT_BASENAME=${PROJECT_TABLE_PREFIX}${PROJECT_TABLE}

  return
}

initTables()
{
  # extract the name of the experiment from subPath
  # Explanation: look for EXP_PATH_INDEX in a configuration file

  # we need a real array
  PT_PATH_INDEX=( ${PT_PATH_INDEX//,/ } )

  PT_PATH_INDEX_MAX=100  # exceeds any number of path components

  if [ ${#PT_PATH_INDEX[*]} -gt 0 ] ; then
    # note: the highest number points to the most left-side
    # path component
    PT_PATH_INDEX_MAX=0

    local t
    for t in ${PT_PATH_INDEX[*]} ; do
      test ${t} -gt ${PT_PATH_INDEX_MAX} && PT_PATH_INDEX_MAX=${t}
    done
  fi

  mkdir -p ${TABLE_PATH}

  # Precedence of path search for tables:
  #
  #   tables/projects/${PROJECT}
  #   tables/projects
  #   tables/${PROJECT}
  #   tables

  # 1) default tables are provided in ${QC_SRC}/tables/projects/PROJECT.
  # 2) a table of the same name provided in ${QC_SRC}/tables gets
  #    priority, thus may be persistently modified.
  # 3) tables from 2) or 1) are copied to ${QC_Results}/tables.
  # 4) Option TABLE_AUTO_UPDATE is the default, i.e. tables in
  #    projects are updated and are applied.
  # 5) 4) also for option USE_STRICT.

  initT STANDARD_TABLE=${STANDARD_TABLE}
  initT TIME_TABLE=${TIME_TABLE}
  initT TABLE_GCM_NAME=${TABLE_GCM_NAME}
  initT TABLE_RCM_NAME=${TABLE_RCM_NAME}
  initT TABLE_REQUIREMENTS=${TABLE_REQUIREMENTS}
  initT CHECK_LIST=${CHECK_LIST}
  initT CF_CHECK_LIST=${CF_CHECK_LIST}

# getCF_STD_NAME
  initT CF_STANDARD_NAMES=${CF_STANDARD_NAMES}

  return
}

initT()
{
   local table=${1%=*}
   local value=${1#*=}

   local pDir  # index 0 -> 3 provides precedence

   pDir[0]=tables/projects/${PROJECT_AS}
   pDir[1]=tables/projects
   pDir[2]=tables/${PROJECT_AS}
   pDir[3]=tables

   if [ "$table" = TABLE_RCM_NAME ] ; then
     if [ -d ${pDir[0]}/IS-ENES-Data.github.io ] ; then
       ( cd ${pDir[0]}/IS-ENES-Data.github.io && \
         git pull origin ) &> /dev/null
     else
       ( cd ${pDir[0]} && \
         git clone  https://github.com/IS-ENES-Data/IS-ENES-Data.github.io ) \
         &> /dev/null
     fi

     test ! -d ${pDir[0]}/cordex_specs && mkdir ${pDir[0]}/cordex_specs

     wget --tries=3 -q -N \
     --directory-prefix=${pDir[0]}/cordex_specs \
     http://cordex.dmi.dk/joomla/images/CORDEX/RCMModelName.txt \
     &> /dev/null
   fi

   test ${#value} -eq 0 && return  # not provided

   local p
   local ix

   # implicitly and highest: local file and file with absolute path

   for(( ix=0 ; ix < 4 ; ++ix )) ; do
     # if USE_STRICT is enabled, then projects[/PROJECT_AS] is required
     test ${USE_STRICT:-f} = t -a ${ix} -gt 1 && break

     # a local instance
     test -f ${value} && break

     # explicitly in a sub-dir path
     if [ -f ${QC_SRC}/${value} ] ; then
       p=${QC_SRC}/${value%/*}/
       break
     fi

     # scan through the precedence chain
     if [ -f ${QC_SRC}/${pDir[ix]}/${value} ] ; then
       p=${QC_SRC}/${pDir[ix]}/
       break
     fi
   done

   value=${value##*/}

   if [ ${table} = TABLE_RCM_NAME ] ; then
     cat ${pDir[0]}/IS-ENES-Data.github.io/CORDEX_ToU_RCMModel.txt \
         ${pDir[0]}/cordex_specs/RCMModelName.txt \
         > ${TABLE_PATH}/CORDEX_RCMModelName.txt
   elif [ -f "${p}${value}" ] ; then
     if ! diff ${p}${value} ${TABLE_PATH}/${value} \
           &> /dev/null ; then
       tryCom \
       cp ${p}${value} ${TABLE_PATH}
     fi

     eval ${table}=${value}
     setKWL ${table}  # note: no value
   fi

   return
}

##//! Initialisation of the command launcher

initTryCom()
{
  # parse REATTEMPT_LIMIT and SLEEP_TIME

  local rLs
  rLs=( ${REATTEMPT_LIMIT//,/ } )
  unset REATTEMPT_LIMIT

  local period
  declare -a period

  for(( i=0 ; i < ${#rLs[*]} ; ++i )) do
    # two figures?
    local j perd rL

    rL=${rLs[i]}
    perd=0
    for(( j=0 ; j < ${#rL} ; ++j )) ; do
      case ${rL:$j:1} in
        s) perd=${rL:0:$j}
           break ;;
        m) perd=$( echo "${rL:0:$j} * 60" | bc -l )
           break ;;
        h) perd=$( echo "${rL:0:$j} * 3600" | bc -l )
           break ;;
        d) perd=$( echo "${rL:0:$j} * 86400" | bc -l )
           break ;;
        w) perd=$( echo "${rL:0:$j} * 604800" | bc -l )
           break ;;
        M) perd=$( echo "${rL:0:$j} * 2592000" | bc -l )
           break ;;
        y) perd=$( echo "${rL:0:$j} * 31536000" | bc -l )
           break ;;
        \?) ;; # not valid; ignore
      esac
    done

    period=( ${period[*]} $perd )
  done

  # defaults
  SLEEP_TIME=1
  REATTEMPT_LIMIT=0
#  period[0]=${period[0]%.*}  # int-rounding

  if [ ${#period[*]} -eq 2 ] ; then
    if [ "${period[1]}" = '0' ] ; then
      SLEEP_TIME=${rLs[1]}
    else
      SLEEP_TIME=${period[1]}
    fi
  fi

  if [ ${#period[*]} -gt 0 ] ; then
    if [ "${period[0]}" = '0' ] ; then
      REATTEMPT_LIMIT=${rLs[0]}  # integer
    else
     if [ $(echo "a=0;if(${period[0]} > $SLEEP_TIME)a=1;a" | bc -l) \
           -eq 1 ] ; then
       REATTEMPT_LIMIT=$( echo "${period[0]} / $SLEEP_TIME" | bc -l)
     else
       REATTEMPT_LIMIT=$( echo "$SLEEP_TIME / ${period[0]}" | bc -l)
     fi

     REATTEMPT_LIMIT=${REATTEMPT_LIMIT%.*}
     test ${#REATTEMPT_LIMIT} -eq 0 && REATTEMPT_LIMIT=0
    fi
  fi
}

##//! Inquire available disk-space

inqDiskSpace()
{
  test ${DISABLE_INQ_DISK_SPACE:-f} = t && return

  local usedDiskSpace isSubmitted

  # diskUsage.x outputs percentage of used disk space.
  # if this could not be calculated, then return silently
  if ! usedDiskSpace=$( diskUsage.x ${QC_RESULTS} ) ; then
    return
  fi

  # The used disk space must not exceed this threshold %.
  local threshold
  threshold=95

  local total used val

  while : ; do
    # disk has enough space to go on
    test $(echo "a=0;if($usedDiskSpace < $threshold )a=1;a" | bc -l ) -eq 1 && return

    if [ ${isSubmitted:-f} = f ] ; then
      sendSubject="not enough space left on device"

      local text
      text="Available capacity on device below $((100 - threshold)) %"
      text="${text}\ndf  ${QC_RESULTS}:"
      text="${text}\n$( df -h .|head -n 1)"
      text="${text}\n$( df -h .|tail -n 1)"
      text="${text}\nqcDKRZ stays in a wait loop."

      std_out flush "${text}"
      isSubmitted=t
    fi

    sleep 91
  done

  sendSubject="disk space shortage cleared"
  text="Disk space shortage cleared."
  text="${text}\nqcDKRZ resumes processing."

  std_out flush "${text}"
}

is_TPUT()
{
  test ${CLOSED_TTY} = t && return 1
  test $isTPUT = f      && return 1

  # reassure that TTY is still valid
  if [ ! -c "$TTY" ] ; then
    CLOSED_TTY=t
    isTPUT=f
    return 1
  fi

  return 0
}

is_TTY()
{
  test ${CLOSED_TTY} = t && return 1

  # reassure that TTY is still valid
  if [ ! -c "$TTY" ] ; then
    CLOSED_TTY=t
    return 1
  fi

  return 0
}

##//! Save configuration information.

logConfiguration()
{
  # don't create log-files
  test ${isShow:-f} = t && return

  # two things happen here. The config file(s), i.e. also a task file,
  # will be copied to the config directory.
  # Also, the names will be noted  in the session log-file, additionally
  # with the command-line call

  # when a session is resumed
  test -e ${SESSION_LOGDIR}/session.log && return

  # a preamble will be copied to all log-files
  local preamble=${SESSION_LOGDIR}/session.prmbl

  # this file is prepented to all exp-log-files
  tryCom \
  echo    '---'                 > $preamble
  echo    '# Log-file of a QC session started by qcDKRZ' \
                               >> $preamble
  echo    'configuration: '    >> $preamble
  echo -n ' command-line: '    >> $preamble
  echo    "$*"                 >> $preamble

  # save living configuration options
  echo -e ' options: '      >> $preamble

  local item z
  for item in ${keyWordList[*]} ; do
     eval w="\${${item}[*]}"
     test -z "$w" && w=t

     echo -n "  ${item}: " >> $preamble
     if has --char=, ${w} ; then
       echo "[${w//,/, }]"   >> $preamble
     else
       echo "${w}"           >> $preamble
     fi
  done

  # start: and corresponding date:
#  local rev_0
#  getRevNum rev_0

#  sTxt[0]="3qc_svn_revision: ${rev_0}"
  log --start

  # make a link between session logdir and task name
  if [ ${#qcCs[*]} -gt 0 ] ; then
    local p s
    p=${SESSION_LOGDIR%/*}
    s=${SESSION_LOGDIR##*/}
    ln -sf ${SESSION} $p/${qcCs[0]##*/}
  fi

  return
}

##//! Log annotations to the experiment-logfile
log()
{
  # print execution messages to the experiment-log file

  local s_out  # collects sTxt for output

  local sp
  sp[0]=''
  sp[1]=' '
  sp[2]='  '
  sp[3]='   '
  sp[4]='    '
  sp[5]='     '
  sp[6]='      '
  sp[7]='       '
  sp[8]='        '

  if [ "$1" = '--start' ] ; then
    s_out="start:\n${sp[1]}date: $( date +'%FT%T' )"
    echo -e "$s_out" >> ${SESSION_LOGDIR}/session.prmbl

    cp ${SESSION_LOGDIR}/session.prmbl ${SESSION_LOGDIR}/session.log

    echo 'items:' >> ${SESSION_LOGDIR}/session.prmbl
    unset sTxt
    return
  fi

  local out
  getExperimentName ${subPath}
  out=$EXP_LOGDIR/${CURR_EXP_NAME}.log

  s_out="${s_out} - date: $( date +'%FT%T' )"

#  if [ ${QC_MANAGER_HOST} = $HOSTNAME ] ; then
#  test ${ix} -lt 2 && \
#    echo  "${sp[ix]}date: $( date +'%FT%T' )" >> $out
#  else
#    tryRemote ssh ${QC_MANAGER_HOST} \
#      echo -e ${str} >> $out
#  fi

  # The total output is subdivided into chunks of pmax characters.
  # Effect of \n is preserved.
  local i k str0 str
  local N=70

  for(( i=0 ; i < ${#sTxt[*]} ; ++i )) ; do
    #sTxt: 'I[ - ]text'
    #       ^-- number of leading spaces

#    if [ "${sTxt[i]}" != "${sTxt[i]//:/}" -o ${#sTxt[i]} -lt $N ] ; then
      s_out="${s_out}\n${sp[${sTxt[i]:0:1}]}${sTxt[i]:1}"
      continue
#    fi

    # break a long text into several line
    s_out="${s_out} |"  # preserve lines

    if [ "${sTxt[i]:1:3}" = ' - ' ] ; then
      s_out="${s_out}\n${sp[${sTxt[i]:0:1}]} - |"
      str0="${sTxt[i]:4} }"
    fi

    str=

    while : ; do
      k=0  # necessarily outside the for-loop if the latter is skipped

      if [ ${#str0} -ge $N ] ; then
        # break lines with length > N
        for (( ; k < N ; ++k )) ; do
          if [ "${str0:k:2}" = "\n" ] ; then
            str="${str}${sp[$(( ${sTxt[i]:0:1} +1))]}${str0:0:k}\n"
            str0=${str0:$((k+2))}
            continue 2
          fi
        done
      fi

      if [ $k -eq $N ] ; then
        str="${str}${sp[$(( ${sTxt[i]:0:1} +1))]}${str0:0:N}\n"
        str0=${str0:N}
      else
        str="${str}${sp[$(( ${sTxt[i]:0:1} +1))]}${str0:0:N}"
        break
      fi
    done
    s_out="${s_out}${str}"

  done

  echo -e "${s_out}" >> $out

  test "$1" == '--keep' && return

  unset sTxt

  return
}

log_expMessage()
{
  # print execution messages to the experiment-log file

  # $1: "time-range"
  # $2: "execution message"

  local str

  # extracted name of the experiment from SUB_PATH;
  # see configuration file

  # date and time range
  str="\n$( date +'%F %T' ) "
  str="$str""$1"

#  if [ ${QC_MANAGER_HOST} = $HOSTNAME ] ; then
    tryCom \
    echo -e "${str}" >> $EXP_LOGDIR/${CURR_EXP_NAME}.log
#  else
#    tryRemote ssh ${QC_MANAGER_HOST} \
#      echo -e ${str} >> $EXP_LOGDIR/${CURR_EXP_NAME}.log
#  fi

   return
}

##//! Log annotation to the session-logfile

log_sessMessage()
{
  # print messages to the log file

  test ${#DEBUG_MANAGER} -eq 0 && pauseX

  # date and host
  local k N str0 str

  str0="$( date +'%F %T' ) ${HOSTNAME%%.*}:qcDKRZ\n"
  str0="${str0}$*"

  # The total output is subdivided into chunqks of pmax characters.
  # Effect of \n is preserved.
  local N
  N=100
  str=

  while : ; do
    k=0  # necessary when skipping the loop

    if [ ${#str0} -ge $N ] ; then
      # break lines with length > N
      for (( ; k < N ; ++k )) ; do
        if [ "${str0:k:2}" = "\n" ] ; then
          str="${str}${str0:0:k}\n"
          str0=${str0:$((k+2))}
          continue 2
        fi
      done
    fi

    if [ $k -eq $N ] ; then
      str="${str}${str0:0:N}\n\t"
      str0=${str0:N}
    else
      str="${str}${str0:0:N}"
      break
    fi
  done

  tryCom \
  echo -e "\n${str}" >> $SESSION_LOGDIR/session.log

  test ${#DEBUG_MANAGER} -eq 0 && pauseX
  return
}

##//! Log current QC version information

mkLinks()
{
  local dest_path=$1
  local subPath=$2
  local src_filename=$3
  local fBase=$4

  local i grfs grf text text2

  local f tmp

  tmp=$( getDateRange ${src_filename} )
  f=${src_filename%.nc}
  f=${f%_${tmp}}

  # Get all names of corresponding genuine qc result files.
  grfs=(
     $(ls ${dest_path}/${subPath}/*${fBase}* \
         2> /dev/null) )

  local is

  tmp=$( getDateRange ${link_filenameBase} )
  link_filenameBase=${link_filenameBase%.nc}
  link_filenameBase=${link_filenameBase%_${tmp}}

  # target and link share the same filename base
  test ${link_filenameBase} = ${f} && is=t

  for grf in ${grfs[*]} ; do
    local name=${grf##*/}

    if [ ${is:-f} = t ] ; then
      test -h ${dest_path}$saveSubPath/$name && continue

      if ln -s -t ${dest_path}$saveSubPath \
            ${link_target_path}/$name &> /dev/null ; then
        text2="${text2}\nQC File:\t${grf##*/}"
      fi
    else
      grf=${grf##*/}
      grf=${grf/${f}/${link_filenameBase}}

      test -h ${dest_path}$saveSubPath/$grf && continue

      cd ${dest_path}$saveSubPath &> /dev/null
      if ln -s ${link_target_path}/$name $grf &> /dev/null ; then
        text2="${text2}\nQC File:\t${grf}"
      fi
      cd - &> /dev/null
    fi
  done

  if [ ${#grfs[*]} -gt 0 ] ; then
    sTxt[0]="3data_path: ${PROJECT_DATA}${saveSubPath}"
    sTxt[1]="3caption: 'symbolic link to QC results'"
    sTxt[2]="3text: $((${#grfs[*]}+2))"
    sTxt[3]="3 - qc_linkpath= ${dest_path}${saveSubPath}"
    sTxt[4]="3 - qc_target_path= ${grf[0]%/*}"

    if [ ${#grfs[*]} -gt 1 ] ; then
      local l
      for(( l=0 ; l <  ${#grfs[*]} ; ++l )) ; do
         sTxt[$((l+4))]="3 - qc_file= ${grfs[l]}"
      done
    else
      sTxt[4]="3 - qc_file= ${grfs}"
    fi

    local k n text
    for(( k=0 ; k < ${#sTxt[*]} ; ++k )) ; do
      n=1
      test "${sTxt[k]:1:3}" = ' - '  && n=4

      text="${text}${sTxt[k]:n}\n"
    done
    std_out flush "${text}"
  fi

  return
}

##//! Operate sets of sub-temporal files for a given variable.

##/*!
## Maximum number of sets is equivalent to the number of NUM_EXEC_THREADS.
##*/

operatePipes()
{
  # Variables, i.e. the entire sets of sub-temporal files,
  # are kept in a container (array of indirect references).
  # Maximum number of indirect references equals the maximum
  # of allowed number of execution threads. In the initial phase
  # the container is filled step by step for each call of this
  # function. If all sub-temporal files of a given variable
  # are processed, then the corresponding container item is
  # released and filled with the next variable. Special care
  # has to be taken when the last item of the set of sub-temporal
  # files as well as the last variable.

  local subPath
  local hasFinished=f
  local retVal=1

  if [ $# -gt 0 ] ; then
     subPath=$1
  else
    # drain pipes
    hasFinished=t
    nFcurr=0
    retVal=0
  fi

  # empty subPath for draining the pipes; nothing to refill
  if [ ${#subPath} -gt 0 ] ; then
    # find the next file(s); if there is any.
    if \
#trace \
      getNextVariable ${fBase[ix]} ; then

      return $retVal # try for a next one
    fi

    # Any duplicates of variables in case of multiple PROJECT_DATA
    # assignments? Note: all sub-paths are mapped to the same QC_RESULTS
    if [ ${#PROJECT_DATAV[*]} -gt 1 ] ; then
      local k;
      for(( k=0 ; k < nFmax ; ++k )) ; do
        if [ "${fBase[ix]}" = "${nF_name[k]}" ] ; then
          # The if-clause is sufficient. Testing sub-paths allows identical
          # variable names in different sub-paths (not CMIP5 or CORDEX).
          test "${fBase[ix]}" = ${nF_name[k]} && return 0
        fi
      done
    fi

    # update container of indirect references of string arrays.
    # init: direct to new pipes step by step
    # op:   redirect to drained pipes
    local j
    if [  $nFmax -lt ${maxNumExecThreads} ] ; then
      # init:
      nF_PID[${nFmax}]=0
      j=$nFmax
      nFmax=$((nFmax+1))
    else
      # op:
      j=$nFcurr
    fi

    xyz=nFstore${j}
    eval ${xyz}=\(\${nextFile[*]}\)
    eval nFstore[${j}]=${xyz}

    # generate an experiment name; CURR_EXP_NAME gets a 'return value'
#trace \
    getExperimentName ${subPath}
#trace \
    getProjectTableName ${subPath}

    nF_EXP[${j}]=$CURR_EXP_NAME
    nF_TP[${j}]=$PROJECT_TABLE
    nF_SUBPATH[${j}]=${subPath}
    nF_name[${j}]=${fBase[ix]}

    if [ -e ${QC_RESULTS}/data/${subPath}/qc_${fBase[ix]}.nc ] ; then
      nF_SEQ[${j}]=s
    else
      nF_SEQ[${j}]=f
    fi

    countActivePipes=$(( countActivePipes + 1 ))
  fi

  # purpose of this loop: whenn all allowed execution threads
  # are busy, then wait until any of them is free again
  local op_nap=1
  local host_nap

  while : ; do
    # the index holds the value across the function
    test ${nFcurr} -eq ${nFmax} && nFcurr=0

    for((  ; nFcurr < nFmax ; ++nFcurr )) ; do
      # skip pipe with a running job
      if [ ${nF_PID[nFcurr]} -gt 0 ]  ; then
        if ps -p ${nF_PID[nFcurr]} -o pid= &> /dev/null  ; then
          # there is still an active job for this fBase
          continue
        fi
      elif [ $hasFinished = t ] ; then
        # fade out
        test $countActivePipes -gt 0  && continue

        break 2  # that's it
      fi

      metaV=${nFstore[nFcurr]}[*]
      metaW=${nFstore[nFcurr]}

      p_nF=(${!metaV})
      CURR_EXP_NAME=${nF_EXP[nFcurr]}
      PROJECT_TABLE=${nF_TP[nFcurr]}
      FILE_SEQUENCE=${nF_SEQ[nFcurr]}

      subPath=${nF_SUBPATH[nFcurr]}

      # anything extraordinary in a record of a sub-temporal file must stop
      # the pipe; p_nF -eq 0 means that the pipe is empty
      ls ${QC_RESULTS}/data/${subPath}/qc_lock_*.txt ${notes} &> /dev/null
      local stt=$?

      if [ ${stt} -eq 0 ] ; then
        # no processing due to a lock-file
#        if [ ${#PROGRESS_BAR} -gt 0 ] ; then
          local num=${#p_nF[*]}
          progressFileNum=$(( ${progressFileNum:-0} + num ))
#        fi
      fi

      if [ ${#p_nF[*]} -eq 0 -o ${stt} -eq 0 ] ; then
        countActivePipes=$(( countActivePipes - 1 ))
        nF_EXP[${nFcurr}]=
        nF_TP[${nFcurr}]=
        nF_name[${nFcurr}]=
        nF_PID[${nFcurr}]=0
        nF_SUBPATH[${nFcurr}]=
        nF_SEQ[${nFcurr}]=
        unset nFstore[${nFcurr}]

        if [ $hasFinished = t ] ; then
          continue;
        else
          return $retVal # get next variable
        fi
      fi

      nextFile=${p_nF[0]}

      if [ ${FILE_SEQUENCE} = 'f' ] ; then
        if [ ${#p_nF[*]} -eq 1 ] ; then
          FILE_SEQUENCE=s # there is only a single file
        else
          nF_SEQ[${nFcurr}]=s
        fi
      elif [ ${#p_nF[*]} -eq 1 ] ; then
         FILE_SEQUENCE=l # last
      else
         FILE_SEQUENCE=s
      fi

      if [ ${isPost:-f} = t -a ${#p_nF[*]} -eq 1 ] ; then
        POST_PROC=t
      else
        POST_PROC=
      fi

      # select a free host and store the name  in variable 'nextHost'
      # returns 0 for success and 1 for no free host found
      host_nap=1  # increment for a sleeping period

      test ${#DEBUG_MANAGER} -eq 0 && pauseX
      while \
#trace \
       ! getHost
      do

#      while ! getHost ; do
#trace \
        sleep $host_nap
        test $host_nap -lt $maxSleep && host_nap=$(( host_nap +1 ))
      done
      test ${#DEBUG_MANAGER} -eq 0 && pauseX

      # check disk space
      if [ ${ENABLE_DISK_SPACE_INQ:-f} = t ] ; then
#trace \
        inqDiskSpace
      fi

      if [ ${SHOW_NEXT:-f} = t ] ; then
        std_out flush "Next: ${subPath} ${nextFile}"
        finally
      fi

#trace \
      callQcExecutor ${nextFile}

      # store the corresponding pid
      nF_PID[${nFcurr}]=${currPID}

#      if [ ${#PROGRESS_BAR} -gt 0 ] ; then
        # get number of data files for progress estimation
        progressFileNum=$(( ${progressFileNum:-0} + 1 ))
#      fi

      displayStatusLine ${#nextFile} "\rNEXT File: ${nextFile}"

      # limit the number of executions
      if [ ${NEXT:-0} -gt 0 -a ${NEXT:-0} -eq $(( ++fileCount )) ] ;  then
#trace \
        wait_fnct

        if [ ${FLOW_TRACE:-f} = t ] ; then
          FLOW_TRACE_EXIT=t
          return $retVal
        fi

        return 0  # unconditional
      fi

      # update the container with arrays of filenames
      unset p_nF[0]  # pop from the front

      # store the residual array
      eval ${metaW}=\( \${p_nF[*]} \)

#      if [ ${NO_STATUS} = f  ] ; then
#        if [ ${SIMPLE_STATUS_LINE:-f} = t ] ; then
#          # get number of data files for progress estimation
#          progressFileNum=$(( ${progressFileNum:-0} + 1 ))

#          displayStatusLine ${#nextFile[nF_IX]} "\rNEXT File: ${nextFile[nF_IX]}"
#        fi
#      fi

      if [ ${#DEBUG_MANAGER} -gt 1 ] ; then
        wcRes=($( wc -l ${DEBUG_MANAGER}.${dbgCycle}))
        # cycle after every block of 1000000 lines
        if [ ${wcRes[0]} -gt 1000000 ] ; then
          set +x
          exec 2<&7 7<&-
          exec 7<&2
          exec 2>${DEBUG_MANAGER}.$((++dbgCycle))
          set -x
        fi
      fi
    done

    # all pipes are busy
    if [ ${countActivePipes} -eq ${nFmax} -o $hasFinished = t ] ; then
      test ${nFmax} -eq 0 && return $retVal  # pipes have never been filled

#trace \
      sleep $op_nap
      test $op_nap -lt $maxSleep && op_nap=$(( op_nap +1 ))
    fi

    # container still not initially filled
    if [ $hasFinished = f -a $nFmax -lt ${maxNumExecThreads} ] ; then
      return $retVal
    fi
  done

  return $retVal
}

pauseX()
{
  # toggle between set -x and set +x in a way that
  # restores the original setting after calling twice

  if [ ${isSetX:-t} = t ] ; then
    test "$(set -o |grep xtrace | awk '{print $2}')" = off && return

    # first call
    isSetX=on
  fi

  # restore previous setting
  if [ ${isSetX} = off ] ; then
    set -x
    isSetX=on
  else
    set +x
    isSetX=off
  fi

  return
}

##//! Send annotations to the list of email recipients.

sendEMail()
{
  if [ ${#EMAIL_TO[*]} -eq 0 ] ; then
     return
  fi

  local sendSub
  sendSub="QC ${PROJECT} ${CURR_EXP_NAME}: ${sendSubject}"

  # activate backslash escaped chars
  local sendT
  sendT="$( echo -e $sendText )"

  eval ${MAIL} -s \"\$sendSub\"  ${EMAIL_TO[*]} <<!
$sendT
!

  return
}

setF()
{
  # toggle between set -f and set +f in a way that
  # restores the original setting after calling twice

  #Note: set -f  disables pathname expansion; corresponds to on
  #Note: set +f   enables pathname expansion; corresponds to off

  # restore previous setting
  if [ ${isSetF_first:-t} = f ] ; then
    if [ $stateF = on ] ; then
      set -f
    else
      set +f
    fi

    isSetF_first=t
    return
  fi

  # the initial state
  if [ ${isSetF_first:-t} = t ] ; then
    isSetF_first=f
    stateF=$(set -o |grep noglob | awk '{print $2}')
  fi

  # set temporarily
  # switch to a state valid until the next call
  if [ "$1" = '-f' -a ${stateF} = off ] ; then
    set -f
  elif [ "$1" = '+f' -a ${stateF} = on ] ; then
    set +f
  fi

  isSetF=t  # ready for the next pair of calls

  return
}

rmEmptyPaths()
{
  local subPath
  while read -a subPath ; do
    rmdir -p ${QC_RESULTS}/data/${subPath[1]} &> /dev/null
  done < ${pathListFile}

  return
}

setLD_LIB_PATH()
{
  # location of shared libraries not in default paths
  # get those used for the compilation stored in .conf
  local tmp
  tmp=($( grep 'LD_LIBRARY_PATH=' ${QC_SRC}/.conf 2> /dev/null))
  tmp=( ${tmp[*]//LD_LIBRARY_PATH=/} )
  tmp=( ${tmp[*]//:/ } )

  # check against current LD_LIBRARY_PATH
  if [ ${#LD_LIBRARY_PATH} -gt 0 ] ; then
    local i j ldp
    ldp=( ${LD_LIBRARY_PATH//:/ } )

    for(( i=${#tmp[*]}-1 ; i > -1 ; --i )) ; do
      for(( j=0 ; j < ${#ldp[*]} ; ++j )) ; do
        if [ "${tmp[i]}" = "${ldp[j]}" ] ; then
           unset tmp[${i}]
           break
        fi
      done
    done
    tmp=( ${tmp[*]} )
  fi

  if [ ${#tmp[*]} -gt 0 ] ; then
    for(( i=0 ; i < ${#tmp[*]} ; ++i )) ; do
      test ${#LD_LIBRARY_PATH} -gt 0 && LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:
      LD_LIBRARY_PATH=${LD_LIBRARY_PATH}${tmp[i]}
    done
    export LD_LIBRARY_PATH
  fi

  return
}

setKWL()
{
  # store keywords, no values
  local key=$1

  # was key already defined?
  for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
     if [ "${keyWordList[i]}" = "$key" ] ; then
      return
    fi
  done

  # add key to the list
  keyWordList[${#keyWordList[*]}]=$key

  return
}

##//! Launcher of annotations

##/*!
## Determination where annotations go to: experiment _logfile,
## session-logfile, email, and/or terminal.
##*/

std_out()
{
  # if a tty device is connected, then output immediately,
  # else collect contents and print to a default file and/or
  # send by email.
  test $# -eq 0 && return

  if [ "$1" = ttyOnly ] ; then
    if is_TTY ; then
       shift
       echo -e -n "$*" > $TTY
    fi
    return
  fi

  if [ "$1" = add  ] ; then
    # only collect items
    shift
    outputText[${#outputText[*]}]="$*"

    return
  fi

  if [ "$1" = flush ] ; then
    shift
    test $# -gt 0 && outputText[${#outputText[*]}]="$*"

    # nothing to flush
    test ${#outputText[*]} -eq 0 && return
  fi

  local j str0

  # flush
  if [ ${#outputText[*]} -eq 0 -a $# -eq 0 ] ; then
    return
  fi

  # email
  # print to session logfile
  sendText=
  for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
    sendText="${sendText}${outputText[j]}"
  done

  if [ ${#SESSION_LOGDIR} -gt 0 ] ; then
    log_sessMessage "${outputText[*]}"
  fi

  if is_TTY ; then
     shift
     echo -e -n "${sendText}\n" > $TTY
  else
    if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
     sendEMail
    fi
  fi

  # neither email nor session logfile. Store in dir NoDevice
#  if [ ${isSent} = f ] ; then
#    # str0 gets the filename for undeliverables
#    if mkdir -p $QC_SRC/NoDevice &> /dev/null ; then
#      str0="undeliv_$( date +'%FT%T' )_${HOSTNAME%%.*}".txt
#      echo "$str0" >> $QC_SRC/NoDevice/$str0

#      for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
#        echo -e -n "${outputText[j]}" >> $QC_SRC/NoDevice/$str0

#      for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
#        echo -e -n "${outputText[j]}" >> $QC_SRC/NoDevice/$str0
#      done
#    fi
#  fi

  unset outputText

  return
}

taskSum()
{
  local cvr prj qrs tcl ers
  test ${#PROJECT}    -gt 0 && prj="-P ${PROJECT}"
  test ${#QC_RESULTS} -gt 0 && qrs="-r ${QC_RESULTS}"

  if [ ${#TABLE_PATH} -gt 0 ] ; then
    tcl="-t ${TABLE_PATH}/${CHECK_LIST}"
    tcfcl="-c ${TABLE_PATH}/${CHECK_LIST}"
    test ${FIND_NOT_DELIVERED:-t} = t &&
      cvr="-s ${TABLE_PATH}/${STANDARD_TABLE}"
  fi

  if [ ${#EMAIL_SUMMARY[*]} -gt 0 ] ; then
    ers="${EMAIL_SUMMARY[*]}"
    ers=" -e ${ers// /,}"
  fi

  if [ ${#EXP_NAMES[*]} -gt 0 ] ; then
    /bin/bash ${QC_SRC}/scripts/taskSummary ${DEBUG_X} \
       -p ${QC_RESULTS}/check_logs \
       ${cvr} ${ers} ${prj} ${qrs} ${tcl} ${EXP_NAMES[*]}
  fi

  return
}

terminate()
{
  isTERM=t
  finally
  exit
}

testFileLink()
{
  # Purpose: when the file of the current path is
  # a symbolic link, then make links to corresponding QC results.
  # If corresponding QC results don't exist, the append the subpath
  # to the genuine data (Note: D A T A ).
  # If the path to the genuine data is LOCKed, then remove the lock.

  # Note: only links of files within ${subPath}
  # are taken into account. A symbolic link of the prefixed
  # ${PROJECT_DATA} path is always dereferenced.

  local src_filename link_target_path

  # Note: multiple filenames are allowed, but all
  # would be ascociated with the same QC result file.
  # Thus,considering the first one is sufficient

  # Take into account not only a qc-result file but, also new
  # associated files, e.g. freqDist. These could be added
  # after having established the link to the qc result file.

  # dereferenced link
  deref_link link_target_path ${PROJECT_DATA}/${subPath}/$nextFile

  src_filename=${link_target_path##*/}
  link_target_path=${link_target_path%/*.nc}

  if [ ${#link_target_path} -eq 0 ] ; then
    # this should not happen
    sendSubject="No valid link detected from source"

    sTxt[0]="3text: 1"
    sTxt[1]="3 - link detection failed for: ls -l ${PROJECT_DATA}/${subPath}/$nextFile"

    std_out flush "${sTxt[1]:4}"

    sendEMail
    return 0
  fi

  local saveSubPath=${subPath}
  local dest_path=${QC_RESULTS}/data

  if [ "${link_target_path:0:1}" = '/' ] ; then
    # a link to the outside of PROJECT_DATA will always be dereferenced
    test "${link_target_path:0:${#PROJECT_DATA}}" != ${PROJECT_DATA} && return 1

    # adjust for a link with an absolute path
    link_target_path=$QC_RESULTS/data${link_target_path#${PROJECT_DATA}}

    subPath=${link_target_path#${QC_RESULTS}/data/}
  else
    # Any relative path?
    subPath=${link_target_path}

    local tmp_subPath
    if [ ${saveSubPath:0:1} = '/' ] ; then
      tmp_subPath=${saveSubPath:1}
    else
      tmp_subPath=${saveSubPath}
    fi

    while [ ${subPath:0:1} = '.' ] ; do
      subPath=${subPath#*/}
      tmp_subPath=${tmp_subPath%/*}
    done

    subPath=/${tmp_subPath}/${subPath}
  fi

  # qc the genuine data
  tryCom \
  mkdir -p ${QC_RESULTS}/data/${subPath}

# point to the genuine filename from here
  local ix=0
  local f fBase tmp

  tmp=$( getDateRange ${src_filename} )
  f=${src_filename%.nc}
  f=${f%_${tmp}}
  fBase[ix]=$f

#  getFilenameBase
  operatePipes ${subPath}

#trace \
  checkClosedMessages

  # link to genuine qc results
  mkLinks ${dest_path} ${subPath} ${src_filename} ${fBase[ix]} &

  return
}

testLocks()
{
  # apply rules, clearings, and test for qc_note files
  if \
#trace \
  applyRules ${fBase[ix]} ; then
    return 0  # not selected
  fi

  # conditions for clearing are described in the configuration file
  if [ ${#CLEAR} -gt 0 ] ; then
    # if CLEAR=only or SHOW_CLEAR was set, then try another variable
    if clear ; then
      return 0
    fi
  fi

  if \
#trace \
  checkLockFile ${fBase[ix]} ; then
#    if [ ${#PROGRESS_BAR} -gt 0 ] ; then
      local num=$( ls -d ${PROJECT_DATA}/${subPath}/${fBase[ix]}*.nc \
                    | grep -c . )
      progressFileNum=$(( ${progressFileNum:-0} + num ))
#    fi

    return 0  # is blocked
  fi

  return 1
}

testPathLink()
{
  # Purpose: when the current path is
  # a symbolic link, then make links for the QC results, too.
  # Input parameter: subPath
  # Return 0 for a link

  # Note: only a link of a directory within ${subPath}
  # is taken into account. A symbolic link to the outside
  # is
  # A symbolic link of the prefixed
  # ${PROJECT_DATA} path is always dereferenced.

  if [ $# -eq 0 ] ; then
     return 1
  fi

  local dest_path

  dest_path=$QC_RESULTS/data${1}

  local link_target_path

  # test path components. Note: pc starts with a '/'
  local pc
  pc=${1%/}

  while [ "${pc}" != "${pc%/*}" ] ; do

    if [ ! -h ${PROJECT_DATA}$pc ] ; then
       pc=${pc%/*}  # try the preceding component
       continue  # not a symbolic link
    fi

    # dereferenced link
    deref_link link_target_path ${PROJECT_DATA}$pc

    if [ ${#link_target_path} -eq 0 ] ; then
       # this should not happen
       sendSubject="No valid link detected from source"

       sTxt[0]="3text: 1"
       sTxt[1]="3 - Link detection failed for: ls -l ${PROJECT_DATA}$pc"

       std_out flush "${sTxt[1]:4}"

       sendEMail
       continue
    fi

    # a link to the outside of PROJECT_DATA will be dereferenced
    if [ "${link_target_path:0:1}" = '/' -a \
         "${link_target_path:0:${#PROJECT_DATA}}" != ${PROJECT_DATA} ] ; then
       return 1
    fi

    # the dir where to place the link must exist.
    test ! -e $QC_RESULTS/data${pc%/*} && return 0  # try again later

    # is there already a link in the qc dir tree?
    if [ -e "$QC_RESULTS/data${pc}" ] ; then
       # is the link still the one it should be?
       local dest_lnk

       # dereferenced link
       deref_link dest_lnk  ${QC_RESULTS}/data$pc

       # link exists; nothing has changed
       if [ "$link_target_path" = "$dest_lnk" ] ; then
         return 0
       fi
    fi

    # we don't care if a broken link is produced; this may get
    # valid in a later iteration.
    ln -sf ${link_target_path} $QC_RESULTS/data${pc}

    local text
    text="Symbolic link for a sub-tree"

    if [ ${link_target_path:0:1} = / ] ; then
      sTxt[0]="3text: 1"
      sTxt[1]="3 - $QC_RESULTS/data${pc} --> ${link_target_path}"
    else
      sTxt[0]="text: 2"
      sTxt[1]="3 - common_path: $QC_RESULTS/data${pc%/*}"
      sTxt[2]="3 - link: ${pc##*/} --> ${link_target_path}"
    fi

    test ${#text} -gt 28 && log_sessMessage "$text"

    return 0
  done

  return 1
}

timer()
{
  # on normal execution, this function is closed externally in time
  limit=10
  for(( i=0 ; i < limit ; ++i )) ; do
    if ! ps -p $1 -o pid= &> /dev/null  ; then
      # there is no more active job
      return 0
    fi

    sleep 1
  done

  kill -TERM $1
  return 1
}

##//! Flow tracing of the session

##/*!
## Just for debugging or efficiency considerations.
##*/

trace()
{
  local ret

  if [ ${FLOW_TRACE:-f} = f ] ; then
    eval $*
    return $?
  fi

  trc_curr_depth=$(( trc_curr_depth + 1 ))

  local i j index str t0 t1 token count

  # estimating trace itself
  t0=$(unixTime.x dec)

  count=0
  while [ $count -lt 5 ] ;  do  # a workaround for erroneous expr exit value
  # find the function name, perhaps embedded
  if expr match "$*" '[[:alpha:]]*=' &> /dev/null ; then
    # variabel=( $(fnctName ... )
    token=$( expr match "$1" '[[:alpha:]]*=*[^[:alpha:]]*\([[:alpha:]]\+\)' )
  elif expr match "$*" '[^[:alpha:]]' &> /dev/null ; then
    # $(fnctName ... )
    token=$( expr match "$*" '[^[:alpha:]]*\([[:alpha:]]\+\)' )
    test ${#token} -eq 0 && token="$1"
  else
    token="$1"  # a plain function was called
  fi

    count=$(( count + 1 ))
    test ${#token} -gt 1 && break
  done;

  for(( index=0 ; index < ${#trc_name[*]} ; ++index )) ; do
    test ${trc_name[index]} = trc_${token} && break
  done

  if [ ${index} = ${#trc_name[*]} ] ; then
    trc_name[$index]=trc_${token}
    trc_time[$index]=0.
    trc_count[$index]=0
    trc_depth[$index]=$trc_curr_depth
  fi

  t1=$(unixTime.x dec 2> /dev/null)
  trc_time[0]=\
$(echo "${trc_time[0]} + $t1 - $t0 - $traceCalibTime" \
   | bc -l 2> /dev/null)
  trc_count[0]=$(( trc_count[0] + 1 ))

  # time measurement of called function
  t0=$(unixTime.x dec)
  eval $*
  ret=$?
  t1=$(unixTime.x dec)

  trc_time[$index]=\
$(echo "${trc_time[$index]} + $t1 - $t0 - $traceCalibTime" | bc -l 2> /dev/null)
  trc_count[$index]=$(( trc_count[$index] + 1 ))
  trc_depth[$index]=$trc_curr_depth

  trc_curr_depth=$(( trc_curr_depth - 1 ))

  test ${FLOW_TRACE_EXIT:-f} = t && exit

  return $ret
}

traceCalibration()
{
  local prg

  if [ ${HOSTNAME} = surge ] ; then
    prg="${QC_SRC}/bin/unixTime.x dec"
  elif [ ${HOSTNAME:0:3} = liz ] ; then
    prg="${QC_SRC}/bin_l/unixTime.x dec"
  elif [ ${HOSTNAME:0:4} = pass ] ; then
    prg="${QC_SRC}/bin_p/unixTime.x dec"
  elif [ ${HOSTNAME:0:4} = bliz ] ; then
    prg="${QC_SRC}/bin_b/unixTime.x dec"
  else
    echo "traceCalibration: executable unixTime.x not found"
    exit
  fi

  local t0 t1

  traceCalibTime=0
  trc_curr_depth=0

  t0=$( $prg )
  trace :
  t1=$( $prg )

  traceCalibTime=$(echo "${t1} -${t0}" | bc -l 2> /dev/null)
  traceStartTime=$( $prg )

  return
}

tracePrint()
{
  # part of the elapsed time used in trace itself will be removed

  local i j tab resid sum out total sz
  sum=0.
  out=qc_flowtrace.lst

  total=$(unixTime.x dec)
  total=$(echo "$total - ${traceStartTime}" | bc -l 2> /dev/null )

  echo -e "Function\t\tdepth\tcount\ttime [s]" > $out
  echo -e "--------\t\t-----\t---------------" >> $out

  sz=${#trc_name[*]}

  # accumulated time [%]
  for(( i=1 ; i < sz ; ++i )) ; do
    # skip secondary processes
    test ${trc_depth[i]} -gt 1 && continue

    sum=$(echo "$sum + ${trc_time[i]}" | bc -l 2> /dev/null )
  done

  # residual time
  local tmp
  tmp=$(echo "$total - ${sum}" | bc -l )
  trc_time[${#trc_time[*]}]=$tmp

  # elapsed time
  trc_time[${#trc_time[*]}]=${total}

  # position of the decimal point of the accumulated times
  local pre
  pre=0
  for(( i=1 ; i < ${#trc_time[*]} ; ++i )) ; do
     for((j=0 ; j < ${#trc_time[i]} ; ++j )) do
       if [ "${trc_time[i]:j:1}" = '.' ] ; then
         test $j -gt $pre && pre=$j
         break
       fi
     done
  done

  # formatting of the acc. times
  local trm
  trm=6
  for(( i=1 ; i < ${#trc_time[*]} ; ++i )) ; do
     for((j=0 ; j < ${#trc_time[i]} ; ++j )) do
       if [ "${trc_time[i]:j:1}" = '.' ] ; then
         # trim decimal digits
         trc_time[$i]=${trc_time[i]:0:$(( j + trm))}
         local k
         for(( k=0 ; k < pre - j ; ++k )) ; do
           trc_time[$i]=" ${trc_time[i]}"
         done
         break
       fi
     done
  done

  for(( i=1 ; i < sz ; ++i )) ; do
    if [ ${#trc_name[i]} -lt 12 ] ; then
      tab='\t\t\t'
    elif [ ${#trc_name[i]} -lt 20 ] ; then
      tab='\t\t'
    else # [ ${#trc_name[i]} -lt 28 ] ; then
      tab='\t'
    fi

    echo -e -n "${trc_name[i]:4}"       >> $out
    echo -e -n "${tab}${trc_depth[i]}"  >> $out
    echo -e -n "\t${trc_count[i]}"      >> $out
    echo -e   "\t${trc_time[i]}"        >> $out

  done

  echo -e "--------\t\t \t----------------" >> $out
  tab='\t\t'

  echo -e "residual time${tab}\t\t${trc_time[sz]}" >> $out

  echo -e "elapsed time${tab}\t\t${trc_time[$((sz+1))]}" >> $out
}

##//! Command launcher

##/*!
## Several commands are passed to this launcher making processing
## more robust against interruptions of the file system.
##*/

tryCom()
{
  test ${#DEBUG_MANAGER} -eq 0 && pauseX

  # leading options:
  # a) return the status after trying:   get_status
  # b) set temporary sleep period:       set_sleep
  # c) set temporary REATTEMPT_LIMIT:    set_limit

  # $*:   command [with args]

  # Examples:
  # 1) tryCom 'eval echo -e qcDKRZ.${2} >> qwer/qwer'
  # 2) for f in $(tryCom ls -d *) ; do ... ; done
  # 3) tryCom 'eval echo -e qcDKRZ.${2} >> qwer/qwer'
  # There is a dependency on bash's "noglob" setting

  local i arg tCStatus
  local countAttempts=0
  local n_shift=0

  local limits=$REATTEMPT_LIMIT
  local t_slice=$SLEEP_TIME
  local getStatus=f

  for(( i=1 ; i <= $# ; ++i )) ; do
    arg=${!i}
    if [ "${arg}" = 'get_status' ] ; then
       getStatus=t
       n_shift=$(( n_shift + 1 ))
       continue
    elif [ "${arg:0:10}" = 'set_limit=' ] ; then
       limits=${arg#*=}
       n_shift=$(( n_shift + 1 ))
       continue
    elif [ "${arg:0:10}" = 'set_sleep=' ] ; then
       t_slice=${arg#*=}
       n_shift=$(( n_shift + 1 ))
       continue
    else
      break
    fi
  done

  test ${n_shift} -gt 0 && shift ${n_shift}

  local retVal

  while : ; do
    $* 2> /dev/null # execute the command

    tCStatus=$?
    if [ $tCStatus -eq 0 ] ; then
      retVal=0
      break
    fi

    # for a configuration defined period
    if [ $((countAttempts++)) -lt $limits ] ; then
       sleep $t_slice
       continue
    fi

    # number of allowed attempts exceeded.

    # it is ok to have failed, so just return
    if [ ${getStatus} = t ] ; then
      retval=$tCStatus
      break
    fi

    # Try a last time to get the error message.
    local failed
    failed="$( $* 2>&1 )"

    # for instance rm returns an error text with embedded ` and '
    failed=$( echo "$failed" | sed 's%`%%g' |sed "s%'%%g")

    std_out add "Failed command in qcDKRZ: $*"
    std_out add "\n${failed}"

    sendSubject="command failed after ${limits} reattempts"
    std_out flush

    finally

    retVal=1
    break
  done

  test ${#DEBUG_MANAGER} -eq 0 && pauseX
  return $retVal
}

wait_fnct()
{
  test ${SHOW_CALL:-f} = t && return

  # a getSelectedPath process is still running; kill it
  if ps -p ${getPathPID:-0} -o pid= &> /dev/null  ; then
     kill -9 $getPathPID &> /dev/null
     wait $getPathPID &> /dev/null
  fi

  local count=0
  local i isAnyAlive

  while : ; do

    isAnyAlive=f

    for(( i=0 ; i < nFmax ; ++i )) ; do
       # skip pipe with a running job
       if [ ${nF_PID[i]} -gt 0 ]  ; then
         if ps -p ${nF_PID[i]} -o pid= &> /dev/null  ; then
           # there is still an active job for this fBase
           isAnyAlive=t
           sleep 1

           if [ ${isTERM:-f} = t -o $((count++)) -gt 1000 ] ; then
             # kill immediately of after a while
             kill -TERM ${nF_PID[i]} &> /dev/null
             wait ${nF_PID[i]} &> /dev/null
           fi
         fi
       fi
    done

    test $isAnyAlive = f && break
  done

  return
}

##//! Determine the path to QC-0.4/scripts from $0

xtractSrcPath()
{
  # Note: each executable invoked on a bash command-line
  # gets its name in parameter $0, which is available
  # in functions.

  if [ ${#QC_SRC} -eq 0 ] ; then
    # init
    if [ ${0:0:1} = '/' ] ; then
      QC_SRC=${0%/*}
    else
      QC_SRC=$(pwd)/${0%/*}
    fi

    qcDKRZ=${0##*/}
  fi

  if [ -h $QC_SRC/$qcDKRZ ] ; then

    QC_SRC=$(ls -l $QC_SRC/${qcDKRZ} | awk  '{print $(NF)}')
    qcDKRZ=${QC_SRC##*/}
    QC_SRC=${QC_SRC%/*}

    xtractSrcPath

  else

    # resolve .. and .
    local arr=( ${QC_SRC//\// } )

    # any //, ., or .. in the middle of QC_SRC?
    local i j sz
    sz=${#arr[*]}

    for(( i=1 ; i < sz ; ++i )) ; do
      j=$((i-1))

      if [ "${arr[i]}" = '/' -a "${arr[j]}" = '/' ] ; then
        unset arr[j]
      elif [ "${arr[i]}" = '.' ] ; then
        unset arr[i]
      elif [ "${arr[i]}" = '..' ] ; then
        while [ ${#arr[j]} -eq 0 ] ; do
          j=$((j-1))
        done
        unset arr[j]
        unset arr[i]
      fi
    done

    # get rid of empty items
    arr=( ${arr[*]} )

    sz=${#arr[*]}
    QC_SRC=

    for(( i=0 ; i < sz ; ++i )) ; do
      QC_SRC=${QC_SRC}/${arr[i]}
    done
  fi

  local tmp
  while [ "${QC_SRC}" != "${QC_SRC%/*}" ] ; do
    tmp=${QC_SRC##*/}
    test ${tmp:0:3} = 'QC-' && return

    QC_SRC=${QC_SRC%/*}
  done

  local str
  str="\nThis script was executed from out-side of the QC package."
  str="${str}\nIt was probably copied or hard-linked. Please, use a"
  str="${str}\nsymbolic link or call directly from /path/QC-package/scripts"

  echo -e -n "${str}" > $TTY

  exit
}

##//! Entry to this script

##/*!
## Definition of traps, init() and check().
##*/

##main()
##{
######## main ############
umask 002

# store the tty, if any
if tty -s ; then TTY=$(tty) ; fi

# test for nohup

#sleep 10

QC_CONFIGURATOR=qcConfiguration
QC_EXECUTOR=qcExecution

rootPID=$$

#extract the path to QC from $0
# get execution path of QC scripts
xtractSrcPath

init $*

test ${FLOW_TRACE:-f} = t && traceCalibration

trap terminate TERM
trap finally EXIT

test ${SHOW_EXP:-f} = t  && getAllExps && exit

### the inifinit loop: over all experiments again and again ####
check

##}
