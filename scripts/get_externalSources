ges_cf()
{
   local org=http://cfconventions.org

   ges_cf_html

   return $?
}

ges_cf_html()
{
  local status=0

  # htmnl page containing access to cf related tables
  local html=standard-names.html
  wget -q -N $org/$html

  if [ ! -f ${file} ] ; then
    err[${#err[*]}]="failed wget -N $org/$html"
    return 41
  fi

  if ! ges_parse_html "Standard Name Table" xml ; then
    return $?
  fi

  if ! ges_parse_html "Area Type Table" xml ; then
    return $?
  fi

  if ! ges_parse_html "Standardized Region List" html ; then
    return $?
  fi

  return 0
}

ges_convert_html2txt()
{
  if [ "${2}" = "Standardized Region List" ] ; then
    if ! ges_convert_html2txt_region "$1" ; then
       return $?
    fi
  fi

  return 0
}

ges_convert_html2txt_region()
{
  local htmlFile=${1}
  local txtFile=CF_${1%html}txt

  if [ -f ${txtFile} ] ; then
    local h_date=$(ls -l --time-style='+%Y%m%d' ${htmlFile} | awk '{print $6}')
    local t_date=$(ls -l --time-style='+%Y%m%d' ${txtFile} | awk '{print $6}')

    test ${h_date} -lt ${t_date} && return 0
  fi

  # convert html to plain text

  rm -f ${txtFile}
  isSearchBeg=t
  local txt
  while read line ; do
    txt=
    for(( i=0 ; i < ${#line} ; ++i )) ; do
      if [ ${isSearchBeg} = t ] ; then
        test "${line:i:4}" = '</p>' && isSearchBeg=f
        continue
      fi

      # rm leading
      test "${line:i:1}" = ' ' && continue
      test "${line:i:6}" = '</div>' && return 0
      if [ "${line:i:1}" = '<' ] ; then
        echo "${txt}" >> ${txtFile}
        txt=
        continue 2
      fi

      txt=${txt}"${line:i:1}"
    done
  done < ${htmlFile}

  return 0
}

ges_convert_xml2txt()
{
  if [ "${2}" = "Area Type Table" ] ; then
    ges_convert_xml2txt_area "$1"
  fi

  return 0
}

ges_convert_xml2txt_area()
{
  local xmlFile=${1}
  local txtFile=CF_${1%xml}txt

  if [ -f ${txtFile} ] ; then
    local h_date=$(ls -l --time-style='+%Y%m%d' ${xmlFile} | awk '{print $6}')
    local t_date=$(ls -l --time-style='+%Y%m%d' ${txtFile} | awk '{print $6}')

    test ${h_date} -lt ${t_date} && return 0
  fi

  # convert html to plain text

  rm -f ${txtFile}
  local txt
  while read line ; do
    for(( i=0 ; i < ${#line} ; ++i )) ; do
      # rm leading blanks
      test "${line:i:1}" = ' ' && continue

      if [ "${line:i:10}" = '<entry id=' ] ; then
        line=${line#*=}
        line=${line:1:$((${#line}-3))}
        echo "${line}" >> ${txtFile}

        continue 2
      fi

      break  #get next line
    done
  done < ${xmlFile}

  return 0
}

ges_parse_html()
{
  local table="$1"
  local type=$2

  # extract the relative path to the latest version
  local line="$(grep -A 3 "$table" $html | grep $type)"
  local i cf_table_name
  local isSearchBeg=t

  for(( i=0 ; i < ${#line} ; ++i )) ; do
    if [ ${isSearchBeg} = t ] ; then
      test "${line:i:1}" = '"' && isSearchBeg=f

      continue
    fi

    test "${line:i:1}" = '"' && break

    cf_table_name=${cf_table_name}"${line:i:1}"
  done

  if [ ${#cf_table_name} -eq 0 ] ; then
    err[${#err[*]}]="grep failed to find string ${table} in file $html"
    return 41
  fi

  if [ ${#cf_table_name} -gt 0 ] ; then
    if ! wget -q -N $org/${cf_table_name} ; then
      err[${#err[*]}]="failed wget -q -N $org/${cf_table_name}"
      return 41
    fi
  fi

  if [ ${cf_table_name##*.} = html ] ; then
    ges_convert_html2txt ${cf_table_name##*/} "${table}"
  elif [ ${cf_table_name##*.} = xml ] ; then
    ges_convert_xml2txt ${cf_table_name##*/} "${table}"
  fi

  return $?
}

ges_cmip6()
{
   local status=0

   if [ ! ${XLSX2CSV} ] || [ ! -f "${XLSX2CSV}" ] ; then
     if ! ges_xlsx2csv ; then
        status=$?
     fi
   fi

   if [ ! ${PrePARE} ] ; then
     isForceUp=t
   elif [ ! ${UDUNITS2_XML_PATH} ] ; then
     isForceUp=t
   fi

   if [ "${LAST_CMIP6_UPDATE}" != $today -o ${isForceUp:-f} = t ] ; then
     if ! ges_cmip6_mip ; then # non-cmor tables
       status=$?
     fi

     if ! ges_cmip6_conda ; then
          status=$?
     fi

     if ! ges_cmip6_cmor ; then
        status=$?
     fi
   fi

   return $status
}

ges_cmip6_cmor()
{
   # Clone the CMIP6 table to your working directory.
   # Disable SSL verification (firewall only).

   cd ${QA_HOME}/tables/projects/CMIP6/cmip6-cmor-tables &> /dev/null

   if [ -d ${QA_HOME}/tables/projects/CMIP6/cmip6-cmor-tables ] ; then
     #look for an update

     local remote
     declare -a remote
     remote=( $( git remote -v ) )
     if [ ${remote[1]##*/} = 'cmip6-cmor-tables.git' ] ; then
       git fetch &> log_cmip6-cmor-tables.txt \
       && git reset --hard origin/master &> log_cmip6-cmor-tables.txt
     fi
   else
     git clone https://github.com/PCMDI/cmip6-cmor-tables.git &> log_cmip6-cmor.txt
   fi

   local status=$?

   if [ $status -gt 0 ] ; then
     cat log_cmip6-cmor-tables.txt > ${TTY}
   fi

   cd - &> /dev/null

   return $status
}

ges_cmip6_conda()
{
  local conda_path
  local conda_env
  local action isNewConda

  if [ ${PrePARE} ] ; then
    action=update
    conda_path=${PrePARE%/*}
  elif [ ${CONDA_QA_PATH} ] || conda_path=$(which conda 2> /dev/null) ; then
    # look for existing miniconda with a cmor installation
    inqRunEnv funct=iRE_scanCondaEnv PrePARE.py
    inqRunEnv funct=iRE_scanCondaEnv udunits2.xml

    if [ ${#PrePARE} -gt 0 -a ${UDUNITS2_XML_PATH} -gt 0 ] ; then
      action=update
      conda_env=${CONDA_CMOR_ENV}
      test ! ${conda_path} && conda_path=${CONDA_QA_PATH}
    else
      action=create
      conda_path=${CONDA_QA_PATH}
    fi
  else
    # e.g. for a conda-less instantiation;
    # sets conda_path
    action=create
#    ges_make_miniconda

    conda_path=${QA_HOME}/miniconda
    isNewConda=t
  fi

  if [ ${action} = create ] ; then
     local prompt_text
     echo -e "\nCMIP6 requires conda for running CMOR." > ${TTY}
     if [ ${isNewConda} ] ; then
       prompt_text=" <yes: in ${conda_path%/bin}, [no]>: "
     else
       echo -e "\nDifferent installation modes are available:" > ${TTY}
       echo    "    <a> environment of its own (original) " > ${TTY}
       echo    "    <b> environment of qa-dkrz " > ${TTY}
       echo    "    <c> a separate miniconda instantiated in the user-space" > ${TTY}
       echo    "    <no> exit"
       prompt_text="Select: <a, b, c: in [${QA_HOME}/miniconda], or user-defined-path, [no]>: "
     fi

     local quest

     while : ; do
       read -p "${prompt_text}"  quest 2> ${TTY}

       case ${quest:0:1} in
         ( n |  '') exit 41  ;;
         (       a) conda_env=cmor  ;;
         (       b) conda_env=qa-dkrz  ;;
         (       c) conda_path=${QA_HOME}/miniconda
                    isNewConda=t
                    ;;
         *) if [ ${quest:0:1} != '/' ] ; then
              echo "Please, provide absolute path (in case of no typo)" > ${TTY}
              continue
            else
              conda_path=${quest}
              isNewConda=t
            fi
            ;;
       esac

       break
     done
  fi

  conda_path=${conda_path%/miniconda*}/miniconda

  test ${isNewConda} && ges_make_miniconda ${conda_path}

  if [ ${conda_path} ] ; then
    if update_CONDA "${CONDA_CMOR_NAME}" "${CONDA_CMOR_CHANNELS}" \
                    "${conda_path}" ${conda_env:-cmor} ${action} ; then

      . ${QA_SRC}/scripts/parseConfigFile LAST_CONDA_CMOR_UPDATE=$today
      . ${QA_SRC}/scripts/parseConfigFile CONDA_CMOR_ENV=${conda_env:-cmor}
      return 0
    fi
  fi

  return 41
}

ges_cmip6_mip()
{
   local curPWD=$(pwd)

   mkdir -p ${QA_HOME}/tables/projects/CMIP6
   cd ${QA_HOME}/tables/projects/CMIP6 &> /dev/null

   wget -l1 -N -np  \
      http://proj.badc.rl.ac.uk/svn/exarch/CMIP6dreq/tags/latest/dreqPy/docs/CMIP6_MIP_tables.xlsx \
      &>> log_cmip6_tables.txt

   if [ $? -gt 0 ] ; then
      err[${#err[*]}]="wget CMIP6_MIP_tables.xlsx from http://proj.badc.rl.ac.uk"
      cd - &> /dev/null
      return 41
   fi

   # location of extracted csv table sheets: [~/.qa-dkrz/tables/projects/CMIP6]
   ${XLSX2CSV} -a -d '|' -l '\n' CMIP6_MIP_tables.xlsx CMIP6_MIP_tables

   # the CMIP6 json files
   if [ -d CMIP6_CVs ] ; then
     cd CMIP6_CVs

     if [ "$(ges_getGitBranch)" != master ] ; then
       git checkout master &> /dev/null
     fi

     git fetch && git reset --hard origin/master &>> log_cmip6_tables.txt
   else
     git clone https://github.com/WCRP-CMIP/CMIP6_CVs &>> log_cmip6_tables.txt
   fi

   local status=$?

   if [ $status -gt 0 ] ; then
      err[${#err[*]}]="git failed for CMIP6_CVs from https://github.com/WCRP-CMIP"
   fi

   return $status
}

ges_cordex()
{
   local status

   if ! mkdir -p $QA_HOME/tables/projects/$prj ; then
     mkdir -p $1
     return 41
   fi

   cd $QA_HOME/tables/projects/$prj

   if [ -d IS-ENES-Data.github.io ] ; then
     cd IS-ENES-Data.github.io

     if [ "$(ges_getGitBranch)" != master ] ; then
       git checkout master &> /dev/null
     fi

     local remote
     remote=( $( git remote -v ) )
     if [ ${remote[1]##*/} = 'IS-ENES-Data.github.io' ] ; then
       git fetch &>> log_cordex_tables.txt \
       && git reset --hard origin/master &>> log_cordex_tables.txt
       status=$?
     fi
   else
     git clone https://github.com/IS-ENES-Data/IS-ENES-Data.github.io \
       &>> log_cordex_tables.txt
     status=$?

     ln -sf IS-ENES-Data.github.io/CORDEX_RCMs_ToU.txt CORDEX_RCMs_ToU.txt
   fi

   if [ $status -gt 0 ] ; then
     err[${#err[*]}]="git failed for IS-ENES-Data.github.io"
   fi

   return ${status}
}

ges_getGitBranch()
{
   git branch | grep '*' | awk '{print $2}'
   return 0
}

ges_make_miniconda()
{
   test ${PrePARE} && return 0

   local path quest
   path=${1%/bin}
   path=${path%/miniconda}

   # look for a conda installation. Is conda in PATH?
   echo    "miniconda: 'yes' would approve the '3-clause BSD License'!" > ${TTY}

   local isRead

   while : ; do
     read -p "  <yes: in ${path}/miniconda, r: read license, [no]>: " \
          quest 2> ${TTY}

     case $quest in
       ( y | yes)  ;;
       ( no | '') return 41  ;;
       r) isRead=t ;;
       *) continue ;;
     esac

     if mkdir -p ${path} ; then
        cd ${path}
     else
        return 41
     fi

     if [ ! -f Miniconda-latest-Linux-x86_64.sh ] ; then
       wget -l1 -N -np \
          https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh
     fi

     if [ ${isRead:-f} = t ] ; then
       bash Miniconda-latest-Linux-x86_64.sh  > ${TTY} << EOF

no
EOF
       continue
     fi

     if ! bash Miniconda-latest-Linux-x86_64.sh -b -p ${conda_path} \
           &> /dev/null ; then

        if [ ! -w ${conda_path/miniconda} ] ; then
           err[${#err[*]}]="failed bash Miniconda-latest-Linux-x86_64.sh -b -p ${conda_path}/miniconda"
           return 41
        fi
        fi

     break
   done

   return 0
}

ges_xlsx2csv()
{
   local xc=$QA_HOME/xlsx2csv/xlsx2csv.py

   if [ ! -f $xc ] ; then
      git clone http://github.com/dilshod/xlsx2csv &>> log_install_xlsx2csv.txt

      if [ $? -gt 0 ] ; then
        err[${#err[*]}]="git failed for xlsx2csv"
        return 41
      fi
   fi

    # new or restored entry in the config file
   . $QA_SRC/scripts/parseConfigFile XLSX2CSV=$xc
   XLSX2CSV=$xc

   return 0
}


# main
declare -a err

while getopts hP:-: option
do
  case $option in
    h)  ;;
    P)  prj=${OPTARG} ;;
    -) if [ ${OPTARG%=*} = "config_file" ] ; then
         CONFIG_FILE=${OPTARG#*=}
#         elif [ ${OPTARG} == 'debug' ] ; then
#           set -x
       elif [ ${OPTARG} == 'force-update' ] ; then
         isForceUp=t
       elif [ ${OPTARG%=*} = "qa-home" ] ; then
         QA_HOME=${OPTARG#*=}
       elif [ ${OPTARG%=*} = "qa-src" ] ; then
         QA_SRC=${OPTARG##*=}
       fi
       ;;
   \?) echo "get_externalSources: undefined option $option"
       return 41 ;;
  esac
done

if [ ! ${QA_HOME} ] ; then
  echo "could not cd ${HOME}"
  return 41
fi

cd $QA_HOME &> /dev/null

# search for updates only once a day
test !${today} && today=$( date '+%Y%m%d' )

# Note that CF may-be stand-alone or together with another project
if [ ! \( "${LAST_CF_UPDATE}" = $today -a ${isForceUp:-f} = f \) ] ; then
  #. $QA_SRC/scripts/parseConfigFile LAST_CF_UPDATE
  #if [ ! \( "${LAST_CF_UPDATE}" = $today -a ${isForceUp:-f} = f \) ] ; then
     if ges_cf ; then
       . $QA_SRC/scripts/parseConfigFile LAST_CF_UPDATE=$today
     else
       return 41
     fi
  #fi
fi

ges_pLU=LAST_${prj}_UPDATE
test "${!ges_pLU}" = $today -a ${isForceUp:-f} = f && return 0

#if [ ! \( "${!ges_pLU}" = $today -a ${isForceUp:-f} = f \) ] ; then
#  . $QA_SRC/scripts/parseConfigFile ${!pLU}

#  test "${!pLU}" = $today -a ${isForceUp:-f} = f && return 0
#fi
status=0

if [ "$prj" = CORDEX ] ; then
  if ! ges_cordex ; then
    status=$?
  fi
elif [ "$prj" = CMIP6 ] ; then
  if ! ges_cmip6 ; then
    status=$?
  fi
fi

if [ ${#err[*]} -gt 0 ] ; then
   for(( k=0 ; k < ${#err[*]} ; ++k )) ; do
      echo -e "${err[k]}"
   done

   return 41
fi

test ${status} -eq 0 && \
   . $QA_SRC/scripts/parseConfigFile LAST_${prj}_UPDATE=${today}

return 0
