# get the state of the current QA-DKRZ installation

iRE_checkForUpdate()
{
  # 1st run on this day?
  local isUp=0 val
  test !${today} && today=$( date '+%Y%m%d' )

  for(( i=0 ; i < ${#name[*]} ; ++i )) ; do
    val=${value[i]}

    if [ ${val:-f} = f -a ${rname[i]} = '+' ] ; then
         isUp=1
         break
    elif [ ! ${isRO} ] ; then
      if [ "${val:0:2}" = '20' ] ; then
         if [ ${val} -lt $today ] ; then
            isUp=1
            break
         fi
      fi
    fi
  done

  if [ ${isCMIP6} ] ; then
    if [ ${PrePARE:-f} = f -o ${XLSX2CSV:-f} = f  \
                    -o ${UDUNITS2_XML_PATH:-f} = f ] ; then
       isUp=1
    fi
  fi

  return $isUp
}

iRE_inqState()
{
  local isRO
  if [ "${1}" = '--read-only' ] ; then
    isRO=t
    shift 1
  fi

  local prj
  declare -a prj
  if [ $# -gt 0 ] ; then
    prj=($*)
  fi

  local retVal  # no updates
  declare -i retVal=0

  local i name rname reqCount value
  declare -a name rname value
  declare -i reqCount=0

  # First char of names indicate whether optional (-) or required (+)
  # as to must-have names working also in case of a non-update option (default)
  rname=(
         -AUTO_UPDATE \
         -DEFAULT_PROJECT \
         -INTERNET \
         -LAST_QA_UPDATE \
         +QA_HOME \
         +QA_REVISION \
       )

  # extend for CONDA installation
  if [ ${CONDA_QA_PATH} ] ; then
    rname[${#rname[*]}]=-CONDA_QA_PATH
    rname[${#rname[*]}]=-LAST_CONDA_QA_UPDATE
    rname[${#rname[*]}]=+CONDA_QA_ENV
  fi

  # extend for current projects
  for(( i=0 ; i < ${#prj[*]} ; ++i )) ; do
    rname[${#rname[*]}]=-LAST_${prj[i]}_UPDATE

    if [ ${prj[i]} = CMIP6 ] ; then
      isCMIP6=t
      rname[${#name[*]}]=+PrePARE
      rname[${#rname[*]}]=+UDUNITS2_XML_PATH
      rname[${#rname[*]}]=+XLSX2CSV
      rname[${#rname[*]}]=+CONDA_CMOR_ENV
    fi
  done

  # count mandatory names and convert to plain requirements and names, respectively
  for(( i=0 ; i < ${#rname[*]} ; ++i )) ; do
    test ${rname[i]:0:1} = '+' && reqCount+=1
    name[i]=${rname[i]:1}
    rname[i]=${rname[i]:0:1}
  done

  # read configuration setting
  iRE_readConfigFile

  # read configuration setting
  if ! iRE_checkForUpdate ; then
    retVal+=1
  fi

  test ${isRO:-f} = t -o ${retVal} = 0 && return ${retVal}

  test ${iRE_RestoreApproval} && return ${retVal}

  # try to restore some lost config-file items
  iRE_scanCondaEnv qa-dkrz
  iRE_scanCondaEnv PrePARE.py
  iRE_scanCondaEnv udunits2.xml

  # revison num of the package
  local packRec
  getRevNum packRev

  . ${QA_SRC}/scripts/parseConfigFile QA_REVISION${packRev:+=}${packRev}

  iRE_RestoreApproval=t

  iRE_inqState ${iRE_CallParam[*]}
  retVal=$?

  return ${retVal}
}

iRE_readConfigFile()
{
  local count i
  declare -i count=0

  for(( i=0 ; i < ${#name[*]} ; ++i )) ; do
    if . ${QA_SRC}/scripts/parseConfigFile ${name[i]} ; then
       value[i]=${!name[i]}

       if [ ${rname[i]} = '+' -a ${#value[i]} -eq 0 ] ; then
          echo "missing feature: ${name[i]}"
       else
          count+=1
       fi
    fi
  done

  # retVal > 9 indicates at least one missing required config-file entry
  test ${count} -lt ${reqCount} && retVal=$(( retVal + 10 ))

  return
}

iRE_scanCondaEnv()
{
  if [ $1 = qa-dkrz ] ; then
    test ! ${CONDA_QA_PATH} && return  # not installed by conda
    test ${CONDA_QA_ENV} && return
  else
    test ! ${isCMIP6} && return

    if [ $1 = PrePARE.py ] ; then
      if [ ! \( ${CONDA_CMOR_ENV:-f} = f -o ${XLSX2CSV:-f} = f \
                   -o ${PrePARE:-f} = f \) ] ; then
        return
      fi
    else
      test ${UDUNITS2_XML_PATH} && return
    fi
  fi

  local path fs
  declare -a fs

  # find installation path
  if [ "$1" = qa-dkrz ] ; then
    path=${CONDA_QA_PATH%%/miniconda*}/miniconda
  else
    if [ ${PrePARE} ] ; then
      path=${PrePARE%/miniconda*}/miniconda
    else
      # try possible known locations for the existance of PrePARE.x
      if [ ${CONDA_QA_PATH} ] ; then
        # in the QA-DKRZ sources installed by conda
        fs=( $( find ${CONDA_QA_PATH%%/miniconda*}/miniconda -type f -name $1 2> /dev/null ) )
      else
        # in already specified QA_HOME
        fs=( $( find ${QA_HOME%%/miniconda*}/miniconda -type f -name $1 2> /dev/null ) )
        if [ ${#fs[*]} -eq 0 ] ; then
          # in QA-DKRZ installed from GitHub
          fs=( $( find ${QA_SRC%%/miniconda*}/miniconda -type f -name $1 2> /dev/null ) )
        fi
      fi

      # bad luck when there would be more than a single one if any.
      if [ ${#fs[*]} -gt 0 ] ; then
        path=${fs[0]%%/miniconda*}/miniconda
      fi
    fi
  fi

  test ! ${path} && return 0

  local x xx f fs t0 t1

  # not only for the envs, but also for PrePARE and udunits2 if any

  for x in $* ; do
    fs=( $( find ${path}/envs -name $x 2> /dev/null ) )

    if [ ${#fs[*]} -gt 0 ] ; then
      if [ $x = qa-dkrz ] ; then
        CONDA_QA_ENV=t
      elif [ $x = PrePARE.py ] ; then
        CONDA_CMOR_ENV=t
      fi
    else
      # try for the root env
      fs=( $( find ${path} -name $x ) )
    fi

    test ${#fs[*]} -eq 0 && continue

    f=${fs[0]}
    t0=$( ls -l --time-style='+%s' ${fs[0]} | awk '{print $6}')

    xx=${fs[0]}

    for(( i=1 ; i < ${#fs[*]} ; ++i )) ; do
      t1=$( ls -l --time-style='+%s' ${fs[0]} | awk '{print $6}')
      if [ $t1 -gt $t0 ] ; then
         t0=t1
         xx=${fs[i]}
      fi
    done

    if [ $x = qa-dkrz ] ; then
      if [ ${CONDA_QA_ENV:-f} = t  ] ; then
        t0=${f%%/envs/*}/envs/
        t0=${f#${t0}}
        CONDA_QA_ENV=${t0%%/*}
      else
        CONDA_QA_ENV=none
      fi

      . ${QA_SRC}/scripts/parseConfigFile CONDA_QA_ENV=${CONDA_QA_ENV}
    elif [ $x = PrePARE.py ] ; then
      if [ ${CONDA_CMOR_ENV:-f} = t  ] ; then
        t0=${f%%/envs/*}/envs/
        t0=${f#${t0}}
        CONDA_CMOR_ENV=${t0%%/*}
      else
        CONDA_CMOR_ENV=none
      fi

      . ${QA_SRC}/scripts/parseConfigFile CONDA_CMOR_ENV=${CONDA_CMOR_ENV}

      PrePARE=$f
      . ${QA_SRC}/scripts/parseConfigFile PrePARE=$f

    else
      . ${QA_SRC}/scripts/parseConfigFile UDUNITS2_XML_PATH=$f
    fi
  done

  return
}


# main

iRE_CallParam=( $* )

iRE_inqState $*

return $?
