# get the state of the current QA-DKRZ installation

iRE_checkForUpdate()
{
  # 1st run on this day?
  local val
  test ! ${today} && today=$( date '+%Y%m%d' )

  local failedItems
  declare -a failedItems

  for(( i=0 ; i < ${#name[*]} ; ++i )) ; do
    val=${value[i]}

    if [ ${rname[i]:0:1} = '+' -a ${val:-f} = f  ] ; then
         upCount=$(( upCount + 1 ))
         failedItems[${#failedItems[*]}]=${name[i]}

         break
    elif [ ! ${isRO} ] ; then
      if [ "${val:0:2}" = '20' -a ${rname[i]:0:1} = '-' ] ; then
         if ! . ${QA_SRC}/scripts/parseConfigFile ${name[i]} --inquire ; then
            upCount=$(( upCount + 1 ))
            break
         fi
      fi
    fi
  done

  if [ ${#failedItems[*]} -gt 0 -a "${QA_HOME}" ] ; then
    # try to restore missing items in config.txt from QA_HOME
    local item
    for item in ${failedItems[*]} ; do
       if [ ${item} = XLSX2CSV ] ; then
          item=$( find ${QA_HOME} -name xlsx2csv.py )
          if [ ${item} ] ; then
             . ${QA_SRC}/scripts/parseConfigFile XLSX2CSV=$item
             XLSX2CSV=$item
             upCount=$(( upCount -1 ))
          fi
       fi
    done
  fi

  return
}

iRE_checkTables()
{
  local prj=$1

  if [ ! ${QA_HOME} ] ; then
    upCount=$(( upCount + 1 ))
    return
  elif [ ! -d ${QA_HOME}/tables/projects/$prj ] ; then
    upCount=$(( upCount + 1 ))
    return
  else
    local p=${QA_HOME}/tables/projects

    if [ ${#prj} -eq 0 -a ${#DEFAULT_PROJECT} -gt 0 ] ; then
      prj=${DEFAULT_PROJECT}
    fi

    local reqItems
    declare -a reqItems

    if [ "${prj}" = CORDEX ] ; then
      reqItems=( \
        $p/${prj}/CORDEX_DRS_CV.csv \
        $p/${prj}/CORDEX_GCMModelName.txt \
        $p/${prj}/CORDEX_RCMs_ToU.txt \
        $p/${prj}/CORDEX_variables_requirement_table.csv
      )
    elif [ "${prj}" = CMIP6 ] ; then
      reqItems=( \
        $p/${prj}/CMIP6_check-list.conf \
        $p/${prj}/CMIP6_DRS_CV.csv \
        $p/${prj}/CMIP6_CVs \
        $p/${prj}/cmip6-cmor-tables \
        $p/${prj}/CMIP6_MIP_tables
      )
    fi

    # check always CF
    reqItems=( ${reqItems[*]} \
      $p/CF/CF_check-list.conf \
      $p/CF/CF_area-type-table.txt \
      $p/CF/CF_standardized-region-names.txt \
      $p/CF/cf-standard-name-table.xml \
      )

    local rI
    for rI in ${reqItems[*]} ; do
      if [ ! -e ${rI} ] ; then
        upCount=$(( upCount + 1 ))
        break
      fi
    done
  fi

  return
}

iRE_inqState()
{
  upCount=0

  local prj
  declare -a prj
  if [ $# -gt 0 ] ; then
    prj=($*)
  fi

  local i name rname reqCount value
  declare -a name rname value
  declare -i reqCount=0

  # First char of names indicate whether optional (-) or required (+),
  # second by + indicates required and must exist;
  # as to must-have names working also in case of a non-update option (default)
  rname=(
         -AUTO_UPDATE \
         -DEFAULT_PROJECT \
         -INTERNET \
         -NEXT_QA_UPDATE \
         +QA_HOME \
         -QA_REVISION \
       )

if [ ! ${NO_CONDA_INSTALL} ] ; then
  # extend for CONDA installation
  if [ ${CONDA_QA_PATH} ] ; then
    rname[${#rname[*]}]=-CONDA_QA_PATH
    #rname[${#rname[*]}]=+CONDA_QA_ENV
  fi
fi

  # extend for current projects
  for(( i=0 ; i < ${#prj[*]} ; ++i )) ; do
    rname[${#rname[*]}]=-NEXT_${prj[i]}_UPDATE
    rname[${#rname[*]}]=+XLSX2CSV

    if [ ${prj[i]} = CMIP6 ] ; then
      isCMIP6=t

if [ ! ${NO_CONDA_INSTALL} ] ; then
      rname[${#name[*]}]=+PrePARE
#      rname[${#rname[*]}]=+UDUNITS2_XML_PATH
      rname[${#rname[*]}]=+CONDA_CMOR_ENV
      rname[${#rname[*]}]=+CONDA_CMOR_PATH
fi
    fi
  done

  # count mandatory names and convert to plain requirements and names, respectively
  local pos
  for(( i=0 ; i < ${#rname[*]} ; ++i )) ; do
    test ${rname[i]:0:1} = '+' && reqCount+=1
    pos=1
    test ${rname[i]:1:1} = '+' && pos=2
    name[i]=${rname[i]:pos}
    rname[i]=${rname[i]:0:pos}
  done

  # read configuration setting
  iRE_readConfigFile

  iRE_checkForUpdate

  test ${upCount} -eq 0 && iRE_checkTables $*

  test ${isRO:-f} = t -o ${upCount} = 0 && return ${upCount}

if [ ! ${NO_CONDA_INSTALL} ] ; then
  iRE_scanCondaEnv qa-dkrz
  iRE_scanCondaEnv PrePARE
#  iRE_scanCondaEnv udunits2.xml
fi

  # revison num of the package
  local packRec
  ${QA_SRC}/scripts/getVersion packRev

  . ${QA_SRC}/scripts/parseConfigFile QA_REVISION${packRev:+=}${packRev}

  return
}

iRE_readConfigFile()
{
  local count i
  declare -i count=0

  for(( i=0 ; i < ${#name[*]} ; ++i )) ; do
    if . ${QA_SRC}/scripts/parseConfigFile ${name[i]} --inquire ; then
       value[i]=${!name[i]}

       if [ ${rname[i]:0:1} = '+' -a ${#value[i]} -eq 0 ] ; then
          echo "missing feature: ${name[i]}"
       else
          count+=1
       fi
    fi
  done

  return
}

iRE_scanCondaEnv()
{
  local f ix env envs ix_custom ix_env ix_root
  local path paths path_env path_custom path_root env_custom env_env env_root
  local conda_path # could be different for cmor
  declare -a envs paths

  if [ $1 = qa-dkrz ] ; then
    test ! ${CONDA_QA_PATH} && return  # not installed by conda
    test "${CONDA_QA_PATH}" -a "${CONDA_QA_ENV}" && return

    # try to restore some lost config-file items
    if conda_path=$(. ${QA_SRC}/scripts/which.sh conda) ; then
       CONDA_QA_PATH=${conda_path}
    fi
  fi

  if [ $1 = PrePARE ] ; then
    test ! ${CMIP6} && return
    test "${CONDA_CMOR_PATH}" -a "${CONDA_CMOR_ENV}" && return

    # try to restore some lost config-file items
    if [ ! ${PrePARE} ] ; then
      if conda_path=$(. ${QA_SRC}/scripts/which.sh PrePARE) ; then
         PrePARE=${conda_path}
      else
         paths=( $( which conda 2> /dev/null) )

         if [ ${#paths[*]} -gt 0 ] ; then
            # PrePARE is not necessarily in the path;
            # there could be more than a single conda

            for(( f=0 ; f < ${#paths[*]} ; ++f )) ; do
               path=$( find ${paths[f]%/bin/conda} -type f -name "PrePARE" )
               if [ ${path} ] ; then
                 CONDA_CMOR_PATH=${paths[f]}
                 PrePARE=$path
                break
               fi
            done
         elif [ ${CONDA_QA_PATH} ] ; then
            # try a conda path within the qa-dkrz package
            path=$( find ${CONDA_QA_PATH%/bin/conda} -type f -name "PrePARE" )
            test ${path} && PrePARE=$path
         fi
      fi

      test ${conda_path} && CONDA_QA_PATH=${conda_path}
      test CONDA_QA_PATH=$(. ${QA_SRC}/scripts/which.sh conda)
    fi
  fi

  if [ $1 = udunits2.xml ] ; then
    if [ ! ${CMIP6} -o "${UDUNITS2_XML_PATH}" ] ; then
       return
    else
      paths=( $( find ${PrePARE%/bin/PrePARE} -type f -name "udunits2.xml" ) )
      . ${QA_SRC}/scripts/parseConfigFile UDUNITS2_XML_PATH=${paths[0]}
      return
    fi
  fi

  if [ $1 = qa-dkrz ] ; then
     CONDA_QA_ENV=${env}
     . ${QA_SRC}/scripts/parseConfigFile CONDA_QA_ENV=${CONDA_QA_ENV}

     test ${CONDA_QA_PATH} && \
        . ${QA_SRC}/scripts/parseConfigFile CONDA_QA_PATH=${CONDA_QA_PATH}
  elif [ $1 = PrePARE ] ; then
     CONDA_CMOR_ENV=${env}
     . ${QA_SRC}/scripts/parseConfigFile CONDA_CMOR_ENV=${CONDA_CMOR_ENV}

     test ${CONDA_CMOR_PATH} && \
     . ${QA_SRC}/scripts/parseConfigFile CONDA_CMOR_PATH=${CONDA_CMOR_PATH}

     PrePARE=$path
     . ${QA_SRC}/scripts/parseConfigFile PrePARE=${PrePARE}
  fi

  return
}

iRE_inqRunEnv()
{
  local isRO
  local isUp

  local callParam
  declare -a callParam

  local arg
  for arg in $* ; do
    if [ ${arg} = '--read-only' ] ; then
      isRO=t
    else
      callParam[${#callParam[*]}]=$arg
    fi
  done

  iRE_inqState ${callParam[*]}

  if [ ${NO_CONDA_INSTALL} ] ; then
    # check required paths or ENV
    if ! . ${QA_SRC}/scripts/parseConfigFile CONDA_CMOR_ENV ; then
      while : ; do
         read -p "Provide your environment for CMOR: [STOP], string: " \
                CONDA_CMOR_ENV 2> ${TTY}

         case ${CONDA_CMOR_ENV:0:1} in
          '') exit 0  ;;
           *) test ${CONDA_CMOR_ENV} = STOP && exit 0
              CONDA_CMOR_ENV=${CONDA_CMOR_ENV#*=}
              ;;
         esac

         test ${upCount} -gt 0 && upCount=$(( upCount - 1 ))
         break
      done

      if ! . ${QA_SRC}/scripts/parseConfigFile CONDA_CMOR_PATH ; then
        while : ; do
           echo "Provide your path to (CMOR) conda" > ${TTY}
           read -p "<a> CONDA_PATH in use, <[], STOP>, <CONDA_CMOR_PATH>: " \
              CONDA_CMOR_PATH 2> ${TTY}

           case ${CONDA_CMOR_PATH:0:1} in
             '') exit 0  ;;
             a) CONDA_CMOR_PATH=${CONDA_QA_PATH}  ;;
             *) test ${CONDA_CMOR_PATH} = STOP && exit 0
                CONDA_CMOR_PATH=${CONDA_CMOR_PATH#*=}

                if [ ! -f ${CONDA_CMOR_PATH} ] ; then
                   echo "no such directory ${CONDA_CMOR_PATH}"
                   continue
                fi
                ;;
           esac

           test ${upCount} -gt 0 && upCount=$(( upCount - 1 ))
           break
        done
      fi

      if [ -f ${CONDA_CMOR_PATH} ] ; then
        # try the environment
        if ! . ${CONDA_CMOR_PATH%/conda}/activate ${CONDA_CMOR_ENV} ; then
           echo "could not activate your cmor environment; Exit"
           exit 1
        fi

        . ${CONDA_CMOR_PATH%/conda}/deactivate
      fi

      . ${QA_SRC}/scripts/parseConfigFile CONDA_CMOR_PATH=$CONDA_CMOR_PATH
      . ${QA_SRC}/scripts/parseConfigFile CONDA_CMOR_ENV=$CONDA_CMOR_ENV
    fi
  fi

  return $upCount
}

# main

if [ ${1%%=*} = funct ] ; then
  # run a function
  shift 1

  ${1#funct=} $*
  return $?
fi

iRE_inqRunEnv $*

return $?
