#! /bin/bash

package=QA-DKRZ

export CONDA_CMOR_CHANNELS='-c,conda-forge,-c,pcmdi,-c,uvcdat'
export CONDA_QA_CHANNELS='-c,birdhouse,-c,conda-forge,--channel birdhouse/label/dev'

export CONDA_QA_ENV
export CONDA_CMOR_ENV

export CONDA_QA_NAME=qa-dkrz
export CONDA_CMOR_NAME=cmor

hdf5=hdf5-1.8.17
netcdf=netcdf-4.4.1
zlib=zlib-1.2.8
udunits=udunits-2.2.20

default_prj=CORDEX

export CONFIG_FILE=$HOME/.qa-dkrz/config.txt
test ! -f $HOME/.qa-dkrz/config.txt && touch $HOME/.qa-dkrz/config.txt

# options with auto-update feature (option: --auto-up_feature)
#   CMOR_LLNL:     the CMOR checker (D. Nadeau, LLNL)
#   GIT_QA:         all QA updates touching write-protected locations
#   QA_SRC:         QA sources; disabled for conda-installed QA-DKRZ
#   PROJECT_TABLES: Project related tables and programs; PROJECT substituted by
#                   current projects name(s).

descript()
{
  echo "Usage: install [options] [projects[s]]"
  echo "Purpose: Install/update 'the Quality Control Software Package'"
  echo "for checking climate simulation meta-data provided in netCDF format."
  echo "Details at https://redmine.dkrz.de/projectss/cordex/wiki/DKRZ_QC_Tool"
  echo ''
  echo "Options:"
  echo "  -B                Unconditionally re-make all QA executables."
  echo "  -d                Execute 'make' with debugging information."
  echo "  -h                Display usage and exit."
  echo "  --auto-up=expr    Control automatic updates from the repository at the"
  echo "                    beginning of a run. Valid expressions for enabling:"
  echo "                    enable, e, t. Suspending: disable, d, suspend, s."
  echo "  --build           Download and build required libraries."
  echo "  --debug[=scrienv pt]"
  echo "                    Display execution commands. If the name of a script"
  echo "                    is assigned, then debug only this one."
  echo "  --help            Display usage and exit."
  echo "  --home=path       Same as QA_HOME."
  echo "  --link=path       Hard links of external NetCDF installations from the"
  echo "                    directories in 'your-path/${package}/local'."
  echo "                    Shared by all hdf, netcdf, udunits  and zlib."
  echo "  --link_type=path  Same as for 'link' but just for type=netcdf, hdf, zlib, or udunits"
  echo "  --net=bool        Enable or disable internet access for as long as not toggled again."
  echo "  --show-inst       Display properties of the current installation."
  echo "  --up[date]        Update external packages from the repository."
  echo "                    Note: not for netCDF, HDF5, udunits2 or zlib."
  echo "  --up              Update the qa-dkrz package when installed by conda."
  echo "  --qa-home=path    Location of the projects tables and external programs."
  echo "                    Also for user-modified QA tables."
  echo "  --work=path       Same as --qa-home."
  echo ""
  echo "  projects-name(s)   At present CF, CMIP5, and CORDEX; the latter by default."
}

getGitBranch()
{
   git branch | grep '*' | awk '{print $2}'
   return
}

getRevNum()
{
  # get current revision number; this determines whether it is
  # before a change of defaults happened.
  local branch currIdent
  declare -a branch

  if [ $CONDA_QA_PATH ] ; then
    declare -a branch
    if branch=( $(cat ${QA_SRC}/install.log 2> /dev/null) ) ; then
      branch[0]=${branch[0]#*=}
      currIdent=${branch[1]#*=}
    fi
  else
    cd ${QA_SRC} &> /dev/null
    branch[0]=$(getGitBranch)
    currIdent=$(git log --pretty=format:'%h' -n 1)
    cd - &> /dev/null
  fi

  eval ${1}=${branch[0]}-${currIdent}

  return
}

log()
{
  if [ ${isContinueLog:-f} = f ] ; then
    isContinueLog=t

    local logTxt="\n$(date +'%F_%T'):"
    echo -e "${logTxt} install $*" >> install.log
  fi

  return
}

saveAsCycle()
{
  for f in $* ; do
    if [ ! \( -f $f -o -d $f \) ] ; then
      echo "install.saveAsCycle: no such file or directory $f"
      return
    fi

    local ext val x
    local maxVal fs fx

    maxVal=0
    fs=( $(ls -d $f.* 2> /dev/null) )

    for fx in ${fs[*]} ; do
      ext=${fx##*.}

      if val=$(expr match $ext '\([[:digit:]]\+$\)' 2> /dev/null) ; then
        test ${val:-0} -gt ${maxVal} && maxVal=${val}
      fi
    done

    mv $f ${f}.$((++maxVal)) 2> /dev/null
  done
}

tr_option()
{
  local line="${!1}"
  local i pref

#  test "${line:0:1}" != '-' && return

  for(( i=0 ; i < ${#line} ; ++i )) ; do
    if [ ${line:i:1} != - ] ; then
      line=${line:i}
      break
    fi
  done

  local sz
  sz=${#line}

  for((i=0 ; i < sz ; ++i )) ; do
    test "${line:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    if [ ${i} -gt 1 ] ; then
      line=$( echo "${line/% /}" | tr "[:lower:]" "[:upper:]" )
      line=$( echo "${line}" | tr "-" "_" )
    fi
  else
    local tmp0="${line:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    tmp0=$( echo "${tmp0}" | tr "-" "_" )
    line="${tmp0}""${line:i}"
  fi

  eval ${1}=\${line}

  return
}

update()
{
  local project=$1

  # search for updates only once a day
  today=$( date '+%Y%m%d' )

  if [ ${CONDA_QA_PATH} ] ; then
    test ! ${CONDA_QA_ENV} && \
      . ${QA_SRC}/scripts/parseConfigFile CONDA_QA_ENV

    . ${QA_SRC}/scripts/parseConfigFile LAST_CONDA_QA_UPDATE
    if [ "${LAST_CONDA_QA_UPDATE}" != $today ] ; then
      if update_CONDA "${CONDA_QA_NAME}" "${CONDA_QA_CHANNELS}" \
                      "${CONDA_QA_PATH}" "${CONDA_QA_ENV}" ; then

        . ${QA_SRC}/scripts/parseConfigFile LAST_CONDA_QA_UPDATE=$today
        . ${QA_SRC}/scripts/parseConfigFile CONDA_QA_ENV=$CONDA_QA_ENV
      fi
    fi
  else
     if ! update_QA_SRC ; then
       return $?
     fi
  fi

  update_external

  if ! mkdir -p ${QA_HOME}/tables  ; then
    echo "could not mkdir -p ${QA_HOME}/tables"
    exit 41
  fi

  # note that QA_HOME points to .qa-dkrz wherever it is located
  rsync -auz --exclude '*~' $QA_SRC/tables ${QA_HOME} &> /dev/null

  # revison num of the package
  local packRec
  getRevNum packRev

  . ${QA_SRC}/scripts/parseConfigFile QA_REVISION${packRev:+=}${packRev}

  return 0
}

update_CONDA()
{
  local conda_name=$1      # is always defined
  local conda_channels=$2  # is always defined
  local conda_path=$3      # is always defined
  local conda_env=$4       # could be empty
  local action=$5          # could be empty
  local status=1

  test ${conda_env} = none && conda_env=cmor
  test ! ${action} && action=update

  test "${LAST_CONDA_UPDATE}" = ${today} && return
  test ${INTERNET:-t} = f && return
  test "${conda_env}" = '-n ' && conda_env=

  if [ ! -w "${QA_SRC}" ] ; then
    echo "no write-permission for ${QA_SRC}"
    exit 41
  elif [ ${action} = update ] ; then
    # look for a new conda-built package
    echo "searching ${conda_name} updates" > ${TTY}

    set -f
    local tmp
    declare -a tmp
    tmp=( $( ${conda_path}/bin/conda search ${conda_env:+-n ${conda_env}} \
                      ${conda_channels//,/ } \
                      ${conda_name} 2> /dev/null ) ) > ${TTY}

    local i item sz
    sz=${#tmp[*]}
    for(( i=0 ; i < sz ; ++i )) ; do
      if [ "${tmp[i]}" = '*' -o "${tmp[i]}" = '.' ] ; then
        item=${tmp[++i]}
        item=${item}-${tmp[++i]}
        i=$((i+2))

        if [ $i -lt $sz ] ; then
          # there is a newer one
          ${conda_path}/bin/conda ${action} ${conda_env:+-n ${conda_env}} \
                       ${conda_channels//,/ } \
                       ${conda_name} &> ${TTY}
        fi

        status=0
        break
      fi
    done

    set +f
  else
    # only CMOR could here be created
    ${conda_path}/bin/conda ${action} ${conda_env:+-n ${conda_env}} \
            ${CONDA_CMOR_CHANNELS//,/ } ${CONDA_CMOR_NAME} > ${TTY}

    if [ $? -eq 0 ] ; then
      if [ ${CONDA_CMOR_ENV} ] ; then
        PrePARE=${conda_path}/envs/${CONDA_CMOR_ENV}/bin/PrePARE.py
        . $QA_SRC/scripts/parseConfigFile CONDA_CMOR_ENV=${conda_env}
      else
        PrePARE=${conda_path}/bin/PrePARE.py
        . $QA_SRC/scripts/parseConfigFile CONDA_CMOR_ENV=none
      fi

      . $QA_SRC/scripts/parseConfigFile \
         PrePARE=${conda_path}/envs/cmor/bin/PrePARE.py

      status=0
      echo "Please, note that activation/deactivation is not required in this place." > $TTY
    fi
  fi

  return $status
}

update_external()
{
  test ${INTERNET:-t} = f && return 0

  test "${PROJECT_AS}" && prj=${PROJECT_AS}

  local lastUpdate
  eval lastUpdate=LAST_${prj}_UPDATE

  # check it here in order to prevent an update of the config-file in case
  # that the installation failed or war terminated.
  if [ "${lastUpdate}" != ${today} -o ${isForceUpdate:-f} = t ]; then
     . ${QA_SRC}/scripts/get_externalSources \
         -P $prj --qa-src=${QA_SRC} \
         --qa-home=${QA_HOME} --config_file=${CONFIG_FILE} \
         ${isUpdate:+--force-update}

     test $? -gt 0 && exit 41

     . ${QA_SRC}/scripts/parseConfigFile LAST_${prj}_UPDATE=${today}
  fi

  return 0
}

update_QA_SRC()
{
  if [ ${INTERNET:-t} = t ] ; then
    if ! . ${QA_SRC}/scripts/parseConfigFile LAST_QA_UPDATE=${today} \
          || [ ${isUpdate:-f} = t ]; then
      if [ ! -f ${QA_SRC}/.ignore_GitHub ] ; then
        cd ${QA_SRC}

        # is qa-dkrz going to change?
        local qa_dkrzDate=$(ls -l \
             --time-style=+'%s' ${QA_SRC}/scripts/qa_dkrz \
             | awk '{print $6}' 2> /dev/null )

        test "$(getGitBranch)" != master && \
          git checkout master &> /dev/null
#         git checkout $(getGitBranch) &> /dev/null

        git fetch && git reset --hard origin/$(getGitBranch) &> /dev/null
#       git pull --no-edit -q origin master &> /dev/null

        if [ ${qa_dkrzDate} != $( ls -l \
             --time-style=+'%s' ${QA_SRC}/scripts/qa_dkrz \
             | awk '{print $6}' 2> /dev/null ) ] ; then
          return 101  # causes a restart of qa-dkrz, because it was renewed
        fi
      fi
    fi
  fi

  return 0
}

# ----- main ------

THIS=${0%/*}
if [ ${THIS} != $0 ] ; then
  cd ${THIS} &> /dev/null
  THIS=$(pwd)
  cd - &> /dev/null
else
  THIS=$(pwd)
fi

test ${THIS##*/} = scripts && THIS=${THIS%/*}

zeroArg=$0
allArgs=($*)

if [ $# -gt 0 ] ; then
  # safe arguments
  sArgs=($*)

  # higher priority options
  for(( i=0 ; i < ${#sArgs[*]} ; ++i )) ; do
    # some args are accepted without '--'
    A="${sArgs[i]}"
#    tr_option A
    A=$( echo "${A/% /}" | tr "[:lower:]" "[:upper:]" )

    if [ "${A:0:5}" = AUTO_ ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:5}" = DEBUG ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:4}" = HELP ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:4}" = LINK ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:6}" = ONLY-Q ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:3}" = SRC  ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:2}" = UP ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    fi

    if [ "${A%=*}" = 'DEBUG' ] ; then
      test ${A} = 'DEBUG' -o ${A#*=} = ${0##*/} && set -x
    fi
  done
fi

prj=${defaultProject}

while getopts BdhT:-: option ${sArgs[*]}
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  case $option in
    -)  OPTVAL=${OPTARG#*=}
        OPTNAME=${UOPTARG%%=*}

        if [ "${OPTNAME}" = HOME ] ; then
          export QA_HOME=${OPTVAL}
          break
        elif [ "${OPTNAME}" = PROJECT_AS ] ; then
          prj="${OPTVAL}"
        elif [ "${OPTNAME}" = QA_HOME ] ; then
          export QA_HOME=${OPTVAL}
          break
        elif [ "${OPTNAME}" = WORK ] ; then
          export QA_HOME=${OPTVAL}
          break
        fi
        ;;
   \?)  ;;
  esac
done

mkdir -p ${HOME}/.qa-dkrz

OPTIND=
while getopts BdhT:-: option ${sArgs[*]}
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  case $option in
    B)  coll[${#coll[*]}]=-B ;;
    d)  coll[${#coll[*]}]=-d ;;
    h)  descript
        exit 41 ;;
    T)  TTY="${OPTARG}" ;;
    -)  OPTVAL=${OPTARG#*=}
        OPTNAME=${UOPTARG%%=*}

        if [ "${UOPTARG:0:7}" = AUTO_UP ] ; then
          local OV
          for OV in ${OPTVAL//,/ } ; do
            if [ "${OV}" = CONDA_QA -o "${OV}" = CONDA_CMOR ] ; then
              OPTNAME=${OV}
              tr_option OPTNAME
              OV=${OPTNAME#*=}
              OPTNAME=${OPTNAME%%=*}

              if [ ${OV:0:1} = D -o ${OV:0:1} = F -o -o ${OV:0:1} = S ] ; then
                 OV=disable
              else
                OV=enable
              fi
              . ${QA_SRC}/scripts/parseConfigFile AUTO_UPDATE_${OPTNAME}=${OV}
            else
              tr_option OV
              if [ ${OV:0:1} = D -o ${OV:0:1} = F -o ${OV:0:1} = S ] ; then
                OV=disable
              else
                OV=enable
              fi
              . ${QA_SRC}/scripts/parseConfigFile AUTO_UPDATE=${OV}
            fi
          done
          continue
        elif [ "${OPTNAME}" = BUILD ] ; then
          isBuild=t
        elif [ ${UOPTARG:0:5} = DEBUG -o ${UOPTARG} = 'DEBUG=INSTALL' ] ; then
          DEBUG='--debug'
          set -x
        elif [ "${OPTNAME}" = HELP ] ; then
          descript
          exit 41
        elif [ "${OPTNAME}" = HOME ] ; then
          continue
        elif [ "${UOPTARG:0:4}" = LINK ] ; then
          isLink=t
        elif [ "${OPTNAME}" = NET ] ; then
          OPTVAL=$( echo "${OPTVAL}" | tr "[:lower:]" "[:upper:]" )
          if [ ${OPTVAL:0:1} = Y -o ${OPTVAL:0:1} = E -o ${OPTVAL:0:1} = T ] ; then
             OPTVAL=t
          elif [ ${OPTVAL:0:1} = N -o ${OPTVAL:0:1} = D -o ${OPTVAL:0:1} = F \
                   -o ${OPTVAL:0:1} = S ] ; then
             OPTVAL=f
          fi
          INTERNET=f
#          . ${QA_SRC}/scripts/parseConfigFile INTERNET=${OPTVAL}
        elif [ "${OPTNAME:0:6}" = ONLY_Q ] ; then
          :  # for backward compatibilty
        elif [ "${OPTNAME}" = PROJECT_AS ] ; then
          PROJECT_AS="${OPTVAL}"
        elif [ "${OPTNAME}" = QA_SRC ] ; then
          export QA_SRC=${OPTVAL}
        elif [ "${OPTNAME}" = QA_HOME ] ; then
          continue
        elif [ "${OPTNAME}" = SRC ] ; then
          :  # for backward compatibilty
        elif [ "${OPTNAME}" = SET_DEFAULT_PROJECT ] ; then
          default_prj=${OPTVAL}
          continue
        elif [ "${OPTNAME:0:2}" = UP ] ; then
          OPTVAL=$( echo "${OPTVAL#*=}" | tr "[:lower:]" "[:upper:]" )
          if [ "${OPTVAL:0:9}" = conda ] ; then
            isCondaUp=t
          elif [ "${OPTVAL:0:5}" = FORCE ] ; then
            isForceUpdate=t
          elif [ "${OPTVAL:0:1}" = N -o "${OPTVAL:0:1}" = F \
                    -o "${OPTVAL:0:1}" = D -o "${OPTVAL:0:1}" = S ] ; then
            isUpdate=f
            continue
          fi

          isUpdate=t
        elif [ "${OPTNAME}" = WORK ] ; then
          continue
        elif [ "${OPTNAME}" = HDF5 ] ; then
          hdf5=${OPTVAL}
        elif [ "${OPTNAME}" = NETCDF ] ; then
          netcdf=${OPTVAL}
        elif [ "${OPTNAME}" = ZLIB ] ; then
          zlib=${OPTVAL}
        elif [ "${OPTNAME}" = UDUNITS ] ; then
          udunits=${OPTVAL}
        fi

        # collect options, which have not been processed above
        coll[${#coll[*]}]=--${UOPTARG}
        ;;
   \?)  descript
        echo $*
        exit 1 ;;
  esac
done

shift $(( $OPTIND - 1 ))

if [ ! "${TTY}" ] ; then
  if tty -s ; then TTY=$(tty) ; fi
fi

for pck in $* ; do
  PCK="${pck}"
  tr_option PCK

  if [ ${PCK:0:4} = ZLIB ] ; then
    zlib=${pck}
  elif [ ${PCK:0:4} = HDF5 ] ; then
    hdf5=${pck}
  elif [ ${PCK:0:6} = NETCDF ] ; then
    netcdf=${pck}
  elif [ ${PCK:0:7} = UDUNITS ] ; then
    udunits=${pck}
  elif [ ${PCK:0:7} = QA_HOME ] ; then
    QA_HOME=${PCK:8}
  elif [ ${PCK:0:10} = PROJECT_AS ] ; then
    PROJECT_AS=${PCK:11}
  else
#    if [ ${pck:0:1} = '-' ] ; then
#      echo -e "\nFound PROJECT name=${pck}" > $TTY
#      echo "Note that options must be provided first" > $TTY
#      exit 1
#    fi

    coll[${#coll[*]}]=$pck  # collect projects names
    projects[${#projects[*]}]=$pck
  fi
done

# resolve symbolic links
. ${THIS}/scripts/getSrcPath

# is it in a conda built?
. ${QA_SRC}/scripts/getCondaPath

. ${QA_SRC}/scripts/getHomePath

. ${QA_SRC}/scripts/parseConfigFile DEFAULT_PROJECT${default_prj:+=${default_prj}}
test ${#projects[*]} -eq 0 && projects=(${default_prj})

# inquire from ~/.qa-dkrz/config.txt;
# also ensures that all names in the config.files are defined in this program
if [ ! ${isBuild} ] ; then
  for prj in ${projects[*]} ;do
    if [ ! . ${QA_SRC}/scripts/inqRunEnv ${projects[*]} || [ ${isUpdate:-f} = t ] ; then
      if ! update $prj ; then
        status=$?
        test ! ${ignore_failed_update} && exit ${status}
      fi
    fi
  done
fi

test ${CONDA_QA_PATH} && exit  # miniconda built executables

pcks="--zlib=$zlib --hdf5=$hdf5 --netcdf=$netcdf --udunits=$udunits"

if [ ${isBuild:-f} = t -a ${isLink:-f} = t ] ; then
  echo "scripts/install.sh: options --build and --link exclude each other"
  exit 1
elif [ ${isBuild:-f} = t -o ${isLink:-f} = t ] ; then
  log ${allArgs[*]}
else
  pcks=
fi

if [ "${projects[0]}" = NONE ] ; then
   echo "qa-dkrz requires PROJECT=name in the configuration or on the command-line"
   exit
fi

exec ${QA_SRC}/scripts/install.sh ${debug} --pack=${package} \
${isContinueLog:+--continue_log} ${pcks} \
${PROJECT_AS:+--PROJECT_AS=${PROJECT_AS}} \
--qa-src=${QA_SRC} ${coll[*]}
