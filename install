#! /bin/bash

package=QA-DKRZ

hdf5=hdf5-1.8.14
netcdf=netcdf-4.3.2
zlib=zlib-1.2.8
udunits=udunits-2.2.19

defaultProject=CORDEX

descript()
{
  echo "Usage: install [options] [project[s]]"
  echo "Purpose: Install/update 'the Quality Control Software Package'"
  echo "for checking climate simulation meta-data provided in netCDF format."
  echo "Details at https://redmine.dkrz.de/projects/cordex/wiki/DKRZ_QC_Tool"
  echo ''
  echo "Options:"
  echo "  -B                Unconditionally re-make all QA executables."
  echo "  -d                Execute 'make' with debugging information."
  echo "  -h                Display usage and exit."
  echo "  --auto-up         Enable automatic updates from the repository at the"
  echo "                    beginning of a run. Suspended by --auto-up=d[isable]."
  echo "  --build           Download and build required libraries."
  echo "  --debug[=script]  Display execution commands. If the name of a script"
  echo "                    called internally is assigned, then debug only this one."
  echo "  --help            Display usage and exit."
  echo "  --link=path       Hard links of external NetCDF installations from the directories"
  echo "                    in 'your-path/${package}/local'."
  echo "                    Shared by all hdf, netcdf, udunits  and zlib."
  echo "  --link_type=path  Same as for 'link' but just for type=netcdf, hdf, zlib, or udunits"
  echo "  --local=path      Path where lib and include directories are to be installed"
  echo "                    [default: QA_DKRZ/local] for both real and hard-links."
  echo "                    Note: unneccesary when install_configure points outside."
  echo "  --show-inst       Display properties of the current installation."
  echo "  --up[date]        Update the QA package from the repository."
  echo "                    Note: not for netCDF, HDF5, udunits2 or zlib."
  echo ""
  echo "  project-name      At present CF, CMIP5, and CORDEX; the latter by default."
}

getRevNum()
{
  # get current revision number; this determines whether it is
  # before a change of defaults happened.
  local arg=$1

  local branch=$(git branch | grep '*' | awk '{print $2}')
  local currIdent=$(git log --pretty=format:'%h' -n 1)

  eval ${arg}=${branch}-${currIdent}

  return
}

getSrcPath()
{
  # extract the path to the root of the QA package

  # given by environment variable
  if [ ${#QA_PATH} -gt 0 ] ; then
    # is it a path to bin?
    if [ ${QA_PATH##*/} = 'bin' ] ; then
      QA_PATH=${QA_PATH%/bin}
      isWithBin=t
    fi

    # is something wrong?
    if [ ! -f ${QA_PATH}/.install_configure ] ; then
      str="\nQA_PATH=${QA_PATH}${isWithBin:+/bin} is no path to the QA-DKRZ root"
      str="\nPlease, check environment variable QA_PATH"
      echo -e "${str}"
      exit
    fi

    return
   fi

  local target isInvalid

  if [ ${1:0:1} = '/' ] ; then
    target=$1
  else
    target=$(pwd)/$1
  fi

  if [ -h $target ] ; then

    # get the link
    local link=$(ls -l $target 2> /dev/null | awk  '{print $(NF)}')

    # link is relative, so make it absolute
    test ${link:0:1} != '/' && link=${target%/*}/${link}

    getSrcPath ${link}

  elif [ -f $target ] ; then

    # a real instance, at first resolve .. and .
    # works also for . or .. in the middle of the path

    local xname=${target##*/}
    target=${target%/*}  # remove the name of the script
    target=${target%/*}  # remove the name directory scripts

    # resolve .. and .
    local arr=( ${target//\// } )

    # any ., or .. in the middle of QA_PATH?
    local i j sz
    sz=${#arr[*]}

    for(( i=1 ; i < sz ; ++i )) ; do

      if [ "${arr[i]}" = '.' ] ; then
        unset arr[i]
      elif [ "${arr[i]}" = '..' ] ; then
        j=$((i-1))

        # this takes into account adjacent . and/or .. with any depth
        while [ ${#arr[j]} -eq 0 ] ; do
          j=$((j-1))
        done
        unset arr[j]
        unset arr[i]
      fi
    done

    # get rid of empty items
    arr=( ${arr[*]} )

    sz=${#arr[*]}

    local tmp
    for(( i=0 ; i < sz ; ++i )) ; do
      tmp=${tmp}/${arr[i]}
    done

    if [ -f ${tmp}/.install_configure ] ; then
      QA_PATH=$tmp
    else
      isInvalid=t
    fi

  else
    isInvalid=t
  fi

  if [ ${isInvalid:-f} = t ] ; then

    local str=$(ls -l $target 2> /dev/null | awk  '{print $(NF)}')

    if [ ${#str} -gt 0 ] ; then
      str="invalid path=$0"
    else
      str="broken path=$0"
    fi

    echo "${str}"

    exit 1
  fi

  export QA_PATH=${QA_PATH}

  return
}

git_update()
{
  git pull origin

  test $? -gt 0 && return

  # revison num of the updated package
  getRevNum packRev

  set_dot_conf QA-DKRZ_REVISION=$packRev

  return
}

log()
{
  if [ ${isContinueLog:-f} = f ] ; then
    isContinueLog=t

    local logTxt="\n$(date +'%F_%T'):"
    echo -e "${logTxt} install $*" >> install.log
  fi

  return
}

saveAsCycle()
{
  for f in $* ; do
    if [ ! \( -f $f -o -d $f \) ] ; then
      echo "install.saveAsCycle: no such file or directory $f"
      return
    fi

    local ext val x
    local maxVal fs fx

    maxVal=0
    fs=( $(ls -d $f.* 2> /dev/null) )

    for fx in ${fs[*]} ; do
      ext=${fx##*.}

      if val=$(expr match $ext '\([[:digit:]]\+$\)' 2> /dev/null) ; then
        test ${val:-0} -gt ${maxVal} && maxVal=$val
      fi
    done

    mv $f ${f}.$((++maxVal)) 2> /dev/null
  done
}

set_dot_conf()
{
  local args item name

  args=($*)
  args=(${args[*]//=/ })

  if [ ${#args[*]} -eq 0 ] ; then
    return  # this is a fault
  elif [ $${#args[*]} -eq 1 ] ; then
    name=${args[0]}
    item=enabled
  else
    name=${args[0]}
    item=${args[1]}
  fi

  if grep -i -q $name=$item .conf &> /dev/null; then
    return
  fi

  if [ "${item#*=}" = disable -o "${item#*=}" = d ] ; then
    sed -i "/${name}/ d" .conf &> /dev/null
    test ! -s .conf && \rm .conf
  elif grep -i -q ${name} .conf &> /dev/null; then
    sed -i "/${name}/ d" .conf &> /dev/null
    echo ${name}=enabled >> .conf
  fi

  return
}

tr_option()
{
  local phrase="${!1}"

  local sz i
  local sz=${#phrase}
  for((i=0 ; i < sz ; ++i )) ; do
    test "${phrase:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    phrase=$( echo "${phrase/% /}" | tr "[:lower:]" "[:upper:]" )
  else
    local tmp0="${phrase:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    phrase="${tmp0}""${phrase:i}"
  fi

  eval ${1}=\${phrase}
  return
}


# ----- main ------

zeroArg=$0
allArgs=($*)

if [ $# -gt 0 ] ; then
  # save arguments
  sArgs=($*)

  # higher priority options
  for(( i=0 ; i < ${#sArgs[*]} ; ++i )) ; do
    # some args are accepted without '--'
    isAccepted=f
    if [ "${sArgs[${i}]:0:7}" = auto-up ] ; then
      isAccepted=t
    elif [ "${sArgs[${i}]:0:5}" = debug ] ; then
      isAccepted=t
    elif [ "${sArgs[${i}]:0:4}" = help ] ; then
      isAccepted=t
    elif [ "${sArgs[${i}]:0:4}" = link ] ; then
      isAccepted=t
    elif [ "${sArgs[${i}]:0:6}" = only-q ] ; then
      isAccepted=t
    elif [ "${sArgs[${i}]:0:3}" = src ] ; then
      isAccepted=t
    elif [ "${sArgs[${i}]:0:2}" = up ] ; then
      isAccepted=t
    fi

    test ${isAccepted} = t && sArgs[${i}]=--${sArgs[${i}]}

    A="${sArgs[i]}"
    tr_option A

    if [ "${A%=*}" = '--DEBUG' ] ; then
      test ${A} = '--DEBUG' -o ${A#*=} = ${0##*/} && set -x
    elif [ "${A%%=*}" = "--PREFIX" ] ; then
      if [ -d ${sArgs[i]#*=} ] ; then
         mv ${sArgs[i]#*=} ${sArgs[i]#*=}.save
         echo "--prefix=${sArgs[i]#*=} exists; saved as ${sArgs[i]#*=}.save"
      fi

      zeroArg=${sArgs[i]#*=}
      if mkdir -p $zeroArg ; then
        cd $zeroArg
      else
        echo "Could not mkdir -p $zeroArg"
        exit
      fi
    fi
  done
fi

while getopts Bdh-: option ${sArgs[*]}
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  case $option in
    B)  coll[${#coll[*]}]=-B ;;
    d)  coll[${#coll[*]}]=-d ;;
    h)  descript
        exit ;;
    -)  if [ "${UOPTARG%=*}" = "AUTO_UP" ] ; then
          set_dot_conf ${OPTARG}
          continue
        elif [ "${UOPTARG:0:5}" = "BUILD" ] ; then
          isBuild=t
        elif [ "${UOPTARG:0:4}" = "LINK" ] ; then
          isLink=t
        elif [ ${UOPTARG:0:5} = DEBUG -o ${UOPTARG} = 'DEBUG=install' ] ; then
          set -x
        elif [ "${UOPTARG%%=*}" = "HELP" ] ; then
          descript
          exit
        elif [ "${UOPTARG:0:6}" = "ONLY-Q" ] ; then
          continue  # for backward compatibilty
        elif [ "${UOPTARG}" = "SRC" ] ; then
          continue  # for backward compatibilty
        elif [ "${UOPTARG:0:2}" = "UP" ] ; then
          isUpdateQA=t
          continue
        fi

        # collect options, which have not been processed above
        coll[${#coll[*]}]=--${OPTARG}
        ;;
   \?)  descript
        echo $*
        exit 1 ;;
  esac
done

shift $(( $OPTIND - 1 ))

getSrcPath $zeroArg

if grep -i -q AUTO-UP .conf &> /dev/null; then
  isUpdateQA=t
fi

test ${isUpdateQA:-f} = t && git_update

for pck in $* ; do
  PCK="${pck}"
  tr_option PCK

  if [ ${PCK:0:4} = ZLIB ] ; then
    zlib=${pck}
  elif [ ${PCK:0:4} = HDF5 ] ; then
    hdf5=${pck}
  elif [ ${PCK:0:6} = NETCDF ] ; then
    netcdf=${pck}
  elif [ ${PCK:0:7} = UDUNITS ] ; then
    udunits=${pck}
  else
    coll[${#coll[*]}]=$pck  # collect project names
  fi
done

pcks="--zlib=$zlib --hdf5=$hdf5 --netcdf=$netcdf --udunits=$udunits"

if [ ${isBuild:-f} = t -a ${isLink:-f} = t ] ; then
  echo "scripts/install.sh: options --build and --link exclude each other"
  exit 1
elif [ ${isBuild:-f} = t -o ${isLink:-f} = t ] ; then
  log ${allArgs[*]}
else
  pcks=
fi

exec scripts/install.sh ${debug} --pack=${package} \
${isContinueLog:+--continue_log} ${pcks} \
${coll[*]}
