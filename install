#! /bin/bash

package=QA-DKRZ

hdf5=hdf5-1.8.17
netcdf=netcdf-4.4.1
zlib=zlib-1.2.8
udunits=udunits-2.2.20

defaultProject=CORDEX

export CONFIG_FILE=$HOME/.qa-dkrz/config.txt

# options with auto-update feature (option: --auto-up_feature)
#   CMOR3_LLNL:     the CMOR3 checker (D. Nadeau, LLNL)
#   GIT_QA:         all QA updates touching write-protected locations
#   QA_SRC:         QA sources; disabled for conda-installed QA-DKRZ
#   PROJECT_TABLES: Project related tables and programs; PROJECT substituted by
#                   current project name(s).

AUTO_OPTS=( CMOR3_LLNL \
            CONDA_FOR_CMOR3 \
            PROJECT_TABLES \
          )

auto_up()
{
  local key param name value

  # strip the 'auto=' prefix
  local param="${1%%=*}"
  if [ "${arg:0:4}" = AUTO ] ; then
    param=${1#*=}
  fi

  local csl
  declare -a csl
  csl=( ${param//,/ } )

  local isForAll=f

  for param in ${csl[*]} ; do
    value=${param#*=}
    name=${param%=*}

    if [ ${value} = ${param} -o ${value:0:1} = e ] ; then
      value=enable
    elif [ ${value:0:1} = d ] ; then
      value=disable
    fi

    for key in ${AUTO_OPTS[*]} ; do
       if [ ${key} = ${name} ] ; then
         . $QA_SRC/scripts/parseConfigFile AUTO-UP_${name}=${value}
         continue 2  # skip the is-for-all part
       fi
    done

    # not a particular one, thus apllicable to all
    if [ ${#csl[*]} -gt 1 ] ; then
      echo "ambiguous auto-option. Please, check the command-line. EXIT"
      exit 1
    fi

    isForAll=t
    break
  done

  if [ ${isForAll} = t ] ; then
    for key in ${AUTO_OPTS[*]} ; do
       . $QA_SRC/scripts/parseConfigFile AUTO-UP_${key}=${value}
    done
  fi

  return 0
}

descript()
{
  echo "Usage: install [options] [project[s]]"
  echo "Purpose: Install/update 'the Quality Control Software Package'"
  echo "for checking climate simulation meta-data provided in netCDF format."
  echo "Details at https://redmine.dkrz.de/projects/cordex/wiki/DKRZ_QC_Tool"
  echo ''
  echo "Options:"
  echo "  -B                Unconditionally re-make all QA executables."
  echo "  -d                Execute 'make' with debugging information."
  echo "  -h                Display usage and exit."
  echo "  --auto-up         Enable automatic updates from the repository at the"
  echo "                    beginning of a run. Suspended by --auto-up=d[isable]."
  echo "                    Enabled initially by default."
  echo "  --build           Download and build required libraries."
  echo "  --debug[=script]  Display execution commands. If the name of a script"
  echo "                    is assigned, then debug only this one."
  echo "  --help            Display usage and exit."
  echo "  --keep            Do not replace installed libs of the same version"
  echo "  --link=path       Hard links of external NetCDF installations from the"
  echo "                    directories in 'your-path/${package}/local'."
  echo "                    Shared by all hdf, netcdf, udunits  and zlib."
  echo "  --link_type=path  Same as for 'link' but just for type=netcdf, hdf, zlib, or udunits"
  echo "  --local=str       Path where lib and include directories are to be installed"
  echo "                    [default: QA_DKRZ/local] for both real and hard-links."
  echo "                    Note: unneccesary when install_configure points outside."
  echo "  --show-inst       Display properties of the current installation."
  echo "  --up[date]        Update the QA package from the repository."
  echo "                    Note: not for netCDF, HDF5, udunits2 or zlib."
  echo "  --work=path       Location of the .config.txt file and project tables"
  echo "                    ~/.qa-dkrz by default. Required if multiple users are"
  echo "                    to access the same set of tables."
  echo ""
  echo "  project-name(s)   At present CF, CMIP5, and CORDEX; the latter by default."
}

getCondaPath()
{
  # was this script launched from qa-dkrz of a conda installation?
  local path=${1%/*}
  path=${path%/*}

  if ls ${path%/*}/conda-meta/qa-dkrz* &> /dev/null ; then
    eval ${2}=$path/qa-dkrz
    export CONDA_ENV=t

    return 0
  fi

  return 1
}

getGitBranch()
{
   git branch | grep '*' | awk '{print $2}'
   return
}

getHomePath()
{
  # path to the current user's home
  export QA_HOME

  if [ "${QA_HOME}" ] ; then
    # if it is a new path, then adjust the config file
    . $QA_SRC/scripts/parseConfigFile QA_HOME=${QA_HOME}
  else
    # take QA_HOME from the config file, if it exists.
    if ! . $QA_SRC/scripts/parseConfigFile QA_HOME ; then
      echo -e "\nPlease, specify variable QA_HOME [default: ${QA_SRC}/HOME], " > ${TTY}
      read -p "the spot for external tables and programs: " QA_HOME 2> ${TTY}

      test ! ${QA_HOME} && QA_HOME=${HOME}/.qa-dkrz

      if mkdir -p ${QA_HOME} &> /dev/null ; then
        . $QA_SRC/scripts/parseConfigFile QA_HOME=${QA_HOME}
      else
        echo  "could not mkdir QA_HOME=${QA_HOME}"
        exit 1
     fi
    fi

    if [ ! -w $QA_HOME ] ; then
      echo "directory $QA_HOME without write permissions,"
      echo "please, restart with added option --qa-home=path"
      exit 1
    fi
  fi

  return
}

getRevNum()
{
  # get current revision number; this determines whether it is
  # before a change of defaults happened.
  local branch currIdent

  if [ $CONDA_ENV ] ; then
    declare -a branch
    if branch=( $(cat $QA_SRC/install.log 2> /dev/null) ) ; then
      branch[0]=${branch[0]#*=}
      currIdent=${branch[1]#*=}
    fi
  else
    cd $QA_SRC &> /dev/null
    branch=$(getGitBranch)
    currIdent=$(git log --pretty=format:'%h' -n 1)
    cd - &> /dev/null
  fi

  eval ${1}=${branch}-${currIdent}

  return
}

getSrcPath()
{
  # extract the path to the root of the QA package

  # is it in a conda built?
  if getCondaPath $0 QA_SRC ; then
    export QA_SRC
  fi

  test ${QA_SRC} && return

  local target isInvalid

  if [ ${1:0:1} = '/' ] ; then
    target=$1
  else
    target=$(pwd)/$1
  fi

  if [ -h $target ] ; then

    # get the link
    local link=$(ls -l $target | awk  '{print $(NF)}')

    # link is relative, so make it absolute
    test ${link:0:1} != '/' && link=${target%/*}/${link}

    getSrcPath ${link}

  elif [ -f $target ] ; then

    # a real instance, at first resolve .. and .
    # works also for . or .. in the middle of the path

    local xname=${target##*/}
    target=${target%/*}  # remove the name of the script

    local arr=( ${target//\// } )

    local i j sz
    sz=${#arr[*]}

    for(( i=1 ; i < sz ; ++i )) ; do

      if [ "${arr[i]}" = '.' ] ; then
        unset arr[i]
      elif [ "${arr[i]}" = '..' ] ; then
        j=$((i-1))

        # this takes into account adjacent . and/or .. with any depth
        while [ ! ${arr[j]} ] ; do
          j=$((j-1))
        done
        unset arr[j]
        unset arr[i]
      fi
    done

    # get rid of empty items
    arr=( ${arr[*]} )

    sz=${#arr[*]}

    local tmp
    for(( i=0 ; i < sz ; ++i )) ; do
      tmp=${tmp}/${arr[i]}

      if [ -f ${tmp}/.install_configure ] ; then
        # final check
        if [ ! -e $tmp/install ] ; then
           echo "$tmp is not QA_SRC; EXIT"
           exit
        fi

        export QA_SRC=$tmp
        break
      fi
    done

    test $i -eq $sz && isInvalid=t
  else
    isInvalid=t
  fi

  if [ ${isInvalid:-f} = t ] ; then

    local str=$(ls -l $target 2> /dev/null | awk  '{print $(NF)}')

    if [ ${#str} -gt 0 ] ; then
      str="invalid path=$0"
    else
      str="broken path=$0"
    fi

    echo "${str}"

    exit 1
  fi

  export QA_SRC=${QA_SRC}

  return
}

log()
{
  if [ ${isContinueLog:-f} = f ] ; then
    isContinueLog=t

    local logTxt="\n$(date +'%F_%T'):"
    echo -e "${logTxt} install $*" >> install.log
  fi

  return
}

saveAsCycle()
{
  for f in $* ; do
    if [ ! \( -f $f -o -d $f \) ] ; then
      echo "install.saveAsCycle: no such file or directory $f"
      return
    fi

    local ext val x
    local maxVal fs fx

    maxVal=0
    fs=( $(ls -d $f.* 2> /dev/null) )

    for fx in ${fs[*]} ; do
      ext=${fx##*.}

      if val=$(expr match $ext '\([[:digit:]]\+$\)' 2> /dev/null) ; then
        test ${val:-0} -gt ${maxVal} && maxVal=$val
      fi
    done

    mv $f ${f}.$((++maxVal)) 2> /dev/null
  done
}

tr_option()
{
  local line="${!1}"
  local i pref

#  test "${line:0:1}" != '-' && return

  for(( i=0 ; i < ${#line} ; ++i )) ; do
    if [ ${line:i:1} != - ] ; then
      line=${line:i}
      break
    fi
  done

  local sz
  sz=${#line}

  for((i=0 ; i < sz ; ++i )) ; do
    test "${line:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    if [ ${i} -gt 1 ] ; then
      line=$( echo "${line/% /}" | tr "[:lower:]" "[:upper:]" )
      line=$( echo "${line}" | tr "-" "_" )
    fi
  else
    local tmp0="${line:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    tmp0=$( echo "${tmp0}" | tr "-" "_" )
    line="${tmp0}""${line:i}"
  fi

  eval ${1}=\${line}

  return
}

update()
{
  # search for updates only once a day
  local today=$( date '+%Y%m%d' )

  update_external

  update_QA

  # revison num of the package
  local packRec
  getRevNum packRev

  . $QA_SRC/scripts/parseConfigFile QA_REVISION${packRev:+=}$packRev

  return 0
}

update_external()
{
  if ! . $QA_SRC/scripts/parseConfigFile QA_LAST_UPDATE=${today} \
        || [ ${isUpdateQA:-f} = t ]; then
    if [ ${isCondaUpdate:-t} = t -a -w ${QA_SRC} ] ; then
      # look for a new conda-built package
#      local tmp
#      declare -a tmp
#      tmp=( $(conda search -c birdhouse -c conda-forge qa-dkrz 2> /dev/null) )

#      local i item
#      for(( i=0 ; i < ${#tmp[*]} ; ++i )) ; do
#        if [ ${tmp[i]} = '*' ] ; then
#          item=${tmp[++i]}
#          item=${item}-${tmp[++i]}

          conda update -c birdhouse -c conda-forge qa-dkrz  &> /dev/null

          getRevNum packRev

          exitVal=101
#          break
#        fi
#      done
    fi
  fi

  for prj in ${project[*]} ; do
    test "${PROJECT_AS}" && prj=${PROJECT_AS}
    local lastUpdate

    if [ "${prj}" != CF ] ; then
      # check it here in order to prevent an update of the config-file in case
      # that the installation failed or war terminated.
      . $QA_SRC/scripts/parseConfigFile ${prj}_LAST_UPDATE
      eval lastUpdate=\${prj}_LAST_UPDATE

      if [ "${lastUpdate}" != ${today} -o ${isUpdateQA:-f} = t ]; then
         . ${QA_SRC}/scripts/get_externalSources \
             -P $prj --qa_src=${QA_SRC} \
             --qa_home=${QA_HOME} --config_file=${CONFIG_FILE} \
             ${isForceUp:+--force-update}

         test $? -gt 0 && exit 1

         . $QA_SRC/scripts/parseConfigFile ${prj}_LAST_UPDATE=${today}
      fi
    fi

    test "${PROJECT_AS}" && break
  done

  if ! . $QA_SRC/scripts/parseConfigFile CF_LAST_UPDATE=${today} \
        || [ ${isUpdateQA:-f} = t ]; then
      ${QA_SRC}/scripts/get_cfconventions \
         --qa_path=${QA_SRC} ${DEBUG} \
         --config_file=$CONFIG_FILE \
         ${QA_HOME}/tables/projects/CF
  fi

  return
}

update_QA()
{
  if ! . $QA_SRC/scripts/parseConfigFile QA_LAST_UPDATE=${today} \
        || [ ${isUpdateQA:-f} = t ]; then
    if [ ! -f ${QA_SRC}/.ignore_GitHub ] ; then
      cd $QA_SRC

      # is qa-dkrz going to change?
      local qa_dkrzDate=$(ls -l \
           --time-style=+'%s' ${QA_SRC}/scripts/qa_dkrz \
           | awk '{print $6}' 2> /dev/null )

      test "$(getGitBranch)" != master && \
        git checkout master &> /dev/null
#        git checkout $(getGitBranch) &> /dev/null

      git fetch && git reset --hard origin/$(getGitBranch) &> /dev/null
#      git pull --no-edit -q origin master &> /dev/null

      if [ ${qa_dkrzDate} != $( ls -l \
           --time-style=+'%s' ${QA_SRC}/scripts/qa_dkrz \
           | awk '{print $6}' 2> /dev/null ) ] ; then
        exitVal=101
      fi
    fi
  fi

  if ! mkdir -p $QA_HOME/tables  ; then
    echo "could not mkdir -p $QA_HOME/tables"
    exit 1
  fi

  # note that QA_HOME points to .qa-dkrz wherever it is located
  rsync -auz --exclude '*~' $QA_SRC/tables $QA_HOME &> /dev/null

  return
}

# ----- main ------
zeroArg=$0
allArgs=($*)

if [ $# -gt 0 ] ; then
  # safe arguments
  sArgs=($*)

  # higher priority options
  for(( i=0 ; i < ${#sArgs[*]} ; ++i )) ; do
    # some args are accepted without '--'
    A="${sArgs[i]}"
#    tr_option A
    A=$( echo "${A/% /}" | tr "[:lower:]" "[:upper:]" )

    if [ "${A:0:5}" = AUTO_ ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:5}" = DEBUG ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:4}" = HELP ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:4}" = LINK ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:6}" = ONLY-Q ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:3}" = SRC  ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:2}" = UP ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    fi

    if [ "${A%=*}" = 'DEBUG' ] ; then
      test ${A} = 'DEBUG' -o ${A#*=} = ${0##*/} && set -x
    fi
  done
fi

while getopts BdhT:-: option ${sArgs[*]}
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  case $option in
    B)  coll[${#coll[*]}]=-B ;;
    d)  coll[${#coll[*]}]=-d ;;
    h)  descript
        exit ;;
    T)  TTY="${OPTARG}" ;;
    -)  OPTVAL=${OPTARG##*=}
        OPTNAME=${UOPTARG%%=*}

        if [ "${UOPTARG:0:4}" = AUTO ] ; then
          autoUpArgs[${#autoUpArgs[*]}]=$UOPTARG
        elif [ "${OPTNAME}" = BUILD ] ; then
          isBuild=t
        elif [ ${UOPTARG:0:5} = DEBUG -o ${UOPTARG} = 'DEBUG=INSTALL' ] ; then
          DEBUG='--debug'
          set -x
        elif [ "${OPTNAME}" = FORCE_UPDATE ] ; then
          isForceUp=t
          isUpdateQA=t
        elif [ "${OPTNAME}" = GET_TABLES ] ; then
          GET_TABLES=t
        elif [ "${OPTNAME}" = HELP ] ; then
          descript
          exit
        elif [ "${OPTNAME}" = HOME -o "${OPTNAME}" = WORK ] ; then
          QA_HOME=${OPTVAL}
        elif [ "${UOPTARG:0:4}" = LINK ] ; then
          isLink=t
        elif [ "${UOPTARG}" = NO_CONDA_UPDATE ] ; then
          isCondaUpdate=f
        elif [ "${UOPTARG}" = NO_INTERNET ] ; then
          isInternet=f
          isCondaUpdate=f
        elif [ "${UOPTARG:0:6}" = ONLY_Q ] ; then
          :  # for backward compatibilty
        elif [ "${OPTNAME}" = PROJECT_AS ] ; then
          PROJECT_AS="${OPTVAL}"
        elif [ "${OPTNAME}" = QA_SRC ] ; then
          export QA_SRC=${OPTVAL}
        elif [ "${OPTNAME}" = QA_HOME ] ; then
          QA_HOME=${OPTVAL}
        elif [ "${OPTNAME}" = SRC ] ; then
          :  # for backward compatibilty
        elif [ "${OPTNAME}" = SET_DEFAULT_PROJECT ] ; then
          DEF_PRJ=${OPTVAL}
          continue
        elif [ "${UOPTARG:0:2}" = UP ] ; then
          isUpdateQA=t
        elif [ "${OPTNAME}" = HDF5 ] ; then
          hdf5=${OPTVAL}
        elif [ "${OPTNAME}" = NETCDF ] ; then
          netcdf=${OPTVAL}
        elif [ "${OPTNAME}" = ZLIB ] ; then
          zlib=${OPTVAL}
        elif [ "${OPTNAME}" = UDUNITS ] ; then
          udunits=${OPTVAL}
        fi

        # collect options, which have not been processed above
        coll[${#coll[*]}]=--${UOPTARG}
        ;;
   \?)  descript
        echo $*
        exit 1 ;;
  esac
done

shift $(( $OPTIND - 1 ))

if [ ! "${TTY}" ] ; then
  if tty -s ; then TTY=$(tty) ; fi
fi

for pck in $* ; do
  PCK="${pck}"
  tr_option PCK

  if [ ${PCK:0:4} = ZLIB ] ; then
    zlib=${pck}
  elif [ ${PCK:0:4} = HDF5 ] ; then
    hdf5=${pck}
  elif [ ${PCK:0:6} = NETCDF ] ; then
    netcdf=${pck}
  elif [ ${PCK:0:7} = UDUNITS ] ; then
    udunits=${pck}
  elif [ ${PCK:0:7} = QA_HOME ] ; then
    QA_HOME=${PCK:8}
    isForceUp=t
  elif [ ${PCK:0:10} = PROJECT_AS ] ; then
    PROJECT_AS=${PCK:11}
  else
#    if [ ${pck:0:1} = '-' ] ; then
#      echo -e "\nFound PROJECT name=${pck}" > $TTY
#      echo "Note that options must be provided first" > $TTY
#      exit 1
#    fi

    coll[${#coll[*]}]=$pck  # collect project names
    project[${#project[*]}]=$pck
  fi
done

mkdir -p ${HOME}/.qa-dkrz

getSrcPath $zeroArg  # sets also CONDA_ENV
getHomePath

#if [ "${autoUpArgs}" ] ; then
#  auto_up ${autoUpArgs[*]}
#fi

if ! . $QA_SRC/scripts/parseConfigFile \
             DEFAULT_PROJECT${DEF_PRJ:+=}${DEF_PRJ} ; then
  # get or set value.
  # note: is set to the defaultProject value at initialisation of the config file,
  #       required here for longer existing config files without entry
  . $QA_SRC/scripts/parseConfigFile DEFAULT_PROJECT=${defaultProject}
fi

test ! "$project" && project=(${DEFAULT_PROJECT#*=})

update

test ${CONDA_ENV} && exit  # miniconda built executables

pcks="--zlib=$zlib --hdf5=$hdf5 --netcdf=$netcdf --udunits=$udunits"

if [ ${isBuild:-f} = t -a ${isLink:-f} = t ] ; then
  echo "scripts/install.sh: options --build and --link exclude each other"
  exit 1
elif [ ${isBuild:-f} = t -o ${isLink:-f} = t ] ; then
  log ${allArgs[*]}
else
  pcks=
fi

if [ "${project[0]}" = NONE ] ; then
   echo "qa-dkrz requires PROJECT=name in the configuration or on the command-line"
   exit
fi

exec $QA_SRC/scripts/install.sh ${debug} --pack=${package} \
${isContinueLog:+--continue_log} ${pcks} \
${PROJECT_AS:+--PROJECT_AS=${PROJECT_AS}} ${coll[*]}
