#! /bin/bash

package=QA-DKRZ

hdf5=hdf5-1.8.14
netcdf=netcdf-4.3.2
zlib=zlib-1.2.8
udunits=udunits-2.2.19

defaultProject=CORDEX

auto-up()
{
  local item=$1

  if [ "${item#*=}" = disable -o "${item#*=}" = d ] ; then
    sed -i '/auto-up/ d' .conf &> /dev/null
    test ! -s .conf && \rm .conf
  else
    if ! grep -i -q auto-up .conf &> /dev/null; then
      echo auto-up=enabled >> .conf
    fi
    isUpdateQA=t
  fi
  return
}

descript()
{
  echo "Usage: install [options] [project[s]]"
  echo "Purpose: Install/update 'the Quality Control Software Package'"
  echo "for checking climate simulation meta-data provided in netCDF format."
  echo "Details at https://redmine.dkrz.de/projects/cordex/wiki/DKRZ_QC_Tool"
  echo ''
  echo "Options:"
  echo "  -B                Unconditionally re-make all QA executables."
  echo "  -d                Execute 'make' with debugging information."
  echo "  -h                Display usage and exit."
  echo "  --auto-up         Enable automatic updates from the repository at the"
  echo "                    beginning of a run. Suspended by --auto-up=d[isable]."
  echo "  --build           Download and build required libraries."
  echo "  --debug[=script]  Display execution commands. If the name of a script"
  echo "                    called internally is assigned, then debug only this one."
  echo "  --distclean       For a re-installation of zlib, hdf5 and netcdf."
  echo "  --help            Display usage and exit."
  echo "  --link=path       Hard links of external NetCDF installations from the directories"
  echo "                    in 'your-path/${package}/local'."
  echo "                    Shared by all hdf, netcdf, udunits  and zlib."
  echo "  --prefix=path     Path for installing the ${package} package;"
  echo "                    current directory by default. "
  echo "  --reset           Clear library setting and start from scratch."
  echo "  --show-inst       Display properties of the current installation."
  echo "  --src-path=path   To the place were all three libs reside."
  echo "  --lib-dest=path   Destination for libs and includes; [${package}/local]."
  echo "                    Note: probably in combination with: --prefix=path."
  echo "  --up[date]        Update the QA package from the repository."
  echo "                    Note: not for netCDF, HDF5, udunits2 or zlib."
  echo ""
  echo "    project-name    At present CMIP5 and CORDEX; the latter by default."
  echo "                    Note: no '--'."
}

getRevNum()
{
  # get current revision number; this determines whether it is
  # before a change of defaults happened.
  local arg=$1

  local branch=$(git branch | grep '*' | awk '{print $2}')
  local currIdent=$(git log --pretty=format:'%h' -n 1)

  eval ${arg}=${branch}-${currIdent}

  return
}

getSrcPath()
{
  # extract the path to the root of the QA package

  # given by environment variable
  if [ ${#QA_PATH} -gt 0 ] ; then
    # is it a path to bin?
    test ${QA_PATH##*/} = 'bin' && export QA_PATH=${QA_PATH%/bin}

    return
  fi

  local target
  if [ ${1:0:1} != '/' ] ; then
    target=$(pwd)/$1
  else
    target=$1
  fi

  if [ -h $target ] ; then

    # get the link
    local link=$(ls -l $target | awk  '{print $(NF)}')

    # link is relative, so make it absolute
    test ${link:0:1} != '/' && link=${target%/*}/${link}

    getSrcPath ${link}

  else

    # resolve .. and .
    local arr=( ${target//\// } )

    # any ., or .. in the middle of QA_PATH?
    local i j sz
    sz=${#arr[*]}

    for(( i=1 ; i < sz ; ++i )) ; do

      if [ "${arr[i]}" = '.' ] ; then
        unset arr[i]
      elif [ "${arr[i]}" = '..' ] ; then
        j=$((i-1))

        # this takes into account adjacent . and/or .. with any depth
        while [ ${#arr[j]} -eq 0 ] ; do
          j=$((j-1))
        done
        unset arr[j]
        unset arr[i]
      fi
    done

    # get rid of empty items
    arr=( ${arr[*]} )

    sz=${#arr[*]}

    for(( i=0 ; i < sz ; ++i )) ; do
      QA_PATH=${QA_PATH}/${arr[i]}
    done
  fi

  local tmp
  while : ; do
    tmp=${QA_PATH##*/}
    test ${#tmp} -eq 0 -o "${tmp:0:3}" = 'QA-' && break

    QA_PATH=${QA_PATH%/*}
  done

  export QA_PATH=${QA_PATH}

  return
}

git_update()
{
  # is git available
  if ! which git &> /dev/null ; then return ; fi

  # revision of the current package: branch-shortIdentifier
  getRevNum packRev_0

  git pull origin

  # revison num of the updated package
  getRevNum packRev_1

  # save current svn revision number, if new
  savedRev=$( grep 'revision=' .conf 2> /dev/null \
            | awk -F= '{print $2}' )

  if [ "${packRev_1}" != "${packRev_1}" ] ; then
    # force compilation
    \rm -f bin/qC-*.x
  fi

  if [ ${savedRev:-0} -eq 0 ] ; then
    getRevNum packRev_1
    echo revision=${packRev} >> .conf
  elif [ ${savedRev} -lt ${packRev_1} ] ; then
    sed -i "s/revision=\(.*\)/revision=${packRev_1}/" .conf &> /dev/null
  fi

  return
}

log()
{
  if [ -f install.log ] ; then
    logTxt="\n === Rebuild: $(date +'%F_%T') ===\n"
  else
    logTxt1="\n === Installation of ${package}: $(date +'%F_%T') ===\n"
  fi

  echo -e ${logTxt} >> install.log
  echo -e "install $*" >> install.log
}

resetBuild()
{
  \rm -rf local

  \rm -rf example/test_I
  \rm -rf example/qa-test.task

  return
}

tr_option()
{
  local phrase="${!1}"

  local sz i
  local sz=${#phrase}
  for((i=0 ; i < sz ; ++i )) ; do
    test "${phrase:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    phrase=$( echo "${phrase/% /}" | tr "[:lower:]" "[:upper:]" )
  else
    local tmp0="${phrase:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    phrase="${tmp0}""${phrase:i}"
  fi

  eval ${1}=\${phrase}
  return
}


# ----- main ------

currPath=$(pwd)
zeroArg=$0

# is git available?
if ! which git &> /dev/null ; then
  echo "git is not available; please, check."
  exit 1
fi

if [ $# -gt 0 ] ; then
  # save arguments
  sArgs=($*)
  allArgs="$*"

  # higher priority options
  for a in $* ; do
    A="$a"
    tr_option A

    if [ "${A%=*}" = '--DEBUG' ] ; then
      test ${A} = '--DEBUG' -o ${A#*=} = ${0##*/} && set -x
    elif [ "${A%%=*}" = "--PREFIX" ] ; then
      if [ ! -d ${a#*=} ] ; then
        if ! mkdir -p ${a#*=} ; then
          echo "Could not mkdir -p ${a#*=}"
          exit
        fi
      fi

      zeroArg=${a#*=}
      if [ ${zeroArg:0:1} != '/' ] ; then
        zeroArg=$currPath/$zeroArg
      fi

      cd $zeroArg
    fi
  done
fi

while getopts Bdh-: option ${args[*]}
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  case $option in
    B)  coll[${#coll[*]}]=-B ;;
    d)  coll[${#coll[*]}]=-d ;;
    h)  descript
        exit ;;
    -)  test "${UOPTARG%=*}" = "AUTO_UP" && auto-up $OPTARG && continue
        test "${UOPTARG}" = "DEBUG" && debug='--debug' && continue
        test "${UOPTARG%%=*}" = "HELP" && descript && exit
        test "${UOPTARG:0:6}" = "ONLY-Q" && continue
        test "${UOPTARG}" = "reset" && resetBuild && continue
        test "${UOPTARG}" = "SRC" && continue  # for backward compatibilty
        test "${UOPTARG:0:2}" = "UP" && isUpdateQA=t && continue

        # collect options, which hav not been proceesed so far
        coll[${#coll[*]}]=--${OPTARG}
        ;;
   \?)  descript
        echo $*
        exit 1 ;;
  esac
done

shift $(( $OPTIND - 1 ))

# accept some args with missing '--'
item=( $* )
for(( i=${#item[*]}-1 ; i >= 0 ; --i )) ; do
  UITEM="${item[i]}"
  tr_option UITEM

  if [ "${UITEM%=*}" = AUTO-UP ] ; then
    auto-up ${item[i]}
  elif [ "${UITEM}" = HELP ] ; then
    descript
    exit
  elif [ "${UITEM:0:4}" = LINK ] ; then
    coll[${#coll[*]}]=--${item[i]}
  elif [ "${UITEM:0:2}" = UP ] ; then
    isUpdateQA=t
  else
    continue
  fi

  unset item[i]
done
item=( ${item[*]} )
test ${#item[*]} -eq 0 && item=(${defaultProject})

getSrcPath $zeroArg

test ${#QA_PATH} -eq 0  && QA_PATH=$currPath/$package
coll[${#coll[*]}]="-q ${QA_PATH}"
test ${QA_PATH} != ${currPath} && cd ${QA_PATH}

log ${allArgs}

if grep -i -q auto-up .conf &> /dev/null; then
  isUpdateQC=t
fi

test ${isUpdateQA:-f} = t && git_update

exec scripts/install.sh ${debug} --pack=${package} --continue_log \
  --zlib=${zlib} --hdf5=${hdf5} --netcdf=${netcdf} --udunits=${udunits} \
  ${coll[*]} ${item[*]}
