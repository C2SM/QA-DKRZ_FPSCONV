#! /bin/bash

package=QA-DKRZ

export CONDA_CMOR_CHANNELS='-c,conda-forge,-c,pcmdi,-c,uvcdat'
export CONDA_QA_CHANNELS='-c,conda-forge,-c,h-dh'
#export CONDA_QA_CHANNELS='-c,birdhouse,-c,conda-forge,--channel birdhouse/label/dev'

export CONDA_QA_ENV
export CONDA_CMOR_ENV

export CONDA_QA_NAME=qa-dkrz
export CONDA_CMOR_NAME=cmor

hdf5=hdf5-1.8.17
netcdf=netcdf-4.4.1
zlib=zlib-1.2.8
udunits=udunits-2.2.20

default_prj=CORDEX

# options with auto-update feature (option: --auto-up_feature)
#   CMOR_LLNL:     the CMOR checker (D. Nadeau, LLNL)
#   GIT_QA:         all QA updates touching write-protected locations
#   QA_SRC:         QA sources; disabled for conda-installed QA-DKRZ
#   PROJECT_TABLES: Project related tables and programs; PROJECT substituted by
#                   current projects name(s).

descript()
{
  echo "Usage: install [options] [projects[s]]"
  echo "Purpose: Install/update 'the Quality Control Software Package'"
  echo "for checking climate simulation meta-data provided in netCDF format."
  echo "Details at https://redmine.dkrz.de/projectss/cordex/wiki/DKRZ_QC_Tool"
  echo ''
  echo "Options:"
  echo "  -B                Unconditionally re-make all QA executables."
  echo "  -d                Execute 'make' with debugging information."
  echo "  -h                Display usage and exit."
  echo "  --auto-up[=expr]  Control automatic updates from the repository at the"
  echo "                    beginning of a run. Valid expressions for enabling:"
  echo "                    enable, e, t. Suspending: disable, d, suspend, s."
  echo "  --build           Download and build required libraries."
  echo "  --conda-cmor-path=path Alias: --ccp=path"
  echo "                    If a separate conda is neither in PATH nor aliased."
  echo "  --debug[=script]  Display execution commands. If the name of a script"
  echo "                    is assigned, then debug only this one."
  echo "  --force           Force update of the given project."
  echo "  --help            Display usage and exit."
  echo "  --home=path       Same as QA_HOME."
  echo "  --lcf=path        Location of .qa-dkrz/config.txt [~]."
  echo "  --link=path       Hard links of external NetCDF installations from the"
  echo "                    directories in 'your-path/${package}/local'."
  echo "                    Shared by all hdf, netcdf, udunits  and zlib."
  echo "  --link_type=path  Same as for 'link' but just for type=netcdf, hdf, zlib, or udunits"
  echo "  --net=no          Disable internet access."
  echo "  --qa-home=path    Location of the projects tables and external programs."
  echo "                    Also for user-modified QA tables."
  echo "  --set-default-project=PROJECT "
  echo "  --show-inst       Display properties of the current installation."
  echo "  --up[date]        Update external packages from the repository."
  echo "                    Note: not for netCDF, HDF5, udunits2 or zlib."
  echo "  --up              Update the qa-dkrz package when installed by conda."
  echo "  --update-frequency=num"
  echo "                    --uf and any --uXXX_FYYY is valid; num in days with default [1]"
  echo ""
  echo "  projects-name(s)   At present CF, CMIP5, and CORDEX; the latter by default."
}

log()
{
  if [ ${isContinueLog:-f} = f ] ; then
    isContinueLog=t

    local logTxt="\n$(date +'%F_%T'):"
    echo -e "${logTxt} install $*" >> install.log
  fi

  return
}

saveAsCycle()
{
  for f in $* ; do
    if [ ! \( -f $f -o -d $f \) ] ; then
      echo "install.saveAsCycle: no such file or directory $f"
      return
    fi

    local ext val x
    local maxVal fs fx

    maxVal=0
    fs=( $(ls -d $f.* 2> /dev/null) )

    for fx in ${fs[*]} ; do
      ext=${fx##*.}

      if val=$(expr match $ext '\([[:digit:]]\+$\)' 2> /dev/null) ; then
        test ${val:-0} -gt ${maxVal} && maxVal=${val}
      fi
    done

    mv $f ${f}.$((++maxVal)) 2> /dev/null
  done
}

tr_option()
{
  local line="${!1}"
  local i pref

#  test "${line:0:1}" != '-' && return

  for(( i=0 ; i < ${#line} ; ++i )) ; do
    if [ ${line:i:1} != - ] ; then
      line=${line:i}
      break
    fi
  done

  local sz
  sz=${#line}

  for((i=0 ; i < sz ; ++i )) ; do
    test "${line:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    if [ ${i} -gt 1 ] ; then
      line=$( echo "${line/% /}" | tr "[:lower:]" "[:upper:]" )
      line=$( echo "${line}" | tr "-" "_" )
    fi
  else
    local tmp0="${line:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    tmp0=$( echo "${tmp0}" | tr "-" "_" )
    line="${tmp0}""${line:i}"
  fi

  eval ${1}=\${line}

  return
}

update()
{
  local prj

  if ! . ${QA_SRC}/scripts/inqRunEnv ${prj} ; then
    test $? -gt 0 && isForceUpdate=t  # look for updates
  fi

  # for searching updates after some days; default: once a day
  # set variable today [ days since 1970 ]

  if [ ${CONDA_PATH} ] ; then
    test ! ${CONDA_QA_ENV} && \
      . ${QA_SRC}/scripts/parseConfigFile CONDA_QA_ENV

    if [ ${isForceUpdate:-f} = t ] || \
         ! . ${QA_SRC}/scripts/parseConfigFile NEXT_QA_UPDATE --inquire
    then
      if update_CONDA "${CONDA_QA_NAME}" "${CONDA_QA_CHANNELS}" \
                      "${CONDA_PATH}"    "${CONDA_QA_ENV}" ; then

        . ${QA_SRC}/scripts/parseConfigFile NEXT_QA_UPDATE ${isForceUpdate:+--force}
        . ${QA_SRC}/scripts/parseConfigFile CONDA_QA_ENV=$CONDA_QA_ENV
      fi
    fi
  elif [ -d ${QA_SRC}/.git ] ; then
     if ! update_QA_SRC ; then
       return $?
     fi
  fi

  # now for non-QA-DKRZ tables and programs
  for prj in $* ; do
    test "${PROJECT_AS}" && prj=${PROJECT_AS}

    if ! update_external $prj ; then
      return $?
    fi

    test "${PROJECT_AS}" && break
  done

  # revison num of the package
  local currVersion
  ${QA_SRC}/scripts/getVersion currVersion
  . ${QA_SRC}/scripts/parseConfigFile QA_REVISION${currVersion:+=}${currVersion}

  if ! mkdir -p ${QA_HOME}/tables  ; then
    echo "could not mkdir -p ${QA_HOME}/tables"
    exit 41
  fi

  # note that QA_HOME points to .qa-dkrz wherever it is located
  rsync -auz --exclude '*~' $QA_SRC/tables ${QA_HOME} &> /dev/null

  return 0
}

update_CONDA()
{
  local conda_name=$1      # is always defined
  local conda_channels=$2  # is always defined
  local conda_path=$3      # is always defined
  local conda_env=$4       # could be empty
  local action=$5          # could be empty

  test ${conda_env:-none} = none && conda_env=cmor
  test ! ${action} && action=update

  test ${INTERNET:-t} = f && return
  test "${conda_env}" = '-n ' && conda_env=

  if [ ! -w "${QA_SRC}" ] ; then
    echo "no write-permission for ${QA_SRC}"
    exit 41
  elif [ ${action} = update ] ; then
    # look for a new conda-built package
    echo "searching ${conda_name} updates" > ${TTY}

    set -f
    ${conda_path} ${action} ${conda_env:+-n ${conda_env}} \
                       ${conda_channels//,/ } \
                       ${conda_name} &> /dev/null << EOF
y
EOF

    set +f
  else
    # only CMOR could here be created
    ${conda_path} ${action} ${conda_env:+-n ${conda_env}} \
            ${CONDA_CMOR_CHANNELS//,/ } ${CONDA_CMOR_NAME} > ${TTY}

    if [ $? -eq 0 ] ; then
      if [ ${CONDA_CMOR_ENV} ] ; then
        PrePARE=${conda_path}/envs/${CONDA_CMOR_ENV}/bin/PrePARE
        . $QA_SRC/scripts/parseConfigFile CONDA_CMOR_ENV=${conda_env}
      else
        PrePARE=${conda_path}/bin/PrePARE
        . $QA_SRC/scripts/parseConfigFile CONDA_CMOR_ENV=none
      fi

      . $QA_SRC/scripts/parseConfigFile \
         PrePARE=${conda_path}/envs/cmor/bin/PrePARE

      echo "Please, note that activation/deactivation is not required in this place." > $TTY
    fi
  fi

  return 0
}

update_external()
{
  test ${INTERNET:-t} = f && return 0

  local prj=$1

  # check it here in order to prevent an update of the config-file in case
  # that the installation failed or was terminated.

  if [ ${isForceUpdate:-f} = t ] || \
         ! . ${QA_SRC}/scripts/parseConfigFile NEXT_${prj}_UPDATE --inquire
  then
     . ${QA_SRC}/scripts/get_externalSources \
         -P $prj --qa-src=${QA_SRC} \
         --qa-home=${QA_HOME} --config_file=${CONFIG_FILE} \
         ${isUpdate:+--update} ${isForceUpdate:+--force-update}

     test $? -gt 0 && exit 41

     local nextUpdate
     eval nextUpdate=\$NEXT_${prj}_UPDATE

  . ${QA_SRC}/scripts/parseConfigFile NEXT_${prj}_UPDATE ${isForceUpdate:+--force}
  fi

  return 0
}

update_QA_SRC()
{
  if [ ${INTERNET:-t} = t ] ; then
    if [ ${isForceUpdate:-f} = t ] || \
           ! . ${QA_SRC}/scripts/parseConfigFile NEXT_QA_UPDATE --inquire
    then
      if [ ! -f ${QA_SRC}/.ignore_GitHub ] ; then
        cd ${QA_SRC}

        local md5_0_inst
        md5_0_inst=$( md5sum ${QA_SRC}/install | awk '{print $1}' )
        local md5_0_inq
        md5_0_inq=$( md5sum ${QA_SRC}/scripts/inqRunEnv | awk '{print $1}' )

        # is qa-dkrz going to change?
        local date_i=$(ls -l \
             --time-style=+'%s' ${QA_SRC}/install \
             | awk '{print $6}' 2> /dev/null )
        local date_inq=$(ls -l \
             --time-style=+'%s' ${QA_SRC}/scripts/inqRunEnv \
             | awk '{print $6}' 2> /dev/null )

        # always from master
        local branch=$( ${QA_SRC}/scripts/getVersion func=getGitBranch)
        # test "${branch}" != master &&  git checkout master &> /dev/null

        git fetch && git reset --hard origin/${branch} &> /dev/null
#       git pull --no-edit -q origin master &> /dev/null

        if [ $? -gt 0 ] ; then
          echo "git-ting QA-DKRZ failed"
          return 1
        fi

        local isRestart=0
        if [ ${date_i} != $( ls -l \
             --time-style=+'%s' ${QA_SRC}/install \
             | awk '{print $6}' 2> /dev/null ) ] ; then
          isRestart=1
        elif [ ${date_inq} != $( ls -l \
               --time-style=+'%s' ${QA_SRC}/scripts/inqRunEnv \
               | awk '{print $6}' 2> /dev/null ) ] ; then
            isRestart=1
        fi

        test ${isRestart} -eq 1 && exec ${QA_SRC}/install ${initialArgs[*]}

        . ${QA_SRC}/scripts/parseConfigFile NEXT_QA_UPDATE ${isForceUpdate:+--force}
      fi
    fi
  fi

  return 0
}

# ----- main ------

zeroArg=$0
initialArgs=($*)

if [ $# -gt 0 ] ; then
  # safe arguments
  sArgs=($*)

  # higher priority options
  for(( i=0 ; i < ${#sArgs[*]} ; ++i )) ; do
    # some args are accepted without '--'
    A="${sArgs[i]}"
#    tr_option A
    A=$( echo "${A/% /}" | tr "[:lower:]" "[:upper:]" )

    if [ "${A:0:5}" = AUTO_ ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:5}" = DEBUG ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:4}" = HELP ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:4}" = LINK ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:6}" = ONLY-Q ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:3}" = SRC  ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    elif [ "${A:0:2}" = UP ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
    fi

    if [ "${A%=*}" = 'DEBUG' ] ; then
      test ${A} = 'DEBUG' -o ${A#*=} = ${0##*/} && set -x
    fi
  done
fi

prj=${defaultProject}

while getopts BdhT:-: option ${sArgs[*]}
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  case $option in
    -)  OPTVAL=${OPTARG#*=}
        OPTNAME=${UOPTARG%%=*}

        if [ "${OPTNAME:0:1}" = C ] ; then
          name_0=${OPTNAME%%_*}
          name_1=${OPTNAME#*_}

          if [ "${OPTNAME}" = CF \
               -o \( "${name_0:0:1}" = C -a "${name_1:0:1}" = F \) ]
          then
            isDisplacedConfigFile=t
            if [ ${UOPTARG%=*} != ${OPTNAME} ] ; then
              displacedConfigFile=${OPTVAL}
            fi
          fi
        elif [ "${OPTNAME}" = HOME ] ; then
          export QA_HOME=${OPTVAL}
        elif [ "${OPTNAME}" = PROJECT_AS ] ; then
          prj="${OPTVAL}"
        elif [ "${OPTNAME}" = QA_HOME ] ; then
          export QA_HOME=${OPTVAL}
        elif [ "${OPTNAME}" = WORK ] ; then
          export QA_HOME=${OPTVAL}
        fi
        ;;
   \?)  ;;
  esac
done

if [ ${isDisplacedConfigFile} ] ; then
  if [ ! "${displacedConfigFile}" ] ; then
    if [ ${QA_HOME} ] ; then
      displacedConfigFile=${QA_HOME}
    else
      echo "option --cf requires provision of --qa-home"
      exit 1
    fi
  fi
else
  displacedConfigFile=${HOME}
fi

export CONFIG_FILE=$displacedConfigFile/.qa-dkrz/config.txt
if [ ! -f $displacedConfigFile/.qa-dkrz/config.txt ] ; then
  mkdir -p ${displacedConfigFile}/.qa-dkrz
  touch $CONFIG_FILE
fi

THIS=${0%/*}
if [ ${THIS} = $0 -o "${THIS:0:1}" = '.' ] ; then
  THIS=$(pwd)
fi

test ${THIS##*/} = scripts && THIS=${THIS%/*}

# resolve symbolic links if any
. ${THIS}/scripts/getSrcPath $THIS

# is it in a conda built?
. ${QA_SRC}/scripts/getCondaPath

OPTIND=
while getopts BdhT:-: option ${sArgs[*]}
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  case $option in
    B)  coll[${#coll[*]}]=-B ;;
    d)  coll[${#coll[*]}]=-d ;;
    h)  descript
        exit 41 ;;
    T)  TTY="${OPTARG}" ;;
    -)  OPTVAL=${OPTARG#*=}
        OPTNAME=${UOPTARG%%=*}

        if [ "${UOPTARG:0:7}" = AUTO_UP ] ; then
          for OV in ${OPTVAL//,/ } ; do
            tr_option OV
            if [ ${OV:0:1} = D -o ${OV:0:1} = F -o ${OV:0:1} = S ] ; then
              OV=disable
            else
              OV=enable
            fi
            . ${QA_SRC}/scripts/parseConfigFile AUTO_UPDATE=${OV}
          done
          continue
        elif [ "${OPTNAME}" = BUILD ] ; then
          isBuild=t
        elif [ "${OPTNAME}" = CONDA_BUILD ] ; then
          isCondaBuild=t
        elif [ "${OPTNAME}" = CONDA_CMOR_PATH \
                    -o "${OPTNAME}" = CCP ] ; then
          export CONDA_CMOR_PATH=${OPTVAL}
            . ${QA_SRC}/scripts/parseConfigFile \
                                CONDA_CMOR_PATH=${OPTVAL}
        elif [ ${UOPTARG:0:5} = DEBUG -o ${UOPTARG} = 'DEBUG=INSTALL' ] ; then
          DEBUG='--debug'
          set -x
        elif [ "${OPTNAME:0:5}" = FORCE ] ; then
          isForceUpdate=t
          isUpdate=t
        elif [ "${OPTNAME}" = HELP ] ; then
          descript
          exit 41
        elif [ "${OPTNAME}" = HOME ] ; then
          continue
        elif [ "${UOPTARG:0:4}" = LINK ] ; then
          isLink=t
        elif [ "${OPTNAME}" = NET ] ; then
          OPTVAL=$( echo "${OPTVAL}" | tr "[:lower:]" "[:upper:]" )
          if [ ${OPTVAL:0:1} = Y -o ${OPTVAL:0:1} = E -o ${OPTVAL:0:1} = T ] ; then
             OPTVAL=t
          elif [ ${OPTVAL:0:1} = N -o ${OPTVAL:0:1} = D -o ${OPTVAL:0:1} = F \
                   -o ${OPTVAL:0:1} = S ] ; then
             OPTVAL=f
          fi
          INTERNET=f
#          . ${QA_SRC}/scripts/parseConfigFile INTERNET=${OPTVAL}
        elif [ "${OPTNAME:0:6}" = ONLY_Q ] ; then
          :  # for backward compatibilty
        elif [ "${OPTNAME}" = PROJECT_AS ] ; then
          PROJECT_AS="${OPTVAL}"
        elif [ "${OPTNAME}" = QA_SRC ] ; then
          export QA_SRC=${OPTVAL}
        elif [ "${OPTNAME}" = QA_HOME ] ; then
          continue
        elif [ "${OPTNAME}" = SRC ] ; then
          :  # for backward compatibilty
        elif [ "${OPTNAME}" = SET_DEFAULT_PROJECT ] ; then
          default_prj=${OPTVAL}
          continue
        elif [ "${OPTNAME:0:2}" = UP ] ; then
          isUpdate=t
          continue
        elif [ "${OPTNAME:0:1}" = U ] ; then
          name_0=${OPTNAME%%_*}
          name_1=${OPTNAME#*_}

          if [ "${OPTNAME:0:2}" = UF \
               -o \( "${name_0:0:1}" = U -a "${name_1:0:1}" = F \) ] ; then
            next_period=( ${next_period[*]} ${OPTVAL//,/ } )
            continue
          fi
        elif [ "${OPTNAME}" = WORK ] ; then
          continue
        elif [ "${OPTNAME}" = HDF5 ] ; then
          hdf5=${OPTVAL}
        elif [ "${OPTNAME}" = NETCDF ] ; then
          netcdf=${OPTVAL}
        elif [ "${OPTNAME}" = ZLIB ] ; then
          zlib=${OPTVAL}
        elif [ "${OPTNAME}" = UDUNITS ] ; then
          udunits=${OPTVAL}
        fi

        # collect options, which have not been processed above
        coll[${#coll[*]}]=--${UOPTARG}
        ;;
   \?)  descript
        echo $*
        exit 1 ;;
  esac
done

shift $(( $OPTIND - 1 ))

if [ ! "${TTY}" ] ; then
  if tty -s ; then TTY=$(tty) ; fi
fi

if ! . ${QA_SRC}/scripts/which.sh git &> /dev/null ; then
  if [ ${INTERNET:-t} = t ; then
    echo "Note that either git is not installed. Running off-line requires --net=no"   > ${TTY}
    exit 1
  fi
fi

for pck in $* ; do
  PCK="${pck}"
  tr_option PCK

  if [ ${PCK:0:4} = ZLIB ] ; then
    zlib=${pck}
  elif [ ${PCK:0:4} = HDF5 ] ; then
    hdf5=${pck}
  elif [ ${PCK:0:6} = NETCDF ] ; then
    netcdf=${pck}
  elif [ ${PCK:0:7} = UDUNITS ] ; then
    udunits=${pck}
  elif [ ${PCK:0:7} = QA_HOME ] ; then
    QA_HOME=${PCK:8}
  elif [ ${PCK:0:10} = PROJECT_AS ] ; then
    PROJECT_AS=${PCK:11}
  else
#    if [ ${pck:0:1} = '-' ] ; then
#      echo -e "\nFound PROJECT name=${pck}" > $TTY
#      echo "Note that options must be provided first" > $TTY
#      exit 1
#    fi

    coll[${#coll[*]}]=$pck  # collect projects names
    projects[${#projects[*]}]=$pck
  fi
done

. ${QA_SRC}/scripts/getHomePath

. ${QA_SRC}/scripts/parseConfigFile DEFAULT_PROJECT${default_prj:+=${default_prj}}
test ${#projects[*]} -eq 0 && projects=(${default_prj})

# inquire from ~/.qa-dkrz/config.txt;
# also ensures that all names in the config.files are defined in this program
if [ ! ${isCondaBuild} ] ; then
  if [ ! ${isBuild} ] ; then
    update ${projects[*]}
  fi

  if [ ${#next_period[*]} -gt 0 ] ; then
    NEXT_VARIABLES=(QA CONDA_CMOR)
    for(( i=0 ; i < ${#projects[*]} ; ++i )) ; do
      NEXT_VARIABLES[${#NEXT_VARIABLES[*]}]=${projects[i]}
    done

    if [ ${#next_period[*]} = 1 -a ${next_period[0]} = ${next_period[0]//=/} ] ; then
       for nv in ${NEXT_VARIABLES[*]} ; do
         # apply to all
         . ${QA_SRC}/scripts/parseConfigFile NEXT_${nv}_UPDATE --set_frequency=${next_period[0]}
       done
    else
      # individual settings
      for dn in ${next_period[*]} ; do
        for nv in ${NEXT_VARIABLES[*]} ; do
          if [ ${dn%=*} = ${nv} ] ; then
        . ${QA_SRC}/scripts/parseConfigFile NEXT_${nv}_UPDATE --set_frequency=${dn#*=}
          fi
        done
      done
    fi
  fi

  test ${CONDA_PATH} && exit  # miniconda built executables
fi

pcks="--zlib=$zlib --hdf5=$hdf5 --netcdf=$netcdf --udunits=$udunits"

if [ ${isBuild:-f} = t -a ${isLink:-f} = t ] ; then
  echo "scripts/install.sh: options --build and --link exclude each other"
  exit 1
elif [ ${isBuild:-f} = t -o ${isLink:-f} = t ] ; then
  log ${initialArgs[*]}
else
  pcks=
fi

if [ "${projects[0]}" = NONE ] ; then
   echo "qa-dkrz requires PROJECT=name in the configuration or on the command-line"
   exit
fi

exec ${QA_SRC}/scripts/install.sh ${debug} --pack=${package} \
${isContinueLog:+--continue_log} ${pcks} \
${PROJECT_AS:+--PROJECT_AS=${PROJECT_AS}} \
--qa-src=${QA_SRC} ${coll[*]}
