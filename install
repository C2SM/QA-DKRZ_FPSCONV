#! /bin/bash

package=QA-DKRZ

hdf5=hdf5-1.8.17
netcdf=netcdf-4.4.1
zlib=zlib-1.2.8
udunits=udunits-2.2.20

defaultProject=CORDEX

descript()
{
  echo "Usage: install [options] [project[s]]"
  echo "Purpose: Install/update 'the Quality Control Software Package'"
  echo "for checking climate simulation meta-data provided in netCDF format."
  echo "Details at https://redmine.dkrz.de/projects/cordex/wiki/DKRZ_QC_Tool"
  echo ''
  echo "Options:"
  echo "  -B                Unconditionally re-make all QA executables."
  echo "  -d                Execute 'make' with debugging information."
  echo "  -h                Display usage and exit."
  echo "  --auto-up         Enable automatic updates from the repository at the"
  echo "                    beginning of a run. Suspended by --auto-up=d[isable]."
  echo "                    Enabled initially by default."
  echo "  --build           Download and build required libraries."
  echo "  --debug[=script]  Display execution commands. If the name of a script"
  echo "                    is assigned, then debug only this one."
  echo "  --help            Display usage and exit."
  echo "  --keep            Do not replace installed libs of the same version"
  echo "  --link=path       Hard links of external NetCDF installations from the"
  echo "                    directories in 'your-path/${package}/local'."
  echo "                    Shared by all hdf, netcdf, udunits  and zlib."
  echo "  --link_type=path  Same as for 'link' but just for type=netcdf, hdf, zlib, or udunits"
  echo "  --local=str       Path where lib and include directories are to be installed"
  echo "                    [default: QA_DKRZ/local] for both real and hard-links."
  echo "                    Note: unneccesary when install_configure points outside."
  echo "  --show-inst       Display properties of the current installation."
  echo "  --up[date]        Update the QA package from the repository."
  echo "                    Note: not for netCDF, HDF5, udunits2 or zlib."
  echo "  --work=path       Location of the .config.txt file and project tables"
  echo "                    ~/.qa-dkrz by default. Required if multiple users are"
  echo "                    to access the same set of tables."
  echo ""
  echo "  project-name(s)   At present CF, CMIP5, and CORDEX; the latter by default."
}

getHomePath()
{
  # path to the current user's home
  export QA_HOME

  if [ -w "$QA_HOME" ] ; then
    test ${QA_HOME##*/} != '.qa-dkrz' && QA_HOME=${QA_HOME}/.qa-dkrz
  else
    if [ -n "${QA_HOME}" ] ; then
      echo "no write permission to $QA_HOME"
      exit 1
    fi

    QA_HOME=~/.qa-dkrz
    if [ ! -w ${QA_HOME} ] ; then
      QA_HOME=$(pwd)/.qa-dkrz
      if [ -w $QA_HOME ] ; then
			echo "directory ${QA_HOME} is home-dir of the QA"
      else
			echo "no directory with write permission for .qa-dkrz"
			exit 1
      fi
    fi
  fi

  # the config filename and location
  if ! mkdir -p $QA_HOME 2> /dev/null ; then
    echo "could not mkdir $QA_HOME"
    exit 1
  fi

  if [ ! -w $QA_HOME ] ; then
    echo "directory $QA_HOME without write permissions,"
    echo "please, restart with added option --qa-home=path"
    exit 1
  fi

  # automatically generated and updated
  export CONFIG_FILE=$QA_HOME/config.txt

  return
}

getGitBranch()
{
   git branch | grep '*' | awk '{print $2}'
   return
}

getRevNum()
{
  # get current revision number; this determines whether it is
  # before a change of defaults happened.
  local branch currIdent

  if [ $CONDA_ENV ] ; then
    if branch=$(grep branch $QA_SRC/install.log 2> /dev/null) ; then
      branch=${branch#*=}
    fi
    if currIdent=$(grep branch $QA_SRC/install.log 2> /dev/null) ; then
      currIdent=${currIdent#*=}
    fi
  else
    branch=$(getGitBranch)
    currIdent=$(git log --pretty=format:'%h' -n 1)
  fi

  eval ${1}=${branch}-${currIdent}

  return
}

getCondaPath()
{
  local path=${1%/*}
  path=${path%/*}

  if [ -d ${path%/*}/conda-meta  ] ; then
    eval ${2}=$path/qa-dkrz
    return 0
  fi

  return 1
}

getSrcPath()
{
  # extract the path to the root of the QA package

  # is it in a conda built?
  if getCondaPath $0 QA_SRC ; then
    export QA_SRC
    CONDA_ENV=t
  fi

  test ${QA_SRC} && return

  local target isInvalid

  if [ ${1:0:1} = '/' ] ; then
    target=$1
  else
    target=$(pwd)/$1
  fi

  if [ -h $target ] ; then

    # get the link
    local link=$(ls -l $target | awk  '{print $(NF)}')

    # link is relative, so make it absolute
    test ${link:0:1} != '/' && link=${target%/*}/${link}

    getSrcPath ${link}

  elif [ -f $target ] ; then

    # a real instance, at first resolve .. and .
    # works also for . or .. in the middle of the path

    local xname=${target##*/}
    target=${target%/*}  # remove the name of the script

    local arr=( ${target//\// } )

    local i j sz
    sz=${#arr[*]}

    for(( i=1 ; i < sz ; ++i )) ; do

      if [ "${arr[i]}" = '.' ] ; then
        unset arr[i]
      elif [ "${arr[i]}" = '..' ] ; then
        j=$((i-1))

        # this takes into account adjacent . and/or .. with any depth
        while [ ! ${arr[j]} ] ; do
          j=$((j-1))
        done
        unset arr[j]
        unset arr[i]
      fi
    done

    # get rid of empty items
    arr=( ${arr[*]} )

    sz=${#arr[*]}

    local tmp
    for(( i=0 ; i < sz ; ++i )) ; do
      tmp=${tmp}/${arr[i]}

      if [ -f ${tmp}/.install_configure ] ; then
        # final check
        if [ ! -e $tmp/install ] ; then
           echo "$tmp is not QA_SRC; EXIT"
           exit
        fi

        export QA_SRC=$tmp
        break
      fi
    done

    test $i -eq $sz && isInvalid=t
  else
    isInvalid=t
  fi

  if [ ${isInvalid:-f} = t ] ; then

    local str=$(ls -l $target 2> /dev/null | awk  '{print $(NF)}')

    if [ ${#str} -gt 0 ] ; then
      str="invalid path=$0"
    else
      str="broken path=$0"
    fi

    echo "${str}"

    exit 1
  fi

  export QA_SRC=${QA_SRC}

  return
}

log()
{
  if [ ${isContinueLog:-f} = f ] ; then
    isContinueLog=t

    local logTxt="\n$(date +'%F_%T'):"
    echo -e "${logTxt} install $*" >> install.log
  fi

  return
}

saveAsCycle()
{
  for f in $* ; do
    if [ ! \( -f $f -o -d $f \) ] ; then
      echo "install.saveAsCycle: no such file or directory $f"
      return
    fi

    local ext val x
    local maxVal fs fx

    maxVal=0
    fs=( $(ls -d $f.* 2> /dev/null) )

    for fx in ${fs[*]} ; do
      ext=${fx##*.}

      if val=$(expr match $ext '\([[:digit:]]\+$\)' 2> /dev/null) ; then
        test ${val:-0} -gt ${maxVal} && maxVal=$val
      fi
    done

    mv $f ${f}.$((++maxVal)) 2> /dev/null
  done
}

tr_option()
{
  local phrase="${!1}"

  local sz i
  local sz=${#phrase}
  for((i=0 ; i < sz ; ++i )) ; do
    test "${phrase:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    phrase=$( echo "${phrase/% /}" | tr "[:lower:]" "[:upper:]" )
    phrase=$( echo "${phrase}" | tr "-" "_" )
  else
    local tmp0="${phrase:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    tmp0=$( echo "${tmp0}" | tr "-" "_" )
    phrase="${tmp0}""${phrase:i}"
  fi

  eval ${1}=\${phrase}
  return
}

update()
{
  # search for updates only once a day
  local today=$( date '+%Y%m%d' )

  if . $QA_SRC/scripts/updateConfigFile.txt QA_UPDATE=${today} \
        || [ ${isUpdateQA:-f} = t ]; then
    if [ $CONDA_ENV ] ; then
      # look for a new conda-built package
      local tmp
      declare -a tmp
      tmp=( $(conda search -c birdhouse -c conda-forge qa-dkrz 2> /dev/null) )

      local i item
      for(( i=0 ; i < ${#tmp[*]} ; ++i )) ; do
        if [ ${tmp[i]} = '*' ] ; then
          item=${tmp[++i]}
          item=${item}-${tmp[++i]}

          if ! . $QA_SRC/scripts/updateConfigFile.txt CONDA_BUILD=$item ; then
            conda update -c birdhouse -c conda-forge qa-dkrz &> /dev/null

            getRevNum packRev

            exitVal=101
          fi
          break
        fi
      done

    elif [ ! -f ${QA_SRC}/.ignore_GitHub ] ; then
      cd $QA_SRC

      # is qa-dkrz going to change?
      local qa_dkrzDate=$(ls -l \
           --time-style=+'%s' ${QA_SRC}/scripts/qa_dkrz \
           | awk '{print $6}' 2> /dev/null )

#      test "$(getGitBranch)" != master && \
#        git checkout master &> /dev/null
        git checkout $(getGitBranch) &> /dev/null

      git fetch && git reset --hard origin/$(getGitBranch) &> /dev/null
#      git pull --no-edit -q origin master &> /dev/null

      if [ ${qa_dkrzDate} != $( ls -l \
           --time-style=+'%s' ${QA_SRC}/scripts/qa_dkrz \
           | awk '{print $6}' 2> /dev/null ) ] ; then
        exitVal=101
      fi

      # revison num of the updated package
      getRevNum packRev
    fi
  fi


  . $QA_SRC/scripts/updateConfigFile.txt QA_REVISION${packRev:+=}$packRev

    if [ ! -d $QA_HOME/tables ] ; then
      # note that QA_HOME points to .qa-dkrz wherever it is located
      rsync -auz --exclude '*~' $QA_SRC/tables $QA_HOME &> /dev/null
    fi

    for prj in ${project[*]} ; do
      test "${PROJECT_AS}" && prj=${PROJECT_AS}

      if [ "${prj}" != CF ] ; then
        ${QA_SRC}/scripts/get_project_tables \
            -P $prj --qa_path=${QA_SRC} ${DEBUG} \
            --config_file=$CONFIG_FILE ${isForceUp:+--force-update} \
            ${QA_HOME}/tables/projects/${prj}

        test $? -gt 0 && exit 1
      fi

      test "${PROJECT_AS}" && break
    done

    ${QA_SRC}/scripts/get_cfconventions \
        --qa_path=${QA_SRC} ${DEBUG} \
        --config_file=$CONFIG_FILE \
        ${QA_HOME}/tables/projects/CF

    # error message already issued
    test $? -gt 0 && exit 1
#  fi

  return
}


# ----- main ------
zeroArg=$0
allArgs=($*)

if [ $# -gt 0 ] ; then
  # safe arguments
  sArgs=($*)

  # higher priority options
  for(( i=0 ; i < ${#sArgs[*]} ; ++i )) ; do
    # some args are accepted without '--'
    A="${sArgs[i]}"
    tr_option A

    if [ "${A:0:5}" = AUTO_ -o "${A:0:5}" = "AUTO-" ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
      A="--${A}"
    elif [ "${A:0:5}" = DEBUG ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
      A="--${A}"
    elif [ "${A:0:4}" = HELP ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
      A="--${A}"
    elif [ "${A:0:4}" = LINK ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
      A="--${A}"
    elif [ "${A:0:6}" = ONLY-Q ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
      A="--${A}"
    elif [ "${A:0:3}" = SRC  ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
      A="--${A}"
    elif [ "${A:0:2}" = UP ] ; then
      sArgs[${i}]=--${sArgs[${i}]}
      A="--${A}"
    fi

    if [ "${A%=*}" = '--DEBUG' ] ; then
      test ${A} = '--DEBUG' -o ${A#*=} = ${0##*/} && set -x
    fi
  done
fi

while getopts Bdh-: option ${sArgs[*]}
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  case $option in
    B)  coll[${#coll[*]}]=-B ;;
    d)  coll[${#coll[*]}]=-d ;;
    h)  descript
        exit ;;
    -)  OPTVAL=${OPTARG##*=}
        OPTNAME=${UOPTARG%=*}

        if [ "${UOPTARG:0:7}" = AUTO_UP -o "${UOPTARG:0:7}" = AUTO-UP ] ; then
          if [ "${OPTVAL}" ] ; then
            AUTO_UPDATE=AUTO_UPDATE=${OPTVAL}
          else
            AUTO_UPDATE=AUTO_UPDATE=enabled
          fi
        elif [ "${OPTNAME}" = BUILD ] ; then
          isBuild=t
        elif [ ${UOPTARG:0:5} = DEBUG -o ${UOPTARG} = 'DEBUG=INSTALL' ] ; then
          DEBUG='--debug'
          set -x
        elif [ "${OPTNAME}" = FORCE_UPDATE ] ; then
          isForceUp=t
          isUpdateQA=t
        elif [ "${OPTNAME}" = GET_TABLES ] ; then
          GET_TABLES=t
        elif [ "${OPTNAME}" = HELP ] ; then
          descript
          exit
        elif [ "${UOPTARG:0:4}" = LINK ] ; then
          isLink=t
        elif [ "${UOPTARG:0:6}" = ONLY_Q ] ; then
          :  # for backward compatibilty
        elif [ "${OPTNAME}" = PROJECT_AS ] ; then
          PROJECT_AS="${OPTVAL}"
        elif [ "${OPTNAME}" = QA_SRC ] ; then
          export QA_SRC=${OPTVAL}
        elif [ "${OPTNAME}" = QA_HOME ] ; then
          QA_HOME=${OPTVAL}
        elif [ "${OPTNAME}" = SRC ] ; then
          :  # for backward compatibilty
        elif [ "${OPTNAME}" = SET_DEFAULT_PROJECT ] ; then
          DEF_PRJ=${OPTVAL}
          continue
        elif [ "${UOPTARG:0:2}" = UP ] ; then
          isUpdateQA=t
        elif [ "${OPTNAME}" = WORK ] ; then
          QA_HOME=${OPTVAL}
        elif [ "${OPTNAME}" = HDF5 ] ; then
          hdf5=${OPTVAL}
        elif [ "${OPTNAME}" = NETCDF ] ; then
          netcdf=${OPTVAL}
        elif [ "${OPTNAME}" = ZLIB ] ; then
          zlib=${OPTVAL}
        elif [ "${OPTNAME}" = UDUNITS ] ; then
          udunits=${OPTVAL}
        fi

        # collect options, which have not been processed above
        coll[${#coll[*]}]=--${OPTARG}
        ;;
   \?)  descript
        echo $*
        exit 1 ;;
  esac
done

shift $(( $OPTIND - 1 ))

for pck in $* ; do
  PCK="${pck}"
  tr_option PCK

  if [ ${PCK:0:4} = ZLIB ] ; then
    zlib=${pck}
  elif [ ${PCK:0:4} = HDF5 ] ; then
    hdf5=${pck}
  elif [ ${PCK:0:6} = NETCDF ] ; then
    netcdf=${pck}
  elif [ ${PCK:0:7} = UDUNITS ] ; then
    udunits=${pck}
  elif [ ${PCK:0:7} = QA_HOME ] ; then
    QA_HOME=${PCK:8}
    isForceUp=t
  elif [ ${PCK:0:10} = PROJECT_AS ] ; then
    PROJECT_AS=${PCK:11}
  else
    coll[${#coll[*]}]=$pck  # collect project names
    project[${#project[*]}]=$pck
  fi
done

getSrcPath $zeroArg  # sets also CONDA_ENV
getHomePath

if . $QA_SRC/scripts/updateConfigFile.txt \
           DEFAULT_PROJECT${DEF_PRJ:+=}${DEF_PRJ} ; then
  defPrj=--default_project=${DEF_PRJ}
else
  defPrj=--default_project=$defaultProject
fi

test ! "$project" && project=(${defPrj#*=})

update

test ${CONDA_ENV} && exit  # miniconda built executables

pcks="--zlib=$zlib --hdf5=$hdf5 --netcdf=$netcdf --udunits=$udunits"

if [ ${isBuild:-f} = t -a ${isLink:-f} = t ] ; then
  echo "scripts/install.sh: options --build and --link exclude each other"
  exit 1
elif [ ${isBuild:-f} = t -o ${isLink:-f} = t ] ; then
  log ${allArgs[*]}
else
  pcks=
fi

if [ "${project[0]}" = NONE ] ; then
   echo "qa-dkrz requires PROJECT=name in the configuration or on the command-line"
   exit
fi

exec $QA_SRC/scripts/install.sh ${debug} --pack=${package} \
${isContinueLog:+--continue_log} ${pcks} ${defPrj} \
${PROJECT_AS:+--PROJECT_AS=${PROJECT_AS}} ${coll[*]}
